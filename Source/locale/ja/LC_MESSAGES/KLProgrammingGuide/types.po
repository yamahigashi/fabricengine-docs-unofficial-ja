#
msgid ""
msgstr ""
"Project-Id-Version: Fabric Engine 2.0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-01-23 12:42+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../source/KLProgrammingGuide/types.rst:4
msgid "The KL Type System"
msgstr "KLの型システム"

#: ../../source/KLProgrammingGuide/types.rst:6
msgid ""
"Unlike most languages, KL has a dynamic type system that is inherited "
"from the Fabric environment.  In most cases, compound types are "
"registered from the Fabric environment running in a dynamic language (eg."
" JavaScript or Python); those types are then automatically made available"
" to KL programs running in that environment.  This does not, however, "
"affect the semantics of the language; the KL type system can still be "
"explained purely from the point of view of the language itself."
msgstr ""
"多くの言語と異なり、KLは動的な型システム ―Fabricの環境から引き継ぐ を持ちます。複合型の登録は、動的言語（例えば JavaScriptや"
" "
"Python）で実行されているFabric環境を通じ行われます。これらの型は自動的にその実行環境においてKLプログラムから利用可能となります。ただし、このことは言語のセマンティクス（プログラム意味論）に影響をあたえるものではありません。つまりKLの型システムは依然として、純粋に、その言語自体の観点から説明できます。"

#: ../../source/KLProgrammingGuide/types.rst:8
msgid ""
"Like most programming languages, KL has support for both a fixed set of "
"base types from which other types are derived as well as different kinds "
"of derived types."
msgstr "多くの他のプログラミング言語同様にKLには、他の型へと継承できる定められた数の基本型だけでなく、異なる種の派生型の数々もサポートします。"

#: ../../source/KLProgrammingGuide/types.rst:14
msgid "Base Types"
msgstr "基本型（Base Types）"

#: ../../source/KLProgrammingGuide/types.rst:16
msgid "The base types in KL are the following:"
msgstr "KLでの基本型は以下："

#: ../../source/KLProgrammingGuide/types.rst:19
msgid ":code:`Boolean`"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:19
msgid "can be either :code:`true` or :code:`false`"
msgstr ":code:`true` もしくは :code:`false` のいずれかをとる"

#: ../../source/KLProgrammingGuide/types.rst:22
#: ../../source/KLProgrammingGuide/types.rst:143
msgid "``UInt8``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:22
#: ../../source/KLProgrammingGuide/types.rst:143
msgid "an 8-bit unsigned integer"
msgstr "8-bit 符号なし整数（unsigned integer）"

#: ../../source/KLProgrammingGuide/types.rst:25
#: ../../source/KLProgrammingGuide/types.rst:146
msgid "``Byte``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:25
#: ../../source/KLProgrammingGuide/types.rst:146
msgid "an alias for ``UInt8``"
msgstr "``UInt8`` のエイリアス（別名）"

#: ../../source/KLProgrammingGuide/types.rst:28
#: ../../source/KLProgrammingGuide/types.rst:149
msgid "``SInt8``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:28
#: ../../source/KLProgrammingGuide/types.rst:149
msgid "an 8-bit signed integer"
msgstr "8-bit 符号つき整数（signed integer）"

#: ../../source/KLProgrammingGuide/types.rst:31
#: ../../source/KLProgrammingGuide/types.rst:152
msgid "``UInt16``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:31
#: ../../source/KLProgrammingGuide/types.rst:152
msgid "a 16-bit unsigned integer"
msgstr "16-bit 符号なし整数"

#: ../../source/KLProgrammingGuide/types.rst:34
#: ../../source/KLProgrammingGuide/types.rst:155
msgid "``SInt16``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:34
#: ../../source/KLProgrammingGuide/types.rst:155
msgid "a 16-bit signed integer"
msgstr "16-bit 符号つき整数"

#: ../../source/KLProgrammingGuide/types.rst:37
#: ../../source/KLProgrammingGuide/types.rst:158
msgid "``UInt32``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:37
#: ../../source/KLProgrammingGuide/types.rst:158
msgid "a 32-bit unsigned integer"
msgstr "32-bit 符号なし整数"

#: ../../source/KLProgrammingGuide/types.rst:40
#: ../../source/KLProgrammingGuide/types.rst:173
msgid "``Count``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:40
msgid "an alias for ``UInt32``; used to represent cardinal numbers"
msgstr "``UInt32`` へのエイリアス。基数を表すために使用される。"

#: ../../source/KLProgrammingGuide/types.rst:43
#: ../../source/KLProgrammingGuide/types.rst:176
msgid "``Index``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:43
msgid "an alias for ``UInt32``; used to represent ordinal numbers"
msgstr "``UInt32`` へのエイリアス。序数を表すために使用される。"

#: ../../source/KLProgrammingGuide/types.rst:46
#: ../../source/KLProgrammingGuide/types.rst:182
msgid "``Size``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:46
msgid "an alias for ``UInt32``"
msgstr "``UInt32`` へのエイリアス"

#: ../../source/KLProgrammingGuide/types.rst:49
#: ../../source/KLProgrammingGuide/types.rst:161
msgid "``SInt32``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:49
#: ../../source/KLProgrammingGuide/types.rst:161
msgid "a 32-bit signed integer"
msgstr "32-bit 符号つき整数"

#: ../../source/KLProgrammingGuide/types.rst:52
#: ../../source/KLProgrammingGuide/types.rst:164
msgid "``Integer``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:52
#: ../../source/KLProgrammingGuide/types.rst:164
msgid "an alias for ``SInt32``"
msgstr "``SInt32`` へのエイリアス"

#: ../../source/KLProgrammingGuide/types.rst:55
#: ../../source/KLProgrammingGuide/types.rst:167
msgid "``UInt64``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:55
#: ../../source/KLProgrammingGuide/types.rst:167
msgid "a 64-bit unsigned integer"
msgstr "64-bit 符号なし整数"

#: ../../source/KLProgrammingGuide/types.rst:58
#: ../../source/KLProgrammingGuide/types.rst:179
msgid "``DataSize``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:58
msgid "an alias for ``UInt64``; used to represent sizes of blocks of memory"
msgstr "``UInt64`` へのエイリアス。メモリブロックのサイズを表すために使用される"

#: ../../source/KLProgrammingGuide/types.rst:61
#: ../../source/KLProgrammingGuide/types.rst:170
msgid "``SInt64``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:61
#: ../../source/KLProgrammingGuide/types.rst:170
msgid "a 64-bit signed integer"
msgstr "64-bit 符号つき整数"

#: ../../source/KLProgrammingGuide/types.rst:64
#: ../../source/KLProgrammingGuide/types.rst:367
msgid "``Float32``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:64
msgid "a 32-bit IEEE floating point"
msgstr "32-bit IEEE浮動小数点数"

#: ../../source/KLProgrammingGuide/types.rst:67
#: ../../source/KLProgrammingGuide/types.rst:373
msgid "``Scalar``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:67
#: ../../source/KLProgrammingGuide/types.rst:373
msgid "an alias for ``Float32``"
msgstr "``Float32`` へのエイリアス"

#: ../../source/KLProgrammingGuide/types.rst:70
#: ../../source/KLProgrammingGuide/types.rst:370
msgid "``Float64``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:70
msgid "a 64-bit IEEE floating point"
msgstr "64-bit IEEE浮動小数点数"

#: ../../source/KLProgrammingGuide/types.rst:73
msgid "``String``"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:73
msgid "a sequence of zero or more characters"
msgstr "ゼロ個以上の文字の連なり"

#: ../../source/KLProgrammingGuide/types.rst:80
msgid "The :code:`Boolean` Type"
msgstr "論理型（ :code:`Boolean` Type）"

#: ../../source/KLProgrammingGuide/types.rst:82
msgid ""
"The value of an expression of :code:`Boolean` type is either logical true"
" or logical false.  The type has the following properties:"
msgstr ":code:`Boolean` 型の式の値は、論理真もしくは論理偽です。以下の特徴を持ちます："

#: ../../source/KLProgrammingGuide/types.rst:84
msgid ""
"The constants :code:`true` and :code:`false` are :code:`Boolean` values "
"with logical values true and false, respectively."
msgstr "定数 :code:`true` 及び :code:`false` はそれぞれ論理値である真、偽の :code:`Boolean` です。"

#: ../../source/KLProgrammingGuide/types.rst:86
msgid "All other base types cast to Boolean as follows:"
msgstr "他の型から Boolean 型へのキャスト："

#: ../../source/KLProgrammingGuide/types.rst:88
msgid ""
"All values of integer type (eg. ``UInt32``, ``Byte``) cast to true if and"
" only if the value is non-zero"
msgstr "全整数型（例えば ``UInt32``, ``Byte``)は値が 0 ではない時のみ true となります。"

#: ../../source/KLProgrammingGuide/types.rst:90
msgid ""
"All values of floating-point type (ie. ``Float32`` and ``Float64``) cast "
"true if and only if the value is not equal to ``0.0`` or ``-0.0``"
msgstr ""
"全浮動小数点数型（すなわち ``Float32`` and ``Float64``）は値が  ``0.0`` もしくは ``-0.0`` "
"と等しくない場合にのみ true となります。"

#: ../../source/KLProgrammingGuide/types.rst:92
msgid ""
"``String`` values cast to true if and only if their length is greater "
"than zero"
msgstr "``String`` の値はその長さが 0以上 の場合のみ true となります。"

#: ../../source/KLProgrammingGuide/types.rst:94
msgid "Arrays and dictionaries cast to true if and only if they are non-empty"
msgstr "配列と辞書型はカラでない場合のみ true となります。"

#: ../../source/KLProgrammingGuide/types.rst:96
msgid ""
"By default, structures do not cast to :code:`Boolean`, but you can "
"implement the cast if desired by creating a :code:`Boolean` constructor "
"that takes the structure as a parameter; see :ref:`KLPG.constructor`"
msgstr ""
"構造体はそのままでは  :code:`Boolean` "
"型へキャストできません。キャスト可能にするには引数パラメータにキャストを行いたい構造体をとる :code:`Boolean` "
"コンストラクタを実装します。 :ref:`KLPG.constructor` を参照してください。"

#: ../../source/KLProgrammingGuide/types.rst:98
msgid "For operators:"
msgstr "演算子"

#: ../../source/KLProgrammingGuide/types.rst:100
msgid ""
"None of the arithmetic operators (binary ``+``, ``-``, ``*``, ``/``, "
"``%`` as well as unary ``-`` and ``+``) are valid for :code:`Boolean` "
"values"
msgstr ""
"算術演算子 (2項演算子 ``+``, ``-``, ``*``, ``/``, ``%`` だけでなく 単独の ``-`` and ``+``)"
" はいずれも :code:`Boolean` の値には無効です。"

#: ../../source/KLProgrammingGuide/types.rst:101
msgid ""
"Only the ``==`` and ``!=`` comparison operators are valid for "
":code:`Boolean` values"
msgstr ":code:`Boolean` の値には比較演算子 ``==`` と ``!=`` のみ有効です。"

#: ../../source/KLProgrammingGuide/types.rst:102
msgid ""
"All of the bitwise binary operators (``|``, ``&amp;``, ``^`` and ``~``) "
"are valid for :code:`Boolean` values and treat the value as if it were a "
"single bit"
msgstr ""
"全2項論理演算子(``|``, ``&amp;``, ``^`` and ``~``) は :code:`Boolean` "
"値で有効です。値を単一のビットであるかのように扱います。"

#: ../../source/KLProgrammingGuide/types.rst:104
msgid "The following example shows the use of the :code:`Boolean` type::"
msgstr "以下に :code:`Boolean` 型の使用例を示します::"

#: ../../source/KLProgrammingGuide/types.rst:114
#: ../../source/KLProgrammingGuide/types.rst:201
#: ../../source/KLProgrammingGuide/types.rst:392
#: ../../source/KLProgrammingGuide/types.rst:449
#: ../../source/KLProgrammingGuide/types.rst:523
msgid "Output::"
msgstr "出力::"

#: ../../source/KLProgrammingGuide/types.rst:138
msgid "Integer Types"
msgstr "整数型（Integer Types）"

#: ../../source/KLProgrammingGuide/types.rst:140
msgid ""
"The ``UInt8``, ``SInt8``, ``UInt16``, ``SInt16``, ``UInt32``, ``SInt32``,"
" ``UInt64`` and ``SInt64`` types, as well as their aliases (``Byte``, "
"``Integer``, ``Size``, ``Count``, ``Index`` and ``DataSize``), are "
"collectively known as the :index:`integer types` and represent whole "
"integers.  These types differ only in their bit width and whether they "
"are signed or unsigned, as follows:"
msgstr ""
"``UInt8``, ``SInt8``, ``UInt16``, ``SInt16``, ``UInt32``, ``SInt32``, "
"``UInt64``, ``SInt64`` 型、そしてエイリアス (``Byte``, ``Integer``, ``Size``, "
"``Count``, ``Index``, ``DataSize``), は総称して :index:`integer types` "
"として知られ、全ての整数を表現します。"

#: ../../source/KLProgrammingGuide/types.rst:173
msgid ""
"an alias for ``UInt32``.  ``Size`` is usually used to count the number of"
" elements in an array"
msgstr "``UInt32`` へのエイリアス。通常 ``Size`` は配列中の要素の数量の数え上げにしようされる。"

#: ../../source/KLProgrammingGuide/types.rst:176
msgid "an alias for ``UInt32``.  ``Index`` is usually used to index into an array"
msgstr "``UInt32`` へのエイリアス。通常  ``Index`` は配列のインデックスに使用される。"

#: ../../source/KLProgrammingGuide/types.rst:179
msgid ""
"an alias for ``UInt64``.  ``DataSize`` is used to represent the size of a"
" block of memory and is the return type for the ``dataSize`` method of "
"types."
msgstr "``UInt64`` へのエイリアス。メモリブロックのサイズを表すために使用され、 ``dataSize`` メッソドの返り値の型として使用される。"

#: ../../source/KLProgrammingGuide/types.rst:182
msgid "an alias for ``UInt32``."
msgstr "``UInt32`` へのエイリアス。"

#: ../../source/KLProgrammingGuide/types.rst:184
msgid "Integer types behave as follows:"
msgstr "整数型の振る舞い："

#: ../../source/KLProgrammingGuide/types.rst:186
msgid ""
"All of the :ref:`arithmetic <arithmetic-ops>`, :ref:`logical <logical-"
"ops>` and :ref:`bitwise <bitwise-ops>` operators work as expected for all"
" integer types."
msgstr ""
"全 :ref:`arithmetic <arithmetic-ops>`, :ref:`logical <logical-ops>`, "
":ref:`bitwise <bitwise-ops>` 演算子は整数型に対し期待通り動作します。"

#: ../../source/KLProgrammingGuide/types.rst:188
msgid ""
"Integer constants are typed using the suffixes ``s32`` for ``SInt32``, "
"``u64`` for ``UInt64``, and so on; if a suffix is omitted, the type is "
"``SInt32``.  For more details, see :ref:`integer-constants`."
msgstr ""
"整数型の定数は ``s32`` が ``SInt32``, ``u64`` が ``UInt64``, "
"などのように接尾語をともない型付けされます。接尾語を付さない場合、 ``SInt32`` となります。参照 :ref:`integer-"
"constants`."

#: ../../source/KLProgrammingGuide/types.rst:190
msgid "The following shows the use of integer types::"
msgstr "整数型の使用例::"

#: ../../source/KLProgrammingGuide/types.rst:212
msgid "Integer Atomic Methods"
msgstr "整数型のアトミックメソッド"

#: ../../source/KLProgrammingGuide/types.rst:214
msgid ""
"The integer types have a set of built-in :ref:`methods` that perform "
"atomic operations on a value of the type.  Atomic operations are used to "
"implement lock-free algorithms; for more information on atomic "
"operations, see http://en.wikipedia.org/wiki/Linearizability."
msgstr ""
"整数型は組み込み :ref:`methods` を持ちます。整数型の値に対しアトミックな操作（不可分操作、atomic "
"operation）をおこないます。アトミックな操作は、ロックフリーなアルゴリズムで実装されています。アトミックな操作については "
"http://en.wikipedia.org/wiki/Linearizability を参照してください。"

#: ../../source/KLProgrammingGuide/types.rst:229
msgid "Atomically add a value to the integer"
msgstr "整数型の値にアトミックな加算"

#: ../../source/KLProgrammingGuide/types.rst:231
#: ../../source/KLProgrammingGuide/types.rst:260
msgid "The value to add"
msgstr "加算する値"

#: ../../source/KLProgrammingGuide/types.rst:232
#: ../../source/KLProgrammingGuide/types.rst:246
#: ../../source/KLProgrammingGuide/types.rst:261
#: ../../source/KLProgrammingGuide/types.rst:275
#: ../../source/KLProgrammingGuide/types.rst:290
#: ../../source/KLProgrammingGuide/types.rst:305
#: ../../source/KLProgrammingGuide/types.rst:320
#: ../../source/KLProgrammingGuide/types.rst:338
msgid "the old value of the integer"
msgstr "操作前の古い整数型の値"

#: ../../source/KLProgrammingGuide/types.rst:244
msgid "Atomically increments the integer"
msgstr "整数型のアトミックなインクリメント"

#: ../../source/KLProgrammingGuide/types.rst:258
msgid "Atomically subtracts a value from the integer"
msgstr "整数型からアトミックな減算"

#: ../../source/KLProgrammingGuide/types.rst:273
msgid "Atomically decrements the integer"
msgstr "整数型のアトミックなデクリメント"

#: ../../source/KLProgrammingGuide/types.rst:287
msgid "Atomically perform a bitwise or on the integer"
msgstr "整数型のアトミックなビット演算「or」"

#: ../../source/KLProgrammingGuide/types.rst:289
msgid "The value to or with the integer"
msgstr "「or」する整数型の値"

#: ../../source/KLProgrammingGuide/types.rst:302
msgid "Atomically perform a bitwise and on the integer"
msgstr "整数型のアトミックなビット演算「and」"

#: ../../source/KLProgrammingGuide/types.rst:304
msgid "The value to and with the integer"
msgstr "「and」する整数型の値"

#: ../../source/KLProgrammingGuide/types.rst:317
msgid "Atomically perform a bitwise xor on the integer"
msgstr "整数型のアトミックなビット演算「xor」"

#: ../../source/KLProgrammingGuide/types.rst:319
msgid "The value to xor with the integer"
msgstr "「xor」する整数型の値"

#: ../../source/KLProgrammingGuide/types.rst:332
msgid ""
"Atomically perform a compare-and-swap operation: if the integer's value "
"is ``oldVal``, change it to ``newVal``.  Returns ``oldVal`` if and only "
"if the value was changed."
msgstr ""
"アトミックな、compare-and-swap 操作を行います ―例えば、整数型の値 ``oldVal`` を ``newVal`` "
"に変更し、値が変更された場合のみ ``oldVal`` を返します。"

#: ../../source/KLProgrammingGuide/types.rst:336
msgid "The value to compare with the integer"
msgstr "整数型と比較する値"

#: ../../source/KLProgrammingGuide/types.rst:337
msgid "The value to set the integer to if the comparison succeeds"
msgstr "整数型の値、比較が成功した場合に設定される"

#: ../../source/KLProgrammingGuide/types.rst:350
msgid ""
"Atomically obtains the value of an integer.  The operation is \"atomic\" "
"in the sense that the value is treated as volatile."
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:353
msgid "the value of the integer"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:362
msgid "Floating-Point Types"
msgstr "浮動小数点数型（Floating-Point Types）"

#: ../../source/KLProgrammingGuide/types.rst:364
msgid ""
"The ``Float32`` and ``Float64`` types (as well as ``Scalar``, an alias "
"for ``Float32``) are collectively known as :dfn:`floating-point types` "
"and represent :abbr:`IEEE` floating-point numbers.  These types differ "
"only in their bit width, as follows:"
msgstr ""
"``Float32`` と ``Float64`` 型 ( ``Float32`` のエイリアスである ``Scalar`` も) "
"は総称して浮動小数点数型（ :dfn:`floating-point types` ）として知られ、 :abbr:`IEEE` "
"浮動小数点数を表現する。これらの型はビット幅が異なる：:"

#: ../../source/KLProgrammingGuide/types.rst:367
msgid "a 32-bit :abbr:`IEEE` floating-point number"
msgstr "32-bit :abbr:`IEEE` 浮動小数点数"

#: ../../source/KLProgrammingGuide/types.rst:370
msgid "a 64-bit :abbr:`IEEE` floating-point number"
msgstr "64-bit :abbr:`IEEE` 浮動小数点数"

#: ../../source/KLProgrammingGuide/types.rst:375
msgid "Floating-point types behave as follows:"
msgstr "浮動小数点数型の振る舞い"

#: ../../source/KLProgrammingGuide/types.rst:377
msgid ""
"Floating-point constants have the same syntax as in JavaScript and C, and"
" are of type ``Float64``.  For more details, see :ref:`floating-point-"
"constants`."
msgstr ""
"浮動小数点数の定数は JavaScript や C言語と同じ文法を持ち、 ``Float64`` 型になる。詳細は  :ref"
":`floating-point-constants` を参照。"

#: ../../source/KLProgrammingGuide/types.rst:379
msgid ""
"All of the :ref:`arithmetic <arithmetic-ops>` and :ref:`logical <logical-"
"ops>` operators are valid for floating-point values.  None of the bitwise"
" operators are valid for floating-point values."
msgstr ""
"全算術演算子（ :ref:`arithmetic <arithmetic-ops>` ）、論理演算子（ :ref:`logical "
"<logical-ops>` ）が浮動小数点数の値に対して使用できる。ビット演算子は使用不可能です。"

#: ../../source/KLProgrammingGuide/types.rst:381
msgid "The following example shows the use of floating-point types::"
msgstr "以下に浮動小数点数型の使用例を示します::"

#: ../../source/KLProgrammingGuide/types.rst:403
msgid "The ``String`` Type"
msgstr "文字列型（``String`` Type）"

#: ../../source/KLProgrammingGuide/types.rst:405
msgid ""
"The ``String`` type represents a text string, ie. a sequence of zero or "
"more characters.  A value of type ``String`` is referred to as a "
":index:`string value`."
msgstr ""
"``文字列`` 型はテキスト文字列 ―すなわちゼロ個以上の文字の連なりを表します。 ``文字列`` 型の値は :index:`string "
"value` として参照されます。"

#: ../../source/KLProgrammingGuide/types.rst:407
msgid ""
"The semantics of the ``String`` type in KL are important to understand.  "
"Strings have the following key properties:"
msgstr "``文字列`` 型のセマンティクスの理解は重要です。文字列の特徴："

#: ../../source/KLProgrammingGuide/types.rst:409
msgid "A string is a sequence of zero or more characters."
msgstr "文字列とはゼロ個以上の文字の連なり"

#: ../../source/KLProgrammingGuide/types.rst:411
msgid ""
"The length of a string is value of type ``Size``, and the maximum length "
"of a string is :math:`2^31-1`."
msgstr "文字列の長さは、 ``Size`` 型であり、最大長は :math:`2^{31}-1`"

#: ../../source/KLProgrammingGuide/types.rst:413
msgid ""
"String constants can be specified inline in KL source files using single-"
" or double-quotation marks, just as in Python and JavaScript.  For more "
"details and examples of string constants, see :ref:`string-constants`."
msgstr ""
"文字列定数はKLソースコード中にインライン指定可能です。JavaScript や Python "
"同様シングルクォーテーションもしくはダブルクォーテーションマークを使用します。文字列定数に関する詳細は :ref:`string-"
"constants` を参照してください。"

#: ../../source/KLProgrammingGuide/types.rst:415
msgid "Strings support the following operations and properties:"
msgstr "文字列は以下の操作とプロパティを持ちます。"

#: ../../source/KLProgrammingGuide/types.rst:417
#, fuzzy
msgid ""
"They have a ``.length()`` method which returns the number of characters "
"in the string"
msgstr "``.length`` プロパティをもち、文字列中の文字数を返します。"

#: ../../source/KLProgrammingGuide/types.rst:419
msgid ""
"The ``+=`` assignment operator is used to append another string to a "
"given string"
msgstr "``+=`` 代入演算子により他の文字列を所定の文字列に追記します。"

#: ../../source/KLProgrammingGuide/types.rst:421
msgid ""
"A new string can be created by concatenating two other strings using the "
"``+`` binary operation"
msgstr "``+`` 2項演算子を使用し、2つの文字列をつなぎ合わせ、新たな文字列を作成します。"

#: ../../source/KLProgrammingGuide/types.rst:423
msgid ""
"Strings can be compared using the usual ``==``, ``!=``, ``<``, ``<=``, "
"``>`` and ``>=`` logical operators.  Additionally, they support the "
":samp:`{string}.compare({otherString})` method that returns -1, 0 or 1 "
"depending on whether :samp:`{string}` is less than, equal to or greater "
"than :samp:`{otherString}`, respectively."
msgstr ""
"論理演算子 ``==``, ``!=``, ``<``, ``<=``, ``>``, ``>=`` により比較します。 さらに "
":samp:`{string}.compare({otherString})` メソッでは -1, 0, 1 いずれかを返します。それぞれ "
":samp:`{string}` が :samp:`{otherString}` より 未満、等しい、超 に応じます。"

#: ../../source/KLProgrammingGuide/types.rst:425
msgid ""
"Strings can be indexed into using the :samp:`{string}[{index}]`.  The "
"result is a string containing the single character at the given index.  "
":samp:`{index}` must be in the range :math:`[0...2^31-1]`."
msgstr ""
":samp:`{string}[{index}]` "
"を使用し、インデックスによるアクセスが可能です。与えられたインデックスに該当する1文字の文字列を結果として返します。 "
":samp:`{index}` は :math:`[0...2^{31}-1]` の範囲である必要があります。"

#: ../../source/KLProgrammingGuide/types.rst:427
msgid ""
"A 32-bit hash value for the string can be obtained with the "
":samp:`{string}.hash()` method."
msgstr ":samp:`{string}.hash()` メソッドにより、文字列の32-bit のハッシュ値を得ます。"

#: ../../source/KLProgrammingGuide/types.rst:429
msgid "Unlike C or C++, strings can contain the null character (ASCII 0)."
msgstr "C/C++言語と異なり、文字列にはヌル文字(ASCII 0)を許容します。"

#: ../../source/KLProgrammingGuide/types.rst:431
msgid ""
"Strings have no notion of encoding; they are just sequences of bytes.  "
"String encodings are determined by the application space where the "
"strings are used.  Note that everything in Fabric itself uses the UTF-8 "
"encoding, but Fabric extensions may need to convert strings into other "
"encodings."
msgstr "文字列はそれ自体にエンコーディング（符号化）の概念を持ちません。つまりただの連続したバイトにすぎません。その文字列が使用されるアプリケーション空間において、文字列エンコーディングが決定されます。Fabric自体ではUTF-8エンコーディングを使用しますが、Fabricエクステンションでは、文字列をそれぞれ別のエンコーディングに変換する必要がある場合があります。"

#: ../../source/KLProgrammingGuide/types.rst:433
msgid ""
"All other types in KL can be converted to strings through a cast; this "
"conversion simply creates a string that is a human-readable version of "
"the value.  This conversion can be overridden for custom types by writing"
" a custom :samp:`function {Type}.appendDesc(io String string)` method; "
"see :ref:`conversion-funcs`."
msgstr ""
"KLの他の全ての型は、キャストし文字列へ変換することができます。この変換によりある値を人間可読な文字列とすることができます。カスタム型においてこの変換"
" ―  :samp:`function {Type}.appendDesc(io String string)` メソッド ― "
"はオーバーライド可能です。 see :ref:`conversion-funcs` を参照してください。"

#: ../../source/KLProgrammingGuide/types.rst:435
msgid "Example use of the ``String`` type::"
msgstr "``String`` 型の使用例::"

#: ../../source/KLProgrammingGuide/types.rst:460
msgid "The ``RTVal`` Type"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:462
msgid "The :code:`RTVal` type is a type that holds a dynamically-typed valued"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:471
msgid "Derived Types"
msgstr "派生型（Derived Types）"

#: ../../source/KLProgrammingGuide/types.rst:473
msgid ""
"In addition to the base types, KL supports three classes of derived "
"types: structures, arrays and dictionaries."
msgstr "基本型に加え、KLは３つの派生型をサポートします。構造体（structures）配列（arrays）辞書（dictionaries）です。"

#: ../../source/KLProgrammingGuide/types.rst:482
msgid "Structures"
msgstr "構造体（Structures）"

#: ../../source/KLProgrammingGuide/types.rst:484
msgid ""
"A :dfn:`structure` is a collection of typed values that are placed "
"together in memory."
msgstr "構造体（ :dfn:`structure` ）ではいくつかの型の値がメモリ上に一緒に配置されます。"

#: ../../source/KLProgrammingGuide/types.rst:486
msgid ""
"Structures are usually defined outside of KL using Fabric's "
":index:`registered type system`, but they can also be declared in KL "
"source code itself using the ``struct`` keyword::"
msgstr ""
"構造体は通常、Fabric's :index:`registered type system` "
"を使いKL外に定義されますが、KLソースコード内に直接 ``struct`` キーワードを使い宣言することもできます。"

#: ../../source/KLProgrammingGuide/types.rst:494
msgid ""
"Note the use of the variable-size array as the last member; derived types"
" can nest arbitrarily."
msgstr "注意：可変長配列は一番最後のメンバとして宣言します。派生型は任意にネストすることが可能です。"

#: ../../source/KLProgrammingGuide/types.rst:496
msgid ""
"All structure declarations in KL must be in the global scope; it is not "
"possible to declare a structure within a function scope."
msgstr "全ての構造体の宣言は、グローバルスコープに置かれます。関数スコープ内での宣言は不可能です。"

#: ../../source/KLProgrammingGuide/types.rst:498
msgid "More details about structures:"
msgstr "構造体に関する詳細："

#: ../../source/KLProgrammingGuide/types.rst:500
msgid ""
"Access to structure members is through the ``.`` (dot) operator, as in "
"JavaScript."
msgstr "構造体のメンバに対するアクセスには ``.`` (ドット) 演算子をJavaScript同様、使用します。"

#: ../../source/KLProgrammingGuide/types.rst:502
msgid ""
"Currently, the structure members are using C-like alignment (see :ref"
":`structure-alignment`)."
msgstr "現状、構造体メンバは C言語ライクなアライメントを使用します。 :ref:`structure-alignment` 参照)."

#: ../../source/KLProgrammingGuide/types.rst:504
msgid ""
"It is possible to overload operators and add :dfn:`methods` to "
"structures; see :ref:`methods`."
msgstr "演算子オーバーロードが可能で、メソッド :dfn:`methods` を構造体に追加できます。 :ref:`methods` 参照"

#: ../../source/KLProgrammingGuide/types.rst:506
msgid ""
"It is possible to control access to members and methods of structures "
"using the ``public``, ``private``, ``protected`` and ``permits`` "
"keywords; see :ref:`KLPG.types.member-access`."
msgstr ""
"``public``, ``private``, ``protected``, ``permits`` "
"キーワードを使用し、構造体メンバ、メソッドに対するアクセス制御が可能です。 :ref:`KLPG.types.member-access` 参照"

#: ../../source/KLProgrammingGuide/types.rst:508
msgid "Example use of structures::"
msgstr "構造体の使用例::"

#: ../../source/KLProgrammingGuide/types.rst:534
msgid "Structure Member Alignment"
msgstr "構造体メンバのアライメント"

#: ../../source/KLProgrammingGuide/types.rst:536
msgid ""
"The alignment of members of structures is identical to that of the C "
"programming language.  Therefore, EDK code that interfaces with the "
"|FABRIC_PRODUCT_NAME| does not need to use any special alignment "
"specification to match the KL structure alignment."
msgstr ""
"構造体メンバのアライメントは、C言語でのそれと同一です。従い、 |FABRIC_PRODUCT_NAME| の EDK "
"コードとのインタフェースでは、KLでの構造体に合わせた特別なアライメントの指定は必要ありません。"

#: ../../source/KLProgrammingGuide/types.rst:541
msgid ""
"For reference, the rules of KL structure alignment (the same as the C "
"default) are:"
msgstr "参考までに、KLの構造体のアライメントに関するルール（つまりC言語のディフォルトと一緒）は："

#: ../../source/KLProgrammingGuide/types.rst:544
msgid "Every type has a size and an alignment"
msgstr "全ての型は、サイズとアライメントを持つ"

#: ../../source/KLProgrammingGuide/types.rst:546
msgid "The alignment of base types is the same as their size"
msgstr "基本型のアライメントは、その型のサイズと同一"

#: ../../source/KLProgrammingGuide/types.rst:548
msgid ""
"The alignment of structures (as a whole) is the largest alignment of any "
"of its member types"
msgstr "構造体（全体）のアライメントはその構造体のメンバの型のうち一番大きい物"

#: ../../source/KLProgrammingGuide/types.rst:551
msgid ""
"The byte position of a member within a structure is chosen by rounding up"
" the next available offset in the structure to the alignment of the "
"member type"
msgstr "メンバの構造体内でのバイト位置は、次に利用可能な構造体のオフセットからメンバの型のアライメントへ切り上げ選択されます。"

#: ../../source/KLProgrammingGuide/types.rst:561
msgid "Structure Inheritance"
msgstr "構造体の継承"

#: ../../source/KLProgrammingGuide/types.rst:565
msgid ""
"A structure can inherit (or `derive`) from a single base structure. The "
"specialized structure then inherits from all members and methods of the "
"base structure."
msgstr ""
"ある構造体は基となる一つの構造体を継承（ `inherit` もしくは `derive` "
"）できます。特殊化した構造体は、基底構造体より全てのメンバとメソッドを継承します。"

#: ../../source/KLProgrammingGuide/types.rst:567
msgid ""
"The :samp:`struct {SpecializedType} : {BaseType}` syntax is used to "
"declare the inheritance relationship. A specialized structure can be "
"`cast` to its base structure type at no cost. The :samp:`.parent` "
"accessor allows to perform that cast explicitly."
msgstr ""
":samp:`struct {SpecializedType} : {BaseType}` "
"構文を使用し継承関係の宣言をします。特殊化した構造体は基底構造体へとノーコストで `cast` が可能です。 :samp:`.parent` "
"アクセッサにより、明示的にキャストします。"

#: ../../source/KLProgrammingGuide/types.rst:591
msgid ""
"When cast to its base type, a structure looses all its specialized "
"behavior, which is different from :ref:`objects "
"<KPLG.object.inheritance>`:"
msgstr ""
"基底型へとキャストすると、その構造体は特殊化した振舞を全て失います。オブジェクト（ :ref:`objects "
"<KPLG.object.inheritance>` ）との違いです。"

#: ../../source/KLProgrammingGuide/types.rst:619
msgid "Objects"
msgstr "オブジェクト（Objects）"

#: ../../source/KLProgrammingGuide/types.rst:621
msgid "Can no longer do \"empty construction\" of variables of object type"
msgstr "オブジェクト型変数の \"empty construction\" は不可能になりました"

#: ../../source/KLProgrammingGuide/types.rst:624
msgid ""
"An :dfn:`object` is similar to a :ref:`structure <KLPG.types.structures>`"
" in that it is a collection of typed values placed together in memory, "
"except that objects are copy-by-reference rather than copy-by-value; "
"objects must be :dfn:`constructed` and are internally reference-counted."
"  Additionally, objects can support :ref:`interfaces "
"<KLPG.types.interfaces>`, which are a collection of methods that the "
"object is guaranteed to support."
msgstr ""
"オブジェクト（ :dfn:`object` ）は、メモリ内に幾つかの型の値を一緒に保持するという点において構造体（ :ref:`structure"
" <KLPG.types.structures>` ）に似ています。違いは、オブジェクトが「参照によるコピー（copy-by-reference"
"）」であるのに対し、構造体では「値によるコピー（copy-by-value）」な点です。オブジェクトは :dfn:`constructed` "
"され内部において参照カウントされます。さらにオブジェクトでは、そのオブジェクトでのサポートが保証されるメソッドの集合の "
":ref:`interfaces <KLPG.types.interfaces>` をサポートします。"

#: ../../source/KLProgrammingGuide/types.rst:626
msgid ""
"Objects are used in much the same way as structures, with the major "
"difference being that they are copy-by-reference and must be constructed."
"  KL internally keeps track of the number of references to each object "
"and when the last reference to an object is dropped the memory holding "
"the object is freed.  Objects drop their references when they go out of "
"scope, or when they have :code:`null` assigned to them."
msgstr ""
"オブジェクトは構造体とほぼ同じように使用できます。おおきな違いは、copy-by-"
"referenceな点、コンストラクトされなくてはいけない点です。KLは内部に各オブジェクトの参照番号のトラックを保持し、そのオブジェクトの最後の参照が破棄された際、オブジェクトは開放されます。スコープから外れるか、オブジェクトに"
"  :code:`null`  が割り当てられると、オブジェクトは参照を落とします。"

#: ../../source/KLProgrammingGuide/types.rst:628
msgid ""
"Objects are defined using the :code:`object` keyword in KL.  The syntax "
"is very similar to the definition of :ref:`structures "
"<KLPG.types.structures>`:"
msgstr ""
"KLコード中、 :code:`object` キーワードを使用しオブジェクトを定義します。このシンタックスは構造体とほぼ一緒です。 "
":ref:`structures <KLPG.types.structures>` 参照"

#: ../../source/KLProgrammingGuide/types.rst:638
msgid ""
"Optionally, the object can derive from one base object, and implement one"
" or more :ref:`interfaces <KLPG.types.interfaces>`.  There are indicated "
"after the name of the object:"
msgstr ""
"必要に応じ、オブジェクトはある1つの基底オブジェクトを継承し、さらに1つ以上の :ref:`interfaces "
"<KLPG.types.interfaces>` "
"を実装することができます。オブジェクトの名前の後に、継承するオブジェクト、実装するインターフェースを示します。"

#: ../../source/KLProgrammingGuide/types.rst:648
msgid ""
"Variables whose type is that of a given object are declared with the name"
" of the object."
msgstr "型にオブジェクトを与えた変数は、そのオブジェクトの名とともに宣言します。"

#: ../../source/KLProgrammingGuide/types.rst:656
msgid ""
"The value :code:`null` refers to a non-existent object.  You can report "
"an object that is :code:`null`, but trying to reference its members or "
"call methods on it will result in a runtime error."
msgstr ""
"値 :code:`null` は存在しないオブジェクトを参照します。オブジェクトが :code:`null` "
"であると、report可能ですが、実行時にそのオブジェクトのメンバを参照したり、メソッドを呼び出すと、ランタイムエラーとなります。"

#: ../../source/KLProgrammingGuide/types.rst:658
msgid ""
"Any variable of Object type can be set to :code:`null`.  Doing almost "
"anything with a :code:`null` object will result in a runtime error.  To "
"create a valid object it must be constructed.  There are two syntaxes for"
" constructing objects:"
msgstr ""
"どのオブジェクト型の変数も :code:`null` に設定可能です。 :code:`null` "
"オブジェクトに対するほとんど操作は、実行時エラーとなります。正常なオブジェクトの作成には、コンストラクトします。コンストラクトする2種類の文法："

#: ../../source/KLProgrammingGuide/types.rst:670
msgid ""
"Objects cannot be \"empty constructed\"; you must explicitly construct "
"objects or explicitly set their values to :code:`null`."
msgstr "オブジェクトは\"empty constructed\"不可能です。明示的にコンストラクトするか、明示的に :code:`null` に設定します。"

#: ../../source/KLProgrammingGuide/types.rst:672
msgid ""
":ref:`Constructors <KLPG.constructor>` and :ref:`destructors "
"<KLPG.destructor>` can be specified for objects just as they are for "
"structures:"
msgstr ""
":ref:`Constructors <KLPG.constructor>` と :ref:`destructors "
"<KLPG.destructor>` を構造体同様、オブジェクトでも指定することができます"

#: ../../source/KLProgrammingGuide/types.rst:694
msgid ""
"Constructing a specific object from another object of the same type makes"
" the new object a reference to the old object.  In this case, a new "
"object is not created; if the object is modified through one of the "
"references to it then the other see the modifications as well."
msgstr "他の同型オブジェクトから特定のオブジェクトをコンストラクトすると、新しいオブジェクトは古いオブジェクトを参照します。この場合、新しいオブジェクトは実際には作られていません。つまり参照を通し、そのうちの1つのオブジェクトに変更が加わると、もう片方のオブジェクトも同様、変更されます。"

#: ../../source/KLProgrammingGuide/types.rst:703
msgid ""
"Users cannot define a custom copy constructor for objects for this "
"reason, the copy constructor always only adds a reference to the existing"
" object. If a user wants to instantiate a new object then the ``clone()``"
" method (see :ref:`KLPG.types.objects.clone`) or a custom method should "
"be used."
msgstr ""
"ユーザ独自のコピーコンストラクタを定義することはできません。以下の理由のためです。コピーコンストラクタは既存のオブジェクトに対し、参照を常に１つ加算します。かりに新規オブジェクトをインスタンス化したいのであれば、"
" ``clone()`` メソッド（ :ref:`KLPG.types.objects.clone` 参照）か、カスタムメソッドを使用します。"

#: ../../source/KLProgrammingGuide/types.rst:742
msgid ""
"Arbitrary methods can be defined on objects just as they are on "
"structures.  These methods are then called using the same "
":samp:`{object}.{methodName}({arg},{arg},...)` syntax as for structures."
"  Calling a method on a :code:`null` object results in a runtime "
"exception."
msgstr ""
"構造体同様、オブジェクトには任意のメソッドを定義できます。これらのメソッドは "
":samp:`{object}.{methodName}({arg},{arg},...)` 構文を使用し呼び出します。 :code:`null`"
" に対するメソッドの呼び出しは実行時例外を引き起こします。"

#: ../../source/KLProgrammingGuide/types.rst:753
msgid ""
"Members of objects are accessed in the same way as members of structures "
"by using the :samp:`{object}.{memberName}` syntax.  Using the :code:`.` "
"operation on a :code:`null` object will throw a runtime exception."
msgstr ""
"構造体同様、オブジェクトのメンバへのアクセスには :samp:`{object}.{memberName}` "
"構文を使用します。:code:`null` オブジェクトに対する :code:`.` （ドット）の使用も実行時例外となります。"

#: ../../source/KLProgrammingGuide/types.rst:755
msgid "Additional properties of objects:"
msgstr "オブジェクトのさらなる特徴:"

#: ../../source/KLProgrammingGuide/types.rst:757
msgid ""
"If an value of object type is converted to a :code:`Boolean` then its "
"value is :code:`true` if and only if the object is not :code:`null`."
msgstr ""
"オブジェクト型の値が :code:`Boolean` に変換されると、そのオブジェクトが :code:`null` ではない場合 "
":code:`true` となる"

#: ../../source/KLProgrammingGuide/types.rst:759
msgid ""
"The :ref:`equality operators <equality-ops>` :samp:`{obj1} == {obj2}` and"
" :samp:`{obj1} != {obj2}` are only valid for objects when overloaded or "
"when comparing with :code:`null`.  The :ref:`identity operators "
"<identity-ops>` :samp:`{obj1} === {obj2}` and :samp:`{obj1} !== {obj2}` "
"are always valid for objects and compare based on whether the objects are"
" references to the same object (ie. if changing one will change both)."
msgstr ""
":ref:`equality operators <equality-ops>` :samp:`{obj1} == {obj2}` and "
":samp:`{obj1} != {obj2}` はオブジェクトがオーバーロドされているか、 :code:`null` "
"と比較されている場合のみ、有効です。 :ref:`identity operators <identity-ops>` :samp:`{obj1}"
" === {obj2}` and :samp:`{obj1} !== {obj2}` "
"は常に有効で、同一のオブジェクトを参照してりうかどうかに依って比較されます。 (すなわち変更が双方に影響します)"

#: ../../source/KLProgrammingGuide/types.rst:761
msgid ""
"Values of object type support the method :samp:`<objectValue>.uid()` that"
" returns a unique UInt64 that can be used to identify the object.  The "
"value is the same as it would be if `.uid()` were called on the object "
"casted to any of the interfaces the object supports."
msgstr ""
"オブジェクト型の値は、 :samp:`<objectValue>.uid()` をサポートしユニークな UInt64 "
"を返します。オブジェクトの同定に使用できます。この値は、そのオブジェクトをそれがサポートするどのようなインターフェースにキャストしたものに対し "
"`.uid()` を呼び出した結果と同一です。"

#: ../../source/KLProgrammingGuide/types.rst:763
msgid ""
"Assigning :code:`null` to an object drops the reference to whatever the "
"object was previously pointing to."
msgstr "オブジェクトに :code:`null` を代入するとそのオブジェクトが過去に示した参照全てをドロップします。"

#: ../../source/KLProgrammingGuide/types.rst:765
msgid ""
"It is possible to control access to members and methods of objects using "
"the ``public``, ``private``, ``protected`` and ``permits`` keywords; see "
":ref:`KLPG.types.member-access`."
msgstr ""
"``public``, ``private``, ``protected``, ``permits`` "
"キーワードにより、オブジェクトのメンバ、メソッドに対するアクセス制御が可能です。 :ref:`KLPG.types.member-access` "
"参照"

#: ../../source/KLProgrammingGuide/types.rst:767
msgid ""
"A variable of whose type is an object cannot point to a structure.  "
"Objects and interfaces are fundamentally different types than structures;"
" see the section :ref:`KLPG.objects-versus-structures`"
msgstr ""
"オブジェクト型の変数は、構造体を示す事はできません。オブジェクト、またインターフェイスは根本的に構造体とは異なります。 :ref:`KLPG"
".objects-versus-structures` 節参照"

#: ../../source/KLProgrammingGuide/types.rst:769
msgid "The following code provides another example of using object:"
msgstr "オブジェクトの別な使用例："

#: ../../source/KLProgrammingGuide/types.rst:802
msgid "The Object ``clone()`` Method"
msgstr "Object ``clone()`` メソッド"

#: ../../source/KLProgrammingGuide/types.rst:806
msgid ""
"As with most other types in KL object types support a method ``clone()`` "
"that does a deep copy of the object.  Every object has a default "
"``clone()`` implementation.  It is possible to change the behavior of "
"``clone()`` for an object by writing a custom method "
"``<ObjectType>.cloneMembersTo(io <ObjectType> that)``.  This method is "
"automatically called during the process of cloning the object, as shown "
"below:"
msgstr ""
"KLでの他の多くの型同様オブジェクトは、オブジェクトのディープコピーを行う ``clone()`` "
"メソッドをサポートします。全てのオブジェクトはディフォルトで ``clone()`` を実装しています。独自定義したメソッド "
"``<ObjectType>.cloneMembersTo(io <ObjectType> that)`` を記述し ``clone()`` "
"の振舞を、変更できます。このメソッドはオブジェクトの複製処理を行う際、自動的に呼びだされます。以下に示す："

#: ../../source/KLProgrammingGuide/types.rst:836
#, fuzzy
msgid "The Object ``refCount()`` Method"
msgstr "Object ``clone()`` メソッド"

#: ../../source/KLProgrammingGuide/types.rst:837
msgid ""
"You can query the number of references pointing to a certain object by "
"using the method ``refCount()``, as shown below:"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:856
msgid "Object inheritance"
msgstr "オブジェクトの継承"

#: ../../source/KLProgrammingGuide/types.rst:860
msgid ""
"Like structures, an object can inherit (or `derive`) from a single base "
"object. The specialized object then inherits from all members and methods"
" of the base object. The :samp:`struct {SpecializedType} : {BaseType}` "
"syntax is used to declare the inheritance relationship."
msgstr ""
"構造体と同じように、オブジェクトは他のベースオブジェクトを1つ継承できます。特殊化したオブジェクトは、基底オブジェクトのすべてのメンバとメソッドを引き継ぎます。"
" :samp:`struct {SpecializedType} : {BaseType}` 構文を使用し継承関係を宣言します。"

#: ../../source/KLProgrammingGuide/types.rst:862
msgid ""
"When inheriting from a base object, the :samp:`{object}.{parent}` syntax "
"allows to perform an explicit cast to that base type. This can be useful "
"for accessing members or methods that have a different definition for the"
" base and the specialized object type."
msgstr ""
":samp:`{object}.{parent}` "
"構文により、基底オブジェクトから継承している場合、明示的に基底型へとキャストを行います。特殊化したメンバやメソッドが基底オブジェクトと異なる定義を持つ場合、便利です。"

#: ../../source/KLProgrammingGuide/types.rst:890
msgid "Interfaces"
msgstr "インタフェース（Interfaces）"

#: ../../source/KLProgrammingGuide/types.rst:892
msgid "Can no longer do \"empty construction\" of variables of interface type"
msgstr "インタフェース型の変数の \"empty construction\" の使用が不可能になりました"

#: ../../source/KLProgrammingGuide/types.rst:895
msgid "Added support for ``<typeExpr>.createNew()`` method"
msgstr "``<typeExpr>.createNew()`` メソッドが追加されました"

#: ../../source/KLProgrammingGuide/types.rst:898
msgid ""
"An :dfn:`interface` is a set of methods that an object agrees to "
"implement.  Objects implement the interface by declaring the interface "
"name in the object declaration as well as implementing each of the "
"interface's methods.  The programmer can then use the interface as a "
"first-class type that refers to any type of object that implements the "
"interface."
msgstr ""
":dfn:`interface` "
"とは、あるオブジェクトが必ず実装しなければならないメソッドの一連の集合です。オブジェクトは、オブジェクトの宣言に単にインタフェースの名前を入れるだけでなくインタフェースの各メソッドを実際に実装することで、インタフェースを実装します。プログラマはどのようなオブジェクトの型であっても、インタフェースを実装するオブジェクトであれば、ファーストクラス型としてインタフェースを使用し参照することができます。"

#: ../../source/KLProgrammingGuide/types.rst:900
msgid ""
"An interface is defined using the :code:`interface` keyword.  An "
"interface definition is similar to a structure or object definition, "
"except that, instead of members, methods are specified.  For example:"
msgstr ""
":code:`interface` "
"キーワードによりインタフェースを定義します。インタフェース定義は構造体や、オブジェクト定義に似ています。メンバやメソッドは指定することを除きます。例えば："

#: ../../source/KLProgrammingGuide/types.rst:910
msgid ""
"This example defines the interface :code:`MyInt` as providing three "
"methods.  The parameter and return types all work the same as for normal "
"structure and object :ref:`methods <methods>`; however, the "
":code:`function` keyword and the typename are omitted.  Notice that the "
":code:`!` and :code:`?` modifiers for the methods also work, indicating "
"explicitly whether the methods may modify the object they are called on."
msgstr ""
"このサンプルでは、インタフェース :code:`MyInt` "
"に３つのメソッドを与え、定義します。引数パラメータと、返り値の型は、構造体やオブジェクト同様におきます（ :ref:`methods "
"<methods>` ）。ただし、 :code:`function` "
"キーワードと、型名は省きます。メソッド呼び出しによりそのオブジェクトが変更されるかどうか明示的に示す :code:`!` and "
":code:`?` は機能します。"

#: ../../source/KLProgrammingGuide/types.rst:912
msgid ""
"An interface only specifies a set of methods that objects implementing "
"the interface must support.  In order to use interfaces, you must define "
"objects that support them:"
msgstr "インタフェースには、それを実装するオブジェクトがサポートしなければならない一連のメソッド「のみ」を指定します。インタフェースを使用するには、そのインタフェースをサポートしたオブジェクトを定義する必要があります。"

#: ../../source/KLProgrammingGuide/types.rst:934
msgid ""
"Notice that, in order to implement the interface, we both list the "
"interface after the object type name and the provide implementations for "
"each of the methods."
msgstr "インタフェースの実装には、オブジェクト型名直後にインタフェースを、そして各メソッドの実装の一覧を列記します。"

#: ../../source/KLProgrammingGuide/types.rst:938
msgid ""
"It is a compile-time error to fail to provide a definition for one or "
"more of the methods required by the interfaces an object implements!"
msgstr "オブジェクトの実装に、インタフェースに必要なメソッド定義が一つでも欠けていると、コンパイル時エラーとなります。"

#: ../../source/KLProgrammingGuide/types.rst:940
msgid "It is possible for an object to implement multiple interfaces:"
msgstr "オブジェクトには複数のインタフェースを実装できます。"

#: ../../source/KLProgrammingGuide/types.rst:970
msgid ""
"Notice that it's possible for an object to support multiple interfaces "
"that share methods.  In this case you only need to implement the method "
"once and that implementation will be shared by all interfaces that "
"include this method."
msgstr "メソッドを共有するような複数のインタフェースを、オブジェクトがサポートすることは可能です。それにはメソッドを1度だけ実装します。実装したメソッドは全てのインタフェースから共有されます。"

#: ../../source/KLProgrammingGuide/types.rst:972
msgid ""
"Once an interface has been defined, you can declare a variable that "
"points to an object that implements the interface and call its methods "
"using the :samp:`{int}.{methodName}({arg}, {arg}, ...)` syntax:"
msgstr ""
"インタフェースを定義すると、あるインタフェースを実装したオブジェクトを参照する変数を宣言できます。 "
":samp:`{int}.{methodName}({arg}, {arg}, ...)` 構文により、そのオブジェクトのメソッドを呼び出します。"

#: ../../source/KLProgrammingGuide/types.rst:986
msgid ""
"Using the :samp:`{interface}.type()` method you can determine the type of"
" the object in interface refers to, and through an assignment or a cast "
"you can obtain a specific object.  This allows for a simple form of weak "
"(or runtime) typing in KL:"
msgstr ""
":samp:`{interface}.type()` "
"メソッドのより、インタフェースから参照しているオブジェクトの型を確認します。割当もしくはキャストにより、特定のオブジェクトを得ます。これにより、KLでの単純な「弱い（もしくは実行時）型付け」の形式（simple"
" form of weak(or runtime) typing）を可能にします。"

#: ../../source/KLProgrammingGuide/types.rst:997
msgid ""
"In the case that an expression is of type :code:`Type` then calling the "
"``<typeExpr>.createNew()`` method will create a new instance of the "
"object the interface is an instance of using its empty constructor.  The "
"result is of the :ref:`Object interface <KLPG.interfaces.object>` type:"
msgstr ""
"このケースでは、この式の型は :code:`Type` 型です。したがって、 ``<typeExpr>.createNew()`` "
"メソッドを呼ぶと、新しいオブジェクトインスタンスを作成します。インタフェースは空コンストラクタを使用しインスタンスになります。結果として、  "
":ref:`Object interface <KLPG.interfaces.object>`  型になります。"

#: ../../source/KLProgrammingGuide/types.rst:1018
msgid ""
"Assigning or casting an interface to the wrong object will result in a "
"runtime exception.  You can also assign a value whose types is one "
"interface to a variable whose type is another interface; if the "
"underlying object supports the second interface, you will get a "
"non-:code:`null` reference to the second interface on the object, "
"otherwise a runtime exception will occur."
msgstr ""
"インタフェースを、間違ったオブジェクトへ割当もしくはキャストすると、実行時例外となります。「型がインタフェースな値」を、「型が他のインタフェースである変数」へと割り当てる事もできます。つまり、基礎となるオブジェクトが、第2のインタフェースをサポートする場合、そのオブジェクトの第2のインタフェースへの"
" :code:`null` ではない参照を得ることができます。第2のインタフェースをサポートしていなければ、実行時例外が発生します。"

#: ../../source/KLProgrammingGuide/types.rst:1020
msgid "Additional properties of interfaces:"
msgstr "インタフェースのさらなる特徴"

#: ../../source/KLProgrammingGuide/types.rst:1022
msgid ""
"The cast-to-:code:`Boolean` works exactly as for objects: it checks if "
"the interface referred to is :code:`null`."
msgstr ":code:`Boolean` へのキャストがオブジェクト同様正常に可能です。 :code:`null` を参照しているかどうかをチェックします"

#: ../../source/KLProgrammingGuide/types.rst:1024
msgid ""
"The comparison operators :samp:`{int1} == {int2}` and :samp:`{int1} != "
"{int2}`, as well as the identity operators :samp:`{int1} === {int2}` and "
":samp:`{int1} !== {int2}`, test whether two interfaces refer to the same "
"(or different) objects. to whatever object it previously referred to."
msgstr ""
"比較演算子 :samp:`{int1} == {int2}`, :samp:`{int1} != {int2}`,そして同一比較演算子 "
":samp:`{int1} === {int2}`, :samp:`{int1} !== {int2}`, "
"では2つのインタフェース同士が、同一（あるは別）のオブジェクトを参照するかどうかを判断します。（以前に参照されていたオブジェクトならなんでも）"

#: ../../source/KLProgrammingGuide/types.rst:1026
msgid ""
"Values of interface type support the method "
":samp:`<interfaceValue>.uid()` that returns a unique UInt64 that can be "
"used to identify the object the interface refers to.  The value is the "
"same as it would be if `.uid()` were called on the object the interface "
"refers to."
msgstr ""
"インタフェース型の値は :samp:`<interfaceValue>.uid()` "
"メソッドをサポートし、インタフェースの参照するオブジェクトの同一性に依存した、ユニークな UInt64 "
"を返します。この値はそのインタフェースの参照するオブジェクトで  `.uid()` を呼んだ時の値と同じになります。"

#: ../../source/KLProgrammingGuide/types.rst:1028
msgid ""
"It is possible to control access to methods of interfaces using the "
"``public``, ``private``, ``protected`` and ``permits`` keywords; see "
":ref:`KLPG.types.member-access`."
msgstr ""
"``public``, ``private``, ``protected``, ``permits`` "
"キーワードによりインタフェースのメソッドに対するアクセス制御が可能です。 :ref:`KLPG.types.member-access` 参照"

#: ../../source/KLProgrammingGuide/types.rst:1030
msgid ""
"A variable of whose type is an interface cannot point to a structure.  "
"Objects and interfaces are fundamentally different types than structures;"
" see the section :ref:`KLPG.objects-versus-structures`"
msgstr ""
"インタフェース型の変数では構造体を示すことはできません。オブジェクトとインタフェースは根本的に構造体とは異なります。  :ref:`KLPG"
".objects-versus-structures` 節参照"

#: ../../source/KLProgrammingGuide/types.rst:1035
msgid "The :code:`Object` Interface"
msgstr ":code:`Object` インタフェース"

#: ../../source/KLProgrammingGuide/types.rst:1037
msgid ""
"There is a special, predefined interface called :code:`Object` that every"
" object in KL always supports.  This both provides backwards "
"compatibility with older versions of the KL language as well as providing"
" a simple way of passing a reference to an arbitrary object (much like a "
"\"void pointer\" in C).  The :code:`Object` interface does not provide "
"any methods."
msgstr ""
"事前に定義された :code:`Object` "
"と呼ばれる特別なインタフェースが存在します。全てのKLでのオブジェクトで常にサポートします。このインタフェースにより、KL言語の過去のバージョンとの後方互換性と、さらに任意のオブジェクトへの参照を渡すシンプルな方法（C言語での"
" \"void pointer\"のようなもの）を提供します。この :code:`Object` インタフェースではメソッドを提供しません。"

#: ../../source/KLProgrammingGuide/types.rst:1052
msgid "Structure, Object and Interface Access Contols"
msgstr "構造体、オブジェクト、インタフェースでのアクセス制御"

#: ../../source/KLProgrammingGuide/types.rst:1056
msgid ""
"Access to members and methods of structures, objects and interfaces can "
"be controlled through the use of the ``public``, ``private`` and "
"``protected`` keywords.  These keywords behave in a similar way to C++:"
msgstr ""
"構造体、オブジェクト、インタフェースのメンバやメソッドへのアクセスは、 ``public``, ``private`` and "
"``protected`` キーワードにより制御されます。これらのキーワードは C++と同じように動作します。"

#: ../../source/KLProgrammingGuide/types.rst:1058
msgid ""
"A member or method marked as ``public`` can be accessed by any part of "
"the source code.  This is the behavior when no access is specified."
msgstr ""
"``public`` "
"が付けられたメンバやメソッドは、ソースコードどこからでもアクセス可能です。アクセス修飾子がつけられない場合のディフォルトの動作でもあります。"

#: ../../source/KLProgrammingGuide/types.rst:1060
msgid ""
"A member or method marked as ``private`` can be only be accessed by "
"methods of the structure or object.  Trying to access the member "
"elsewhere will result in an error when the source code is compiled."
msgstr ""
"``private`` "
"と付けられたメンバやメソッドは、構造体もしくはオブジェクトないのメソッドからのみアクセス可能です。他の場からのアクセスは、コンパイル時エラーとなります。"

#: ../../source/KLProgrammingGuide/types.rst:1062
msgid ""
"A member or method marked as ``protected`` can be only be accessed by "
"methods of the structure or object as well as structures or objects that "
"inherit from it.  Trying to access the member elsewhere will result in an"
" error when the source code is compiled."
msgstr ""
"``protected`` "
"と付けられたメンバやメソッドは、その構造体もしくはオブジェクトおよび、それらを継承した構造体もしくはオブジェクトからのみアクセス可能です。それ以外の場からのアクセスはコンパイル時エラーとなります。"

#: ../../source/KLProgrammingGuide/types.rst:1096
msgid ""
"It is possible to allow a structure or object to bypass this mechanism "
"from within its methods by using the ``permits`` keyword.  If a structure"
" or object is listed in the ``permits`` section of another structure or "
"object, it can access its private and protected members and methods:"
msgstr ""
"``permits`` "
"キーワードの使用により、構造体もしくはオブジェクトがこのメカニズムを迂回させることができます。構造体やオブジェクトが、他の構造体もしくはオブジェクトの"
" ``permits`` セクションにリストされていれば、private や protected メンバもしくはメソッドにアクセス可能です。"

#: ../../source/KLProgrammingGuide/types.rst:1141
msgid "Interfaces and inheritance"
msgstr "インタフェースと継承"

#: ../../source/KLProgrammingGuide/types.rst:1145
msgid ""
"In addition to inherit from a :ref:`base object type "
"<KPLG.object.inheritance>`, specialized objects can implement additional "
"interfaces."
msgstr ""
":ref:`base object type <KPLG.object.inheritance>` "
"を継承し特殊化したオブジェクトでも追加のインタフェースを実装できます。"

#: ../../source/KLProgrammingGuide/types.rst:1154
msgid ""
"If a base object implements an interface, the specialized object can "
"provide its own implementation of the interface methods, which will "
"`override` base type's implementation. In this situation, special syntax "
"is required to call base class's implementation of the same interface "
"method: see :ref:`KLPG.method.interface-inheritance`."
msgstr ""
"基底オブジェクトがインタフェースを実装していると、そのオブジェクトを継承し特殊化したオブジェクトからも、基底オブジェクトでそのインタフェースを実装したメソッドをさらに、"
" `override` "
"した実装が使用可能です。このような場面では、特別なシンタックスが必要となります。同一のインタフェースを実装した基底クラスのメソッドを呼ぶには "
":ref:`KLPG.method.interface-inheritance` 参照してください。"

#: ../../source/KLProgrammingGuide/types.rst:1159
msgid "Forward Declaration of Objects and Interfaces"
msgstr "オブジェクト、インタフェースの前方宣言"

#: ../../source/KLProgrammingGuide/types.rst:1161
msgid "Forward declaration of objects and interfaces"
msgstr "オブジェクト、インタフェースの前方宣言"

#: ../../source/KLProgrammingGuide/types.rst:1164
msgid ""
"It is possible to declare the existence of an object or interface without"
" actually defining its members; this is useful when you have a set of co-"
"dependent objects or interfaces.  To forward-declare an object or "
"interface, simply omit the members, methods and/or implemented "
"interfaces."
msgstr "オブジェクトやインタフェースの存在を、実際のメンバの定義抜きに宣言できます。オブジェクトやインタフェースが相互依存するような場合便利です。オブジェクトやインタフェースの前方定義するには、単にメンバやメソッドそしてインタフェースの実装を省略します。"

#: ../../source/KLProgrammingGuide/types.rst:1217
msgid "Unowned Object and Interface References"
msgstr "未所有オブジェクト、インタフェースへの参照"

#: ../../source/KLProgrammingGuide/types.rst:1219
msgid ""
"The runtime cost of tracking all of the references to objects and "
"interfaces can be high.  In certain situations it is desireable to avoid "
"this reference tracking for performance reasons when it is known that "
"there will always be at least one reference to the object in question.  "
"Kl provides the ability to do this using the :samp:`Ref<{ObjectType}>` "
"and :samp:`Ref<{InterfaceType}>` syntax.  This also provides the ability "
"to create object and interface reference loops that do not leak memory."
msgstr ""
"オブジェクト、インタフェースへの参照全てを追跡するランタイムコストはとても高価となりえます。特定の状況、例えばオブジェクトへの参照が常に1つ以上あることが事前に判明している時などは、パフォーマンス上の理由からこの追跡を避けるのが望ましいです。KLでは"
" :samp:`Ref<{ObjectType}>`, :samp:`Ref<{InterfaceType}>` "
"構文を使いこの状況を避けることができます。これにより、メモリリークを発生させず、オブジェクトやインタフェースの参照を繰り返し作成する機能を提供します。"

#: ../../source/KLProgrammingGuide/types.rst:1221
msgid ""
"Unowned references behave exactly the same as regular object and "
"interface references; the only difference is that they don't track "
"references."
msgstr ""
"未所有参照（Unowned "
"reference）は通常のオブジェクトやインタフェースの参照と全く同様に動作します。ただひとつの違いは、参照を追跡しないことです。"

#: ../../source/KLProgrammingGuide/types.rst:1223
msgid ""
"It is very easy to create subtle bugs and crashes when using unowned "
"references.  Use them at your own risk!  It is your responsibility to "
"ensure that unowned references refer to objects that are owned by "
"something else.  You can leave an unowned reference refering to an object"
" that has been destroyed but if you try to do anything with it your "
"program will probably crash!"
msgstr "未所有参照の使用すると、細かいバグにより、クラッシュを非常に簡単に引き起こしてしまいます。使用はあなたの責任です。未所有参照が、他の何かが所有するオブジェクトを正しく確実に参照するようにしましょう。つまり、既に破棄されたオブジェクトを参照する未所有参照をそのまま放置することができてしまい、プログラム中からその参照を使用し何かさせようとするとクラッシュしてしまうのです。"

#: ../../source/KLProgrammingGuide/types.rst:1225
msgid "Example use of unowned references:"
msgstr "未所有参照の使用例："

#: ../../source/KLProgrammingGuide/types.rst:1245
msgid "The :code:`Type` Type"
msgstr ":code:`Type` 型"

#: ../../source/KLProgrammingGuide/types.rst:1247
msgid ""
"There is a special type in KL called :code:`Type`.  It represents the "
"type of a value in KL.  Every value in KL supports a method "
":code:`{value}.type()` that can be used to obtain the type of the object,"
" which is a value of type :code:`Type`."
msgstr ""
"KLには :code:`Type` 型と呼ばれる特別な型があります。KLでのある値の型を表します。KLでの全ての値は "
":code:`{value}.type()` メソッドをサポートします。これによりそのオブジェクトの型、 "
":code:`Type`　型の値を得ます。"

#: ../../source/KLProgrammingGuide/types.rst:1251
msgid ""
"The default value of a variable of type :code:`Type` is the special value"
" :code:`None`.  This is also sometimes the return value of some methods "
"described below.  :code:`None` is not equal to :code:`{value}.type()` for"
" any :code:`{value}`."
msgstr ""
"変数の :code:`Type` のディフォルト値は、特別な値 :code:`None` "
"です。これはいかに説明する幾つかのメソッドの返り値でもあります。 :code:`None` はどの :code:`{value}` に対する "
":code:`{value}.type()` とも等しくありません。"

#: ../../source/KLProgrammingGuide/types.rst:1253
msgid ""
"You can only do a few things with values of type :code:`Type`; they are "
"primarily used for runtime type inference with interfaces and objects."
msgstr ":code:`Type` 型の値をつかい、いくつかできることがあります。おもに、インタフェースとオブジェクトの実行時型推論に用います。"

#: ../../source/KLProgrammingGuide/types.rst:1255
msgid ""
"You refer to a value of type :code:`Type` just by refering to the value "
"of the type; you can then use this for comparisons:"
msgstr "まず値の型を参照し :code:`Type` 型の値を参照し、そして比較に使用することができます："

#: ../../source/KLProgrammingGuide/types.rst:1269
msgid ""
"For :ref:`interfaces <KLPG.types.interfaces>` the :code:`{value}.type()` "
"method returns the type of the specific object that the generic object "
"refers to; this is how you do runtime type inference on objects.  See "
":ref:`KLPG.types.interfaces` for more information."
msgstr ""
":ref:`interfaces <KLPG.types.interfaces>` では :code:`{value}.type()` "
"メソッドで、生成されたオブジェクトが参照する特定オブジェクトの型を返します。これによりオブジェクトの型推論を行います。 "
":ref:`KLPG.types.interfaces` 節に詳細があります。"

#: ../../source/KLProgrammingGuide/types.rst:1271
msgid ""
"Values of type :code:`Type` support the method "
":code:`{value}.parentType()`.  In the case that the type of "
":code:`{value}` is a structure or object type with an inherited parent, "
":code:`parentType()` returns the type of the parent; otherwise, "
":code:`parentType()` returns :code:`None`."
msgstr ""
":code:`Type` 型の値は :code:`{value}.parentType()` メソッドをサポートします。この場合 "
":code:`{value}` は親を継承したオブジェクトもしくは構造体です。 :code:`parentType()` "
"は親の型を返します。未継承であれば :code:`parentType()` :code:`None` を返します。"

#: ../../source/KLProgrammingGuide/types.rst:1290
msgid ""
"Values of type :code:`Type` support the method "
":code:`{value}.isA({interfaceType})`, which returns :code:`true` if and "
"only if :code:`{value}` supports the interface :code:`{interfaceType}`."
msgstr ""
":code:`Type` 型の値は :code:`{value}.isA({interfaceType})` メソッドをサポートします。 "
":code:`{value}` がインタフェース :code:`{interfaceType}` をサポートしている場合のみ "
":code:`true` を返します。"

#: ../../source/KLProgrammingGuide/types.rst:1324
msgid ""
"You can obtain a description of the type by calling the method "
":code:`{typeValue}.jsonDesc()`.  You can use this to find out things like"
" the members of structures at runtime:"
msgstr ""
":code:`{typeValue}.jsonDesc()` "
"メソッドにより、型の説明を取得できます。実行時に構造体のメンバのようなものを探しだすことができます。"

#: ../../source/KLProgrammingGuide/types.rst:1344
msgid "The :code:`RTVal` Type"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:1346
msgid ""
"The :code:`RTVal` type is once which contains a dynamically-typed value."
"  A value of type :code:`RTVal` can be created from a value of any other "
"type in KL, except :code:`RTVal` itself."
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:1348
msgid ""
"Using the :code:`RTVal` type allows you to work with values whose types "
"are only known at runtime.  In order to determine the type of the value "
"inside of an :code:`RTVal` value, use its :code:`.type()` method as shown"
" below:"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:1371
msgid ""
"Notice above that, unlike most conversions, conversions to and from the "
":code:`RTVal` type must be explicit; this is because it's too easy for "
"bugs to slip by if the conversions are done for you automatically."
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:1376
msgid "The :code:`DFGBinding` Type"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:1378
msgid ""
"The :code:`DFGBinding` type represents a Canvas (historically called "
"\"the DFG\") binding."
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:1380
msgid ""
"Currently, the only supported use of the :code:`DFGBinding` type is as "
"follows:"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:1382
msgid ""
"A value of type :code:`DFGBinding` can be constructed from a JSON-"
"formatted binding description (ie. :code:`.canvas` file)"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:1384
msgid ""
"The methods :code:`.getArgValue({index})` and :code:`setArgValue({index},"
" {rtVal})` are supported"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:1386
msgid "The method :code:`.execute()` is supported."
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:1388
msgid ""
"This allows you to load and execute a Canvas graph entirely from KL.  "
"There is also a CAPI entry point for converting DFGBindings to and from "
"RTVals, which will allow you to pass them in from client applications."
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:1390
msgid ""
"This documentation will be expanded in the future to cover complex use "
"cases."
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:1399
msgid "Objects Versus Structures"
msgstr "オブジェクト vs 構造体"

#: ../../source/KLProgrammingGuide/types.rst:1401
msgid ""
"The decision to use a structure versus an object for a composite type is "
"an important design decision that affects program design as well as "
"runtime behavior and performance."
msgstr "型の合成に、構造体をつかうかオブジェクトを使うかの決定は、実行時の動作や性能に対してだけではなく、プログラムの設計にも影響する極めて重要な選択です。"

#: ../../source/KLProgrammingGuide/types.rst:1403
msgid ""
"Structures are usually the best choice for small types that are "
"performance-critical.  If you have complex expressions that will create a"
" lot of temporary values of the given type, you probably want to be using"
" a structure and not an object.  One critical performance aspect is that "
"variables whose types are structures are allocated on the program stack; "
"this means that there is virtually no overhead to allocating and freeing "
"the memory associated with the structure.  Examples of types that should "
"usually be structures are mathematical types such as vectors and "
"transforms."
msgstr "構造体は、通常、パフォーマンスクリティカルな小さな型に対して最善な選択です。与えられた型の値を一時的に大量に作成する、複雑な式の場合、オブジェクトではなく、構造体を使いましょう。1点致命的なパフォーマンスの観点は、構造体の型をもった変数は、プログラム「スタック」に確保されるということです。つまり、構造体ではメモリ確保、開放のオーバーヘッドが事実上存在しないことを意味します。例えば、ベクタやトランスフォーム型などの数学的な型は、通常構造体です。"

#: ../../source/KLProgrammingGuide/types.rst:1405
msgid ""
"Objects are usually the best choice for large types that are created and "
"destroyed less significantly less often than they are used.  Objects are "
"allocated on the heap, which is significantly slower than stack "
"allocation.  Additionally, since you can have many different variables "
"point to the same object, objects are a good choice when you want lots of"
" references to the same data.  Hierarchies of data are usually "
"represented with objects."
msgstr "オブジェクトは、通常、使用回数が作成／破棄よりも著しく多いような、大規模な型に対して最善の選択です。オブジェクトは、スタックよりも顕著に遅い「ヒープ」に確保されます。さらに、異なる沢山の変数が同じオブジェクトを指すことができ、オブジェクトは同じデータに対し沢山参照する場合、とても良い選択です。データ階層などは通常オブジェクトで表現します。"

#: ../../source/KLProgrammingGuide/types.rst:1414
msgid "Arrays"
msgstr "配列"

#: ../../source/KLProgrammingGuide/types.rst:1416
msgid ""
"An :dfn:`array` is a sequence of values of the same type (referred to as "
"the array's :dfn:`element type`) that are indexed by integers and placed "
"sequentially in memory.  KL supports three types of arrays: variable-size"
" arrays, fixed-length arrays, and external arrays.  The details of each "
"array type are discussed below."
msgstr ""
":dfn:`array` とは同型（配列の :dfn:`element type` "
"呼ばれる)の値を集めた一連のシーケンスです。整数によって索引付け（インデックス）され、メモリ上に連続配置されます。KLでは３種類の配列をサポートします:"
" 可変長配列（variable-size arrays）, 固定長配列（fixed-length arrays）,外部配列（external "
"arrays）です。各配列の詳細については後述します。"

#: ../../source/KLProgrammingGuide/types.rst:1420
msgid "Regardless of specific type, arrays in KL have several common behaviors:"
msgstr "３つのうちいずれであっても、KLにおける配列は幾つかの共通の振舞をもちます。"

#: ../../source/KLProgrammingGuide/types.rst:1422
msgid ""
"Arrays are indexed using the ``[..]`` operator, exactly as in JavaScript "
"and C.  The indexing of arrays is 0-based, again just as in JavaScript "
"and C::"
msgstr ""
"配列は ``[..]`` 演算子をつかい索引付されます。JavaScriptやC言語と同一です。配列の索引は 0 "
"基点です。これもJavaScriptやC言語と一緒です::"

#: ../../source/KLProgrammingGuide/types.rst:1430
msgid ""
"The size of an array is of type ``Size`` and the indexing operator takes "
"an index of type ``Index`` (which is an alias for ``Size``)."
msgstr "配列のサイズの型は ``Size`` 型です。インデクシング演算子は、 ``Index`` 型（ ``Size`` へのエイリアス）を取ります。"

#: ../../source/KLProgrammingGuide/types.rst:1432
msgid ""
"Array declarations can be nested, and can be co-nested with other array "
"types::"
msgstr "配列の宣言はネスト（入れ子）可能です、さらに他の配列の型ともネストできます。"

#: ../../source/KLProgrammingGuide/types.rst:1438
msgid ""
"Arrays are :dfn:`passed by reference` into functions and operators, ie. "
"they are not copied.  This means that it takes just a long to pass an "
"array with one million elements to a function as it does to pass an array"
" with one element."
msgstr ""
"配列は参照渡し（ :dfn:`passed by reference` "
"）により関数やオペレータに渡ります。すなわち、コピーされません。このことは、100万要素を持つ１つの配列を関数に渡すのも、1つの要素の1つの配列を渡すのも、かかる時間は同じです。"

#: ../../source/KLProgrammingGuide/types.rst:1440
msgid ""
"If running a Fabric client with bounds-checking enabled, indexing into "
"arrays using the indexing operator is bounds-checked; if the index runs "
"off the end of the array an exception is thrown."
msgstr ""
"Fabricクライアントを境界チェック（bounds-"
"checks)を有効にし実行した場合、インデクシング演算子を使った配列へのインデクシングは、境界チェックされます。インデックスが配列の終端に達し、超えると、例外が投げられます。"

#: ../../source/KLProgrammingGuide/types.rst:1449
msgid "Variable-Size Arrays"
msgstr "可変長配列（Variable-Size Arrays）"

#: ../../source/KLProgrammingGuide/types.rst:1451
msgid ""
"A :dfn:`variable-size array` is an array whose size can be changed at "
"runtime.  Variable-size arrays are declared by appending ``[]`` to the "
"name of the variable, parameter or structure member where they are "
"declared, eg. ``String strings[]``."
msgstr ""
":dfn:`variable-size array` "
"とは、実行時に長さを帰ることのできる配列です。可変長配列の宣言は変数（パラメータもしくは構造体メンバが宣言された）の名前の直後 ``[]`` "
"を付与します。例： ``String strings[]``"

#: ../../source/KLProgrammingGuide/types.rst:1453
msgid ""
"Variable-size arrays have all the :ref:`properties of arrays <array-"
"properties>` as well as the following additional properties:"
msgstr ""
"可変長配列は :ref:`properties of arrays <array-properties>` "
"を全て持ち、さらに以下の追加の特徴があります："

#: ../../source/KLProgrammingGuide/types.rst:1455
msgid "The maximum size of a variable-size array is :math:`2^31-1`."
msgstr "可変長配列の最大サイズは :math:`2^{31}-1`"

#: ../../source/KLProgrammingGuide/types.rst:1457
msgid ""
"Variable-size arrays are :dfn:`share-on-assign`, meaning that when you "
"assign one variable-size array to another it does not copy the elements "
"but rather copies a reference to the elements; any changes to one of the "
"arrays changes the other as well.  This is sometimes referred to as a "
"shallow copy (as opposed to a deep copy).  In order to obtain a deep copy"
" of an array, use the ``clone()`` method, described below."
msgstr ""
"可変長配列は、割り当て共有（ :dfn:`share-on-assign` "
"）です。つまりある可変長配列を他の配列へ割り当てると、要素はコピーされるのでは「なく」、要素への「参照をコピー」します。片方の配列へのどのような変更も、もう片方の配列に影響します。これはシャローコピー（対義語はディープコピー）と呼ばれます。配列のディープコピーを行うには、後述する"
" ``clone()``  メソッドを使用します。"

#: ../../source/KLProgrammingGuide/types.rst:1459
msgid "Variable-size arrays support the following methods and functions:"
msgstr "可変長配列は、以下のメソッド、関数をサポートします。"

#: ../../source/KLProgrammingGuide/types.rst:1461
msgid ""
"By default, a variable array is empty.  If you specify an integer value "
"when it is constructed, the variable array will initially have that many "
"elements."
msgstr "ディフォルトで可変長配列は空です。コンストラクト時に整数を与えた場合、その配列初期化時初めからは要素を複数持つことになります。"

#: ../../source/KLProgrammingGuide/types.rst:1463
msgid ""
"The ``push(element)`` method appends an element to the end of the "
"variable-size array.  The size of the array is increased by one."
msgstr "``push(element)`` メソッドにより、末端に要素を追加します。結果配列サイズは１繰り上がります。"

#: ../../source/KLProgrammingGuide/types.rst:1465
msgid ""
"The ``pop()`` method removes the last element from the end of the array, "
"and returns that element.  The size of the array is reduced by one.  "
"Calling ``pop()`` on an empty array results in an error."
msgstr ""
"``pop()`` メソッドにより、末端要素を取り除き、その要素を返します。結果配列サイズは１小さくなります。空の配列に対し ``pop()`` "
"を呼ぶとエラーが返ります。"

#: ../../source/KLProgrammingGuide/types.rst:1467
msgid ""
"The ``size()`` method returns the number of elements in the variable-size"
" array"
msgstr "``size()`` メソッドによりその可変長配列の要素数を返します。"

#: ../../source/KLProgrammingGuide/types.rst:1469
msgid ""
"The ``resize(newSize)`` method resizes the array.  Any new elements at "
"the end are initialized with the default value for the underlying type."
msgstr "``resize(newSize)`` メソッドにより配列のサイズを変更します。末端新規要素を、その要素の型のディフォルト値で初期化します。"

#: ../../source/KLProgrammingGuide/types.rst:1471
msgid ""
"The ``reserve(count)`` method ensures that space is allocated for at "
"least ``count`` elements.  If you know the final number of elements in "
"advance, it is much faster to call ``reserve(...)`` before calling "
"``push(...)`` many times."
msgstr ""
"``reserve(count)`` メソッドでは少なくとも ``count`` "
"分の要素の場が確保されていることを保証します。事前に要素の最終的な数がわかっているのであれば、``push(...)`` を何度も呼ぶ前に "
"``reserve(...)`` すると速度面で優位になります。"

#: ../../source/KLProgrammingGuide/types.rst:1473
msgid ""
"The ``clone()`` method makes a deep copy of the variable-size array.  The"
" resulting copy is initially not shared with any other variable-size "
"array."
msgstr "``clone()`` メソッドによりその可変長配列のディープコピーを作成します。結果のコピー物は初期状態で他の可変長配列から共有されていません。"

#: ../../source/KLProgrammingGuide/types.rst:1475
msgid ""
"The ``swap(Size lhsIndex, Size rhsIndex)`` method swaps the values of the"
" array at the two given indices."
msgstr ""
"``swap(Size lhsIndex, Size rhsIndex)`` "
"メソッドにより、２つのインデクスにより指定された配列の値を入れ替えます。"

#: ../../source/KLProgrammingGuide/types.rst:1477
msgid ""
"The :samp:`swap({Type} lhs[], {Type} rhs[])` function swaps the contents "
"of the two variable-size arrays.  This swap is performed in constant time"
" and does not copy any data."
msgstr ""
":samp:`swap({Type} lhs[], {Type} rhs[])` "
"関数により、２つの可変長配列の内容を入れ替えます。この操作はデータのコピーを伴わず、一定時間で完了します。"

#: ../../source/KLProgrammingGuide/types.rst:1500
msgid "Fixed-Size Arrays"
msgstr "固定長配列（Fixed-Size Arrays）"

#: ../../source/KLProgrammingGuide/types.rst:1502
msgid ""
"A :dfn:`fixed-size array` is an array whose size is fixed at runtime.  "
"Fixed-size arrays have much faster performance characteristics than "
"variable-size arrays, therefore should be used in place of variable-sized"
" arrays when the size of an array is known at compile time.  Fixed-size "
"arrays are declared by appending :samp:`[{size}]` to the name of the "
"variable, parameter or structure member where they are declared, eg. "
"``String strings[4]``."
msgstr ""
"固定長配列（ :dfn:`fixed-size array` "
"）とは、実行時サイズが固定されている配列です。固定長配列は可変長配列よりもパフォーマンス特性に優れ、コンパイル時に配列のサイズが判明している場合、可変長配列のかわりに使用します。固定長配列を宣言するには、変数、パラメータ、構造体メンバ名の後に"
" :samp:`[{size}]` を付け足します。例： ``String strings[4]``"

#: ../../source/KLProgrammingGuide/types.rst:1504
msgid ""
"Fixed-size arrays have all the :ref:`properties of arrays <array-"
"properties>` as well as the following additional properties:"
msgstr ""
"固定長配列は :ref:`properties of arrays <array-properties>` "
"をすべて持ち、さらに追加の特徴があります："

#: ../../source/KLProgrammingGuide/types.rst:1506
msgid "The maximum size of a fixed-size array is :math:`2^31-1`."
msgstr "配列の最大サイズは :math:`2^31-1`."

#: ../../source/KLProgrammingGuide/types.rst:1510
msgid ""
"Since fixed-size arrays are allocated on the stack (instead of the heap),"
" using very large fixed-size arrays may result in a stack overflow.  It "
"is recommended that fixed-size arrays only be used for arrays that are "
"reasonably small."
msgstr "固定長配列はスタック上に確保される（ヒープではありません）ため、巨大な固定長配列を使用するとスタックオーバーフローを引き起こします。固定長配列を使用する際は、適正な大きさである場合に限りましょう。"

#: ../../source/KLProgrammingGuide/types.rst:1512
msgid ""
"Fixed-size arrays are copied when they are assigned, ie. they are :dfn"
":`copy-by-value`."
msgstr "固定長配列は、割当時にコピーされます。つまり :dfn:`copy-by-value` です。"

#: ../../source/KLProgrammingGuide/types.rst:1536
msgid "External Arrays"
msgstr "外部配列（External Arrays）"

#: ../../source/KLProgrammingGuide/types.rst:1538
msgid ""
"An :dfn:`external array` is an array whose size is fixed when it is "
"created and does not own the data is operates on.  External arrays are "
"primarily used for operator parameters bound to sliced data inside a "
"|FABRIC_PRODUCT_NAME| dependency graph as well as arrays bound to "
"external data within |FABRIC_PRODUCT_NAME| extensions, but they can also "
"be used on their own within KL.  External arrays are declared by "
"appending ``<>`` to the name of the variable, parameter or structure "
"member where they are declared, eg. ``String strings<>``."
msgstr ""
":dfn:`external array` "
"とは作成時にサイズが固定され、データ操作時にはそのデータを所有しません。外部配列はおもに、オペレータのパラメータ ― "
"|FABRIC_PRODUCT_NAME| dependency graph 内でのスライスデータと結合（bind）されたパラメータだけでなく、 "
"|FABRIC_PRODUCT_NAME| "
"エクステンション内の外部のデータと結合されたパラメータにも使います。また、KL内で使用することも可能です。外部配列の宣言には、変数、パラメータ、構造体メンバの名前の後ろに、"
" ``<>`` を食わ会えます。例： ``String strings<>``"

#: ../../source/KLProgrammingGuide/types.rst:1540
msgid ""
"External arrays have all the :ref:`properties of arrays <array-"
"properties>` as well as the following additional properties:"
msgstr "外部配列は、 :ref:`properties of arrays <array-properties>` をすべて持ちさらに追加の特徴を持ちます："

#: ../../source/KLProgrammingGuide/types.rst:1542
msgid ""
"An external array can be constructed from an existing variable array.  "
"This simply points the external array to the data within the variable "
"array at the time the variable array is constructed.  Note however that "
"there are lots of ways that this usage can break, such as through "
"resizing the variable array.  This usage is primarily meant for testing::"
msgstr "外部配列は、既存の可変長配列からコンストラクト可能です。これは単に、その可変長配列がコンストラクトされた時点の可変長配列に含まれるデータを指します。ただし、この使用方法にはたくさんの穴があります。たとえば可変長配列をリサイズした場合などです。これは主にテストのため使用してください。"

#: ../../source/KLProgrammingGuide/types.rst:1549
msgid ""
"External arrays support an empty constructor (which constructs an empty "
"external array)::"
msgstr "外部配列は空コンストラクタ（empty constructor）をサポートします。（空の外部配列がコンストラクトされます）"

#: ../../source/KLProgrammingGuide/types.rst:1554
msgid ""
"External arrays support a copy constructor and an assignment operator, "
"both of which simply make one external array refer to the same data as "
"the other::"
msgstr "外部配列は、コピーコンストラクタ、代入演算子両方サポートし、他方の配列と同じデータを参照する外部配列を作成します。"

#: ../../source/KLProgrammingGuide/types.rst:1565
msgid ""
"External arrays support a ``size()`` method that returns the number of "
"elements in the external array."
msgstr "外部配列は、 ``size()`` メソッドをサポートし、外部配列の要素数を返します。"

#: ../../source/KLProgrammingGuide/types.rst:1567
msgid ""
"External arrays can be initialized given a ``data`` pointer as well as a "
"``size``. This allows you to map arbitrary memory as an array. This is "
"very useful especially when passing data from C++ into KL and back out. "
"You can also use this constructor to reinterpret any memory as an array::"
msgstr ""
"外部配列は、 ``data`` ポインタだけでなく ``size`` "
"を指定し初期化できます。これにより任意のメモリを配列として割り当てできます。とくにC++からKLへと（もしくはその逆）データを渡す際に便利です。このコンストラクタを使い、どんなメモリも配列として再解釈することができます::"

#: ../../source/KLProgrammingGuide/types.rst:1576
msgid ""
"As opposed to variable arrays, External arrays are not ref counted "
"objects. This makes them cheaper to pass around, but can't be used to "
"manage the lifetime of memory. (See next point)"
msgstr "可変長配列とは逆に、外部配列は参照カウントされないオブジェクトです。つまり受け渡し低価でありますが、メモリのライフタイムを管理することはできなくなります。（次項参照）"

#: ../../source/KLProgrammingGuide/types.rst:1578
msgid ""
"External arrays do not manage the lifetime of the data they operate on. A"
" variable array will free its memory when it is destroyed, but an "
"external array is simply a mapping to memory owned by something else. An "
"external array should never out-live the owner of the data, else it will "
"map to garbage data::"
msgstr "外部配列は、それが操作されるデータの生存期間を管理できません。可変長配列は破棄時にメモリが開放されますが、外部配列は単に他のオブジェクトが所持するメモリをマップしたものに過ぎません。外部配列は真のデータ所持者より長生きしてはいけません、さもなくば不要なゴミデータにマップされてしまいます。"

#: ../../source/KLProgrammingGuide/types.rst:1594
msgid "The following is an example of using external arrays:"
msgstr "外部配列の使用例:"

#: ../../source/KLProgrammingGuide/types.rst:1617
msgid "Dictionaries"
msgstr "辞書（Dictionaries）"

#: ../../source/KLProgrammingGuide/types.rst:1619
msgid ""
"KL supports key-value pair :dfn:`dictionaries`.  The type of the key of a"
" dictionary can be any of the KL base types (e.g. :code:`Boolean`, "
"``String``, or any integer or floating-point type) as well as custom "
"types for which a special :samp:`.hash` method has been defined (see "
":ref:`KLPG.dictionaries.custom-key-types`) and the type of the value can "
"be any type.  Dictionaries are declared by appending :samp:`[{KeyType}]` "
"to the variable, parameter or member name.  For example:"
msgstr ""
"KLは、キーと値のペア、辞書（ :dfn:`dictionaries` ）をサポートします。辞書のキーにはKL基本型（ "
":code:`Boolean`, ``String``, 整数型、浮動小数点型）だけでなく、 :samp:`.hash` "
"メソッドが定義された独自定義した型 (see :ref:`KLPG.dictionaries.custom-key-"
"types`)を、そして辞書の値にはどのような型も取れます。辞書の宣言には、変数（パラメータ、メンバ名）に :samp:`[{KeyType}]`"
" を付けます。例:"

#: ../../source/KLProgrammingGuide/types.rst:1627
msgid "Dictionaries in KL have the following properties:"
msgstr "KL での辞書には以下の特徴があります:"

#: ../../source/KLProgrammingGuide/types.rst:1629
msgid ""
"Dictionaries are :dfn:`share-on-assign`, meaning that when you assign one"
" dictionary to another it does not copy the contents but rather copies a "
"reference to the contents; any changes to one of the dictionaries changes"
" the other as well.  This is sometimes referred to as a shallow copy (as "
"opposed to a deep copy).  In order to obtain a deep copy of a dictionary,"
" use the ``clone()`` method, described below."
msgstr ""
":dfn:`share-on-assign` "
"です。他の辞書に割当てる際、内容そのものをコピーするのではなく内容への参照をコピーします。つまり、一方の辞書への変更が、他方にも作用します。これはシャローコピーと呼ばれます。（対義語はディープコピー）辞書のディープコピーを得るには、"
" ``clone()`` メソッドを用います。以下に説明します。"

#: ../../source/KLProgrammingGuide/types.rst:1631
msgid ""
"Dictionaries can be nested, and can be co-nested with array types.  For "
"example:"
msgstr "ネスト可能です。配列型をネストさせることができます。例:"

#: ../../source/KLProgrammingGuide/types.rst:1639
msgid "Dictionaries can contain at most :math:`2^32-1` key-value pairs."
msgstr "最大要素数は  :math:`2^{32}-1` "

#: ../../source/KLProgrammingGuide/types.rst:1641
msgid ""
"Dictionaries support the :samp:`has({key})` method that returns a "
":code:`Boolean` value indicating whether there is a value in the "
"dictionary for the given key."
msgstr ":samp:`has({key})` メソッドにより、与えられた key 要素が存在するかどうかを :code:`Boolean` の値で返します。"

#: ../../source/KLProgrammingGuide/types.rst:1643
msgid ""
"Dictionaries support the :samp:`get({key})` method that returns the value"
" associated with the given key.  If there is no value for the given key, "
"an exception is thrown."
msgstr ":samp:`get({key})` メソッドにより、与えられた key に対応する値を返します。対応する値が存在しない場合例外を投げます。"

#: ../../source/KLProgrammingGuide/types.rst:1645
msgid ""
"Dictionaries support the :samp:`set({key}, {value})` method that sets the"
" value for the key, replacing the existing value if there is already a "
"value for the key."
msgstr ""
":samp:`set({key}, {value})` メソッドにより、 key に対応した 値 "
"を設定します。キーに対応する値が既に存在する場合、値を上書きします。"

#: ../../source/KLProgrammingGuide/types.rst:1647
msgid ""
"Dictionaries support indexing using the :samp:`[{key}]` indexing "
"operator.  When used as the target of an assignment or as an io parameter"
" to a function (eg. :samp:`{dict}[{key}] = {value}`), it is equivalent to"
" using the :samp:`set({key}, {value})` method.  When used as a read-only "
"expression (eg. :samp:`{value} = {dict}[{key}]`), it is equivalent to "
"using the :samp:`get({key})` method."
msgstr ""
":samp:`[{key}]` インデクサ演算子によるインデクシングに対応しています。代入ターゲットとしての使用、あるいは関数の "
"ioパラメータとしての使用は（例： :samp:`{dict}[{key}] = {value}` ）、 :samp:`set({key}, "
"{value})` メソッドと同等です。read-onlyな式としての使用は、（例： :samp:`{value} = "
"{dict}[{key}]`)は、 :samp:`get({key})` と同等です。"

#: ../../source/KLProgrammingGuide/types.rst:1649
msgid ""
"Dictionaries support the :samp:`get({key}, {defaultValue})` method that "
"returns the value associated with the given key, if it exists, or "
":samp:`{defaultValue}`` if there is no value for the given key."
msgstr ""
":samp:`get({key}, {defaultValue})` メソッドにより、key に対応する値が存在すればその値を、そうでなければ  "
":samp:`{defaultValue}`` を返します。"

#: ../../source/KLProgrammingGuide/types.rst:1651
msgid ""
"Dictionaries support the :samp:`delete({key})` method that deletes the "
"value for the given key.  If there is no value for the given key, nothing"
" happens."
msgstr ""
":samp:`delete({key})` メソッドにより、与えられた key "
"に対する値を削除します。与えられたkeyが存在しない場合は、なにも置きません。"

#: ../../source/KLProgrammingGuide/types.rst:1653
msgid ""
"Dictionaries support the ``clone()`` method which makes a deep copy of "
"the dictionary.  The resulting copy is initially not shared with any "
"other dictionaries."
msgstr "``clone()`` メソッドにより、辞書のディープコピーを作成します。作成されたコピーは初期状態で他の何物の辞書からも共有されません。"

#: ../../source/KLProgrammingGuide/types.rst:1655
msgid ""
"Dictionaries support the ``clear()`` method which removes all keys and "
"values."
msgstr "``clear()`` メソッドにより、全てのキーと値を取り除きます。"

#: ../../source/KLProgrammingGuide/types.rst:1657
msgid "Dictionaries can be iterated over using JavaScript-like ``in`` iteration:"
msgstr "JavaScriptのように ``in`` により、繰り返しが可能です。"

#: ../../source/KLProgrammingGuide/types.rst:1666
msgid ""
"For improved performance, both the key and value can be made available "
"through ``in`` iteration:"
msgstr "パフォーマンス向上のため、キーと値の両方を ``in`` の反復中利用可能とななります。"

#: ../../source/KLProgrammingGuide/types.rst:1675
msgid ""
"In a dictionary iteration, the value can be assigned to if and only if "
"the dictionary can be assigned to.  The key, on the other hand, cannot be"
" assigned to."
msgstr "辞書の反復処理中、値はその辞書自体が割り当て済であれば、代入可能です。一方キーは反復処理中での代入は不可能です。"

#: ../../source/KLProgrammingGuide/types.rst:1677
msgid ""
"Insertion order (not sort order!) is the iteration order for "
"dictionaries, just as for JavaScript objects:"
msgstr "挿入順（ソート順ではなく）が、反復処理の順序となります。JavaScriptのオブジェクトと同じです。"

#: ../../source/KLProgrammingGuide/types.rst:1690
msgid "The following is an example use of dictionaries:"
msgstr "辞書の利用例："

#: ../../source/KLProgrammingGuide/types.rst:1715
msgid "Dictionaries Using Custom Key Types"
msgstr "キーにカスタム型を使用した辞書"

#: ../../source/KLProgrammingGuide/types.rst:1717
msgid ""
"You can use a custom :samp:`struct` as a key type for a dictionary by "
"implementing a :samp:`.hash` method for the type as well as a :samp:`==` "
"operator:"
msgstr ""
"独自定義した構造体 :samp:`struct` を辞書のキーの型として使用できます。型に :samp:`.hash` メソッド、 "
":samp:`==` 演算子 を実装します。"

#: ../../source/KLProgrammingGuide/types.rst:1751
msgid "Map-Reduce Types"
msgstr "Map-Reduce 型"

#: ../../source/KLProgrammingGuide/types.rst:1753
msgid ""
"There are two additional derived types used exclusively for work within "
"Fabric's map-reduce framework, namely:"
msgstr "Fabric の map-reduce フレームワークには、排他的に使用可能な２つの派生型があります:"

#: ../../source/KLProgrammingGuide/types.rst:1755
msgid ":samp:`ValueProducer<{Type}>`"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:1756
msgid ":samp:`ArrayProducer<{Type}>`"
msgstr ""

#: ../../source/KLProgrammingGuide/types.rst:1758
msgid "For more information, see :ref:`map-reduce`."
msgstr ":ref:`map-reduce` の詳細を参照してください。"

#: ../../source/KLProgrammingGuide/types.rst:1765
msgid "Implicit Type Casting Rules in KL"
msgstr "KL での型の暗黙的キャスト"

#: ../../source/KLProgrammingGuide/types.rst:1767
msgid ""
"When a function or method is called in KL, but the types of the arguments"
" do not exactly match the types of the parameters for any polymorphic "
"version of the function or method, KL will attempt to find the best match"
" using implicit casts.  The best match is chosen as follows:"
msgstr "KLにおいて、引数の型がその関数（もしくはメソッド）のどの多態なパラメータとも一致させずに、関数やメソッドを呼んぶと、KLは、最善の型を探すため暗黙のキャストを行います。以下に従い最善なものが選択されます:"

#: ../../source/KLProgrammingGuide/types.rst:1769
msgid ""
"The number of arguments must exactly match the number of parameters.  "
"Therefore, if there is a mismatch, the polymorphic version is not "
"considered.  For example, if the function call :code:`foo(14, 23)` is "
"made and there is a function :code:`foo(Integer)` available, it will not "
"be considered because it only takes one parameter but two arguments have "
"been given."
msgstr ""
"引数の数は、パラメータの数と完全に一致させます。仮にミスマッチがあると、多態バージョンは無視されます。例を挙げると、関数呼び出し "
":code:`foo(14, 23)` がなされ、対して :code:`foo(Integer)` "
"が利用可能な場合、関数で処理可能なパラメータは１つなのに、与えられた引数が２つなため適切に処理されません。"

#: ../../source/KLProgrammingGuide/types.rst:1771
msgid ""
"If the number of parameters matches the number of arguments, the \"cost\""
" of the call is computed as the maximum \"cost\" for each argument.  The "
"cost for each argument is computed as follows:"
msgstr "引数（複数）の数と、パラメータの数が合っている場合、呼び出し『コスト』はそれぞれの引数の最大のコストと等しくなります。それぞれの引数のコストは以下:"

#: ../../source/KLProgrammingGuide/types.rst:1773
msgid "The cost is zero if there is an exact type match"
msgstr "型が一致していればコストは 0"

#: ../../source/KLProgrammingGuide/types.rst:1774
msgid ""
"The cost is very low for inheritance, ie. if the parameter type is "
":code:`A`, the argument type is :code:`B`, and :code:`B` inherits from "
":code:`A`"
msgstr ""
"継承関係であればコストは 極小 （例：受付パラメータの型が :code:`A`, 呼び出し引数の型が :code:`B`, :code:`B` が"
" :code:`A` を引き継ぎ）"

#: ../../source/KLProgrammingGuide/types.rst:1775
msgid ""
"Otherwise, the cost is computed on a per-type basis, and are what would "
"generally be expected.  For instance, casts from smaller integer values "
"to larger ones (eg. :code:`UInt16` to :code:`UInt32`) are very low cost, "
"whereas expensive operations (conversions to strings, numerical "
"conversions that might lose precision) have a high cost."
msgstr ""
"以上に当てはまらない場合、コストは型のよりけりです。一般的に期待される通りではあります。例えば、小さい整数型からより大きい整数型（ "
":code:`UInt16` to :code:`UInt32` など)はとても低コストです。一方高価な操作（文字列への変換, "
"精度を失うような数値変換)は高コストになります。"

#: ../../source/KLProgrammingGuide/types.rst:1778
msgid "Type Aliases"
msgstr "型の別名(Type Aliases)"

#: ../../source/KLProgrammingGuide/types.rst:1780
msgid ""
"The ``alias`` statement can be used to alias a type to make code more "
"readable.  Its syntax is the same as a variable declaration::"
msgstr "エイリアス（ ``alias`` ）文により、ある型に別名を振りコードの可読性を向上させます。変数宣言の文法と同一の文法です::"

#: ../../source/KLProgrammingGuide/types.rst:1786
msgid "``alias`` statements must appear within the global scope of a KL program."
msgstr "``alias`` 文はKLプログラム中、グローバルスコープに置きます。"

#: ../../source/KLProgrammingGuide/types.rst:1803
msgid "The ``Data`` Type and the ``data`` and ``dataSize`` Methods"
msgstr "``Data`` 型 ``data``, ``dataSize`` メソッド"

#: ../../source/KLProgrammingGuide/types.rst:1805
msgid ""
"When interfacing with external libraries such as OpenGL, it is sometimes "
"necessary to get direct access to the data underlying a value.  An "
"example is a library call that takes a pointer to data.  KL itself has no"
" notion of pointers; instead, KL has the concept of the ``Data`` type "
"whose value is a pointer to data which can be passed to an external "
"library call."
msgstr ""
"OpenGLなどの外部ライブラリとの接続を行う際、値の基礎となるデータへ直接のアクセスを必要とすることがあります。例えば、データへのポインタを受け付けるライブラリです。KL自体にはポインタの概念がありません。ですが、KLには"
" ``Data`` 型 ―この型の値は外部ライブラリ呼び出しの際に渡されるデータへのポインタを示す― のコンセプトがあります。"

#: ../../source/KLProgrammingGuide/types.rst:1807
msgid ""
"Most values in KL have a built-in method called ``data`` that returns a "
"value of type ``Data``, and a built-in method called ``dataSize`` that "
"returns a value of type ``Size``.  The value returned by the ``data`` "
"method is a pointer to the data underlying the value, and the value "
"returned by the ``dataSize`` method is the number of bytes the value "
"occupies in memory.  The only values which do not support the ``data`` "
"and ``dataSize`` methods are dictionaries as well as other derived types "
"that do not lay out their elements or members contiguously in memory:"
msgstr ""
"KLでの多くの値は、組み込みメソッド ``data`` を持ち、 ``Data`` 型の値を返します。さらに組み込みメソッド  "
"``dataSize`` を持ち、 ``Size`` 型の値を返します。 ``data`` メソッドは値の基であるデータへのポインタを返し、  "
"``dataSize`` はメモリに占める値のバイト数を返します。ただひとつ、辞書（およびその派生型）はこの  ``data`` and "
"``dataSize`` メソッドを持ちません。なぜなならこの型の値の要素（もしくはメンバ）は、メモリ上に連続して配置されるわけではないからです。"

#: ../../source/KLProgrammingGuide/types.rst:1817
msgid ""
"Unlike pointers in C and C++, the values returned by ``data`` methods "
"cannot be inspected or used in any expressions; the only thing which can "
"be done is a cast to :code:`Boolean`, which will be :code:`true` if and "
"only if the ``Data`` value points to a value whose size is greater than "
"zero.  However, these ``Data`` values can be passed directly to external "
"library functions provided by Fabric itself or Fabric extensions, where "
"they are used as pointers to data in memory."
msgstr ""
"CやC++言語のポインターと異なり、 ``data`` メソッドの返す値はインスペクト不可、いかなる式での使用も不可です。この値は、 "
":code:`Boolean` へのキャストだけが行えます。 ``Data`` の値が 0以上の値を示していれば :code:`true` "
"になります。しかし ``Data`` の値はそのまま直接外部ライブラリの関数 "
"―Fabric自身もしくはFabricエクステンションでも、メモリ上のデータへのポインタを使用する箇所でこへでも与えることができます。"

#: ../../source/KLProgrammingGuide/types.rst:1819
#, fuzzy
msgid ""
"For values of type ``String``, the value returned by ``dataSize`` "
"includes a null terminator that is automatically appended to the string "
"by Fabric; this is so that the string data can be directly used in C "
"library calls as a regular C string.  If you want to pass the number of "
"characters in the string, pass ``string.length()`` instead."
msgstr ""
"``String`` 型の値については、 ``dataSize`` "
"の返す値は、ヌル終端文字を含みます。これはFabricにより文字列へと自動的に付与されます。これにより、文字列のデータを直接 C言語ライブラリで "
"C言語の通常の文字列であるかのように使用できます。文字列中の文字数を受け渡したい場合は、 ``string.length`` を渡します。"

#: ../../source/KLProgrammingGuide/types.rst:1821
msgid "Example of ``Data`` values and the ``data`` and ``dataSize`` methods:"
msgstr "``Data`` の値 ``data``, ``dataSize`` メソッドの使用例:"

