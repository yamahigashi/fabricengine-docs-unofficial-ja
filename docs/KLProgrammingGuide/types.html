<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>KLの型システム &#8212; Fabric Engine 2.4.0 Unofficial Documentation (ja)</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.4.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="関数と他のグローバルな宣言" href="globals.html" />
    <link rel="prev" title="KLの文法" href="syntax.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="globals.html" title="関数と他のグローバルな宣言"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="syntax.html" title="KLの文法"
             accesskey="P">前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Fabric Engine 2.4.0 Unofficial Documentation (ja)</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">KL プログラミングガイド</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-kl-type-system">
<span id="klpg-types"></span><h1>KLの型システム<a class="headerlink" href="#the-kl-type-system" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>多くの言語と異なり、KLは動的な型システム ―Fabricの環境から引き継ぐ を持ちます。複合型の登録は、動的言語（例えば JavaScriptや Python）で実行されているFabric環境を通じ行われます。これらの型は自動的にその実行環境においてKLプログラムから利用可能となります。ただし、このことは言語のセマンティクス（プログラム意味論）に影響をあたえるものではありません。つまりKLの型システムは依然として、純粋に、その言語自体の観点から説明できます。</p>
<p>多くの他のプログラミング言語同様にKLには、他の型へと継承できる定められた数の基本型だけでなく、異なる種の派生型の数々もサポートします。</p>
<div class="section" id="base-types">
<span id="index-0"></span><h2>基本型（Base Types）<a class="headerlink" href="#base-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>KLでの基本型は以下：</p>
<dl class="docutils">
<dt><code class="code docutils literal"><span class="pre">Boolean</span></code></dt>
<dd><code class="code docutils literal"><span class="pre">true</span></code> もしくは <code class="code docutils literal"><span class="pre">false</span></code> のいずれかをとる</dd>
<dt><code class="docutils literal"><span class="pre">UInt8</span></code></dt>
<dd>8-bit 符号なし整数（unsigned integer）</dd>
<dt><code class="docutils literal"><span class="pre">Byte</span></code></dt>
<dd><code class="docutils literal"><span class="pre">UInt8</span></code> のエイリアス（別名）</dd>
<dt><code class="docutils literal"><span class="pre">SInt8</span></code></dt>
<dd>8-bit 符号つき整数（signed integer）</dd>
<dt><code class="docutils literal"><span class="pre">UInt16</span></code></dt>
<dd>16-bit 符号なし整数</dd>
<dt><code class="docutils literal"><span class="pre">SInt16</span></code></dt>
<dd>16-bit 符号つき整数</dd>
<dt><code class="docutils literal"><span class="pre">UInt32</span></code></dt>
<dd>32-bit 符号なし整数</dd>
<dt><code class="docutils literal"><span class="pre">Count</span></code></dt>
<dd><code class="docutils literal"><span class="pre">UInt32</span></code> へのエイリアス。基数を表すために使用される。</dd>
<dt><code class="docutils literal"><span class="pre">Index</span></code></dt>
<dd><code class="docutils literal"><span class="pre">UInt32</span></code> へのエイリアス。序数を表すために使用される。</dd>
<dt><code class="docutils literal"><span class="pre">Size</span></code></dt>
<dd><code class="docutils literal"><span class="pre">UInt32</span></code> へのエイリアス</dd>
<dt><code class="docutils literal"><span class="pre">SInt32</span></code></dt>
<dd>32-bit 符号つき整数</dd>
<dt><code class="docutils literal"><span class="pre">Integer</span></code></dt>
<dd><code class="docutils literal"><span class="pre">SInt32</span></code> へのエイリアス</dd>
<dt><code class="docutils literal"><span class="pre">UInt64</span></code></dt>
<dd>64-bit 符号なし整数</dd>
<dt><code class="docutils literal"><span class="pre">DataSize</span></code></dt>
<dd><code class="docutils literal"><span class="pre">UInt64</span></code> へのエイリアス。メモリブロックのサイズを表すために使用される</dd>
<dt><code class="docutils literal"><span class="pre">SInt64</span></code></dt>
<dd>64-bit 符号つき整数</dd>
<dt><code class="docutils literal"><span class="pre">Float32</span></code></dt>
<dd>32-bit IEEE浮動小数点数</dd>
<dt><code class="docutils literal"><span class="pre">Scalar</span></code></dt>
<dd><code class="docutils literal"><span class="pre">Float32</span></code> へのエイリアス</dd>
<dt><code class="docutils literal"><span class="pre">Float64</span></code></dt>
<dd>64-bit IEEE浮動小数点数</dd>
<dt><code class="docutils literal"><span class="pre">String</span></code></dt>
<dd>ゼロ個以上の文字の連なり</dd>
</dl>
<div class="section" id="the-boolean-type">
<span id="index-1"></span><h3>論理型（ <code class="code docutils literal"><span class="pre">Boolean</span></code> Type）<a class="headerlink" href="#the-boolean-type" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="code docutils literal"><span class="pre">Boolean</span></code> 型の式の値は、論理真もしくは論理偽です。以下の特徴を持ちます：</p>
<ul class="simple">
<li>定数 <code class="code docutils literal"><span class="pre">true</span></code> 及び <code class="code docutils literal"><span class="pre">false</span></code> はそれぞれ論理値である真、偽の <code class="code docutils literal"><span class="pre">Boolean</span></code> です。</li>
<li>他の型から Boolean 型へのキャスト：<ul>
<li>全整数型（例えば <code class="docutils literal"><span class="pre">UInt32</span></code>, <code class="docutils literal"><span class="pre">Byte</span></code>)は値が 0 ではない時のみ true となります。</li>
<li>全浮動小数点数型（すなわち <code class="docutils literal"><span class="pre">Float32</span></code> and <code class="docutils literal"><span class="pre">Float64</span></code>）は値が  <code class="docutils literal"><span class="pre">0.0</span></code> もしくは <code class="docutils literal"><span class="pre">-0.0</span></code> と等しくない場合にのみ true となります。</li>
<li><code class="docutils literal"><span class="pre">String</span></code> の値はその長さが 0以上 の場合のみ true となります。</li>
<li>配列と辞書型はカラでない場合のみ true となります。</li>
<li>構造体はそのままでは  <code class="code docutils literal"><span class="pre">Boolean</span></code> 型へキャストできません。キャスト可能にするには引数パラメータにキャストを行いたい構造体をとる <code class="code docutils literal"><span class="pre">Boolean</span></code> コンストラクタを実装します。 <a class="reference internal" href="globals.html#klpg-constructor"><span class="std std-ref">コンストラクタ</span></a> を参照してください。</li>
</ul>
</li>
<li>演算子<ul>
<li>算術演算子 (2項演算子 <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">%</span></code> だけでなく 単独の <code class="docutils literal"><span class="pre">-</span></code> and <code class="docutils literal"><span class="pre">+</span></code>) はいずれも <code class="code docutils literal"><span class="pre">Boolean</span></code> の値には無効です。</li>
<li><code class="code docutils literal"><span class="pre">Boolean</span></code> の値には比較演算子 <code class="docutils literal"><span class="pre">==</span></code> と <code class="docutils literal"><span class="pre">!=</span></code> のみ有効です。</li>
<li>全2項論理演算子(<code class="docutils literal"><span class="pre">|</span></code>, <code class="docutils literal"><span class="pre">&amp;amp;</span></code>, <code class="docutils literal"><span class="pre">^</span></code> and <code class="docutils literal"><span class="pre">~</span></code>) は <code class="code docutils literal"><span class="pre">Boolean</span></code> 値で有効です。値を単一のビットであるかのように扱います。</li>
</ul>
</li>
</ul>
<p>以下に <code class="code docutils literal"><span class="pre">Boolean</span></code> 型の使用例を示します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">operator</span> <span class="n">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Boolean</span> <span class="n">a</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="n">report</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="n">Boolean</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">false</span><span class="p">;</span>
  <span class="n">report</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="n">report</span><span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>出力:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">true</span>
<span class="n">false</span>
<span class="n">true</span>
</pre></div>
</div>
</div>
<div class="section" id="integer-types">
<span id="index-2"></span><h3>整数型（Integer Types）<a class="headerlink" href="#integer-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">UInt8</span></code>, <code class="docutils literal"><span class="pre">SInt8</span></code>, <code class="docutils literal"><span class="pre">UInt16</span></code>, <code class="docutils literal"><span class="pre">SInt16</span></code>, <code class="docutils literal"><span class="pre">UInt32</span></code>, <code class="docutils literal"><span class="pre">SInt32</span></code>, <code class="docutils literal"><span class="pre">UInt64</span></code>, <code class="docutils literal"><span class="pre">SInt64</span></code> 型、そしてエイリアス (<code class="docutils literal"><span class="pre">Byte</span></code>, <code class="docutils literal"><span class="pre">Integer</span></code>, <code class="docutils literal"><span class="pre">Size</span></code>, <code class="docutils literal"><span class="pre">Count</span></code>, <code class="docutils literal"><span class="pre">Index</span></code>, <code class="docutils literal"><span class="pre">DataSize</span></code>), は総称して <span class="target" id="index-28"></span>integer types として知られ、全ての整数を表現します。</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">UInt8</span></code></dt>
<dd>8-bit 符号なし整数（unsigned integer）</dd>
<dt><code class="docutils literal"><span class="pre">Byte</span></code></dt>
<dd><code class="docutils literal"><span class="pre">UInt8</span></code> のエイリアス（別名）</dd>
<dt><code class="docutils literal"><span class="pre">SInt8</span></code></dt>
<dd>8-bit 符号つき整数（signed integer）</dd>
<dt><code class="docutils literal"><span class="pre">UInt16</span></code></dt>
<dd>16-bit 符号なし整数</dd>
<dt><code class="docutils literal"><span class="pre">SInt16</span></code></dt>
<dd>16-bit 符号つき整数</dd>
<dt><code class="docutils literal"><span class="pre">UInt32</span></code></dt>
<dd>32-bit 符号なし整数</dd>
<dt><code class="docutils literal"><span class="pre">SInt32</span></code></dt>
<dd>32-bit 符号つき整数</dd>
<dt><code class="docutils literal"><span class="pre">Integer</span></code></dt>
<dd><code class="docutils literal"><span class="pre">SInt32</span></code> へのエイリアス</dd>
<dt><code class="docutils literal"><span class="pre">UInt64</span></code></dt>
<dd>64-bit 符号なし整数</dd>
<dt><code class="docutils literal"><span class="pre">SInt64</span></code></dt>
<dd>64-bit 符号つき整数</dd>
<dt><code class="docutils literal"><span class="pre">Count</span></code></dt>
<dd><code class="docutils literal"><span class="pre">UInt32</span></code> へのエイリアス。通常 <code class="docutils literal"><span class="pre">Size</span></code> は配列中の要素の数量の数え上げにしようされる。</dd>
<dt><code class="docutils literal"><span class="pre">Index</span></code></dt>
<dd><code class="docutils literal"><span class="pre">UInt32</span></code> へのエイリアス。通常  <code class="docutils literal"><span class="pre">Index</span></code> は配列のインデックスに使用される。</dd>
<dt><code class="docutils literal"><span class="pre">DataSize</span></code></dt>
<dd><code class="docutils literal"><span class="pre">UInt64</span></code> へのエイリアス。メモリブロックのサイズを表すために使用され、 <code class="docutils literal"><span class="pre">dataSize</span></code> メッソドの返り値の型として使用される。</dd>
<dt><code class="docutils literal"><span class="pre">Size</span></code></dt>
<dd><code class="docutils literal"><span class="pre">UInt32</span></code> へのエイリアス。</dd>
</dl>
<p>整数型の振る舞い：</p>
<ul class="simple">
<li>全 <a class="reference internal" href="ops-exprs.html#arithmetic-ops"><span class="std std-ref">arithmetic</span></a>, <a class="reference internal" href="ops-exprs.html#logical-ops"><span class="std std-ref">logical</span></a>, <a class="reference internal" href="ops-exprs.html#bitwise-ops"><span class="std std-ref">bitwise</span></a> 演算子は整数型に対し期待通り動作します。</li>
<li>整数型の定数は <code class="docutils literal"><span class="pre">s32</span></code> が <code class="docutils literal"><span class="pre">SInt32</span></code>, <code class="docutils literal"><span class="pre">u64</span></code> が <code class="docutils literal"><span class="pre">UInt64</span></code>, などのように接尾語をともない型付けされます。接尾語を付さない場合、 <code class="docutils literal"><span class="pre">SInt32</span></code> となります。参照 <a class="reference internal" href="syntax.html#integer-constants"><span class="std std-ref">整数定数</span></a>.</li>
</ul>
<p>整数型の使用例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">operator</span> <span class="n">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Byte</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
  <span class="n">report</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="n">Size</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">45</span> <span class="o">*</span> <span class="n">Size</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">32</span><span class="p">;</span>
  <span class="n">report</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="n">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">75</span> <span class="o">*</span> <span class="n">Integer</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">18</span><span class="p">;</span>
  <span class="n">report</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>出力:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mi">64</span>
<span class="mi">2912</span>
<span class="o">-</span><span class="mi">218382</span>
</pre></div>
</div>
<div class="section" id="integer-atomic-methods">
<span id="index-4"></span><h4>整数型のアトミックメソッド<a class="headerlink" href="#integer-atomic-methods" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>整数型は組み込み <a class="reference internal" href="globals.html#methods"><span class="std std-ref">メソッド</span></a> を持ちます。整数型の値に対しアトミックな操作（不可分操作、atomic operation）をおこないます。アトミックな操作は、ロックフリーなアルゴリズムで実装されています。アトミックな操作については <a class="reference external" href="http://en.wikipedia.org/wiki/Linearizability">http://en.wikipedia.org/wiki/Linearizability</a> を参照してください。</p>
<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicAdd!(UInt8 val)</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicAdd!(SInt8 val)</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicAdd!(UInt16 val)</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicAdd!(SInt16 val)</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicAdd!(UInt32 val)</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicAdd!(SInt32 val)</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicAdd!(UInt64 val)</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicAdd!(SInt64 val)</code></dt>
<dd><p>整数型の値にアトミックな加算</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first simple">
<li><strong>val</strong> &#8211; 加算する値</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">操作前の古い整数型の値</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicInc!()</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicInc!()</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicInc!()</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicInc!()</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicInc!()</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicInc!()</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicInc!()</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicInc!()</code></dt>
<dd><p>整数型のアトミックなインクリメント</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">戻り値:</th><td class="field-body">操作前の古い整数型の値</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicSub!(UInt8 val)</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicSub!(SInt8 val)</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicSub!(UInt16 val)</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicSub!(SInt16 val)</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicSub!(UInt32 val)</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicSub!(SInt32 val)</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicSub!(UInt64 val)</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicSub!(SInt64 val)</code></dt>
<dd><p>整数型からアトミックな減算</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first simple">
<li><strong>val</strong> &#8211; 加算する値</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">操作前の古い整数型の値</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicDec!()</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicDec!()</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicDec!()</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicDec!()</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicDec!()</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicDec!()</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicDec!()</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicDec!()</code></dt>
<dd><p>整数型のアトミックなデクリメント</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">戻り値:</th><td class="field-body">操作前の古い整数型の値</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicOr!(UInt8 val)</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicOr!(SInt8 val)</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicOr!(UInt16 val)</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicOr!(SInt16 val)</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicOr!(UInt32 val)</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicOr!(SInt32 val)</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicOr!(UInt64 val)</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicOr!(SInt64 val)</code></dt>
<dd><p>整数型のアトミックなビット演算「or」</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first simple">
<li><strong>val</strong> &#8211; 「or」する整数型の値</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">操作前の古い整数型の値</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicAnd!(UInt8 val)</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicAnd!(SInt8 val)</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicAnd!(UInt16 val)</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicAnd!(SInt16 val)</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicAnd!(UInt32 val)</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicAnd!(SInt32 val)</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicAnd!(UInt64 val)</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicAnd!(SInt64 val)</code></dt>
<dd><p>整数型のアトミックなビット演算「and」</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first simple">
<li><strong>val</strong> &#8211; 「and」する整数型の値</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">操作前の古い整数型の値</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicXor!(UInt8 val)</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicXor!(SInt8 val)</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicXor!(UInt16 val)</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicXor!(SInt16 val)</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicXor!(UInt32 val)</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicXor!(SInt32 val)</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicXor!(UInt64 val)</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicXor!(SInt64 val)</code></dt>
<dd><p>整数型のアトミックなビット演算「xor」</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first simple">
<li><strong>val</strong> &#8211; 「xor」する整数型の値</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">操作前の古い整数型の値</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicCAS!(UInt8 oldVal, UInt8 newVal)</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicCAS!(SInt8 oldVal, SInt8 newVal)</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicCAS!(UInt16 oldVal, UInt16 newVal)</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicCAS!(SInt16 oldVal, SInt16 newVal)</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicCAS!(UInt32 oldVal, UInt32 newVal)</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicCAS!(SInt32 oldVal, SInt32 newVal)</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicCAS!(UInt64 oldVal, UInt64 newVal)</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicCAS!(SInt64 oldVal, SInt64 newVal)</code></dt>
<dd><p>アトミックな、compare-and-swap 操作を行います ―例えば、整数型の値 <code class="docutils literal"><span class="pre">oldVal</span></code> を <code class="docutils literal"><span class="pre">newVal</span></code> に変更し、値が変更された場合のみ <code class="docutils literal"><span class="pre">oldVal</span></code> を返します。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first simple">
<li><strong>oldVal</strong> &#8211; 整数型と比較する値</li>
<li><strong>newVal</strong> &#8211; 整数型の値、比較が成功した場合に設定される</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">操作前の古い整数型の値</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicGet!()</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicGet!()</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicGet!()</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicGet!()</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicGet!()</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicGet!()</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicGet!()</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicGet!()</code></dt>
<dd><p>Atomically obtains the value of an integer.  The operation is &#8220;atomic&#8221; in
the sense that the value is treated as volatile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">戻り値:</th><td class="field-body">the value of the integer</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="floating-point-types">
<span id="index-5"></span><h3>浮動小数点数型（Floating-Point Types）<a class="headerlink" href="#floating-point-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Float32</span></code> と <code class="docutils literal"><span class="pre">Float64</span></code> 型 ( <code class="docutils literal"><span class="pre">Float32</span></code> のエイリアスである <code class="docutils literal"><span class="pre">Scalar</span></code> も) は総称して浮動小数点数型（ <em class="dfn">floating-point types</em> ）として知られ、 <abbr>IEEE</abbr> 浮動小数点数を表現する。これらの型はビット幅が異なる：:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Float32</span></code></dt>
<dd>32-bit <abbr>IEEE</abbr> 浮動小数点数</dd>
<dt><code class="docutils literal"><span class="pre">Float64</span></code></dt>
<dd>64-bit <abbr>IEEE</abbr> 浮動小数点数</dd>
<dt><code class="docutils literal"><span class="pre">Scalar</span></code></dt>
<dd><code class="docutils literal"><span class="pre">Float32</span></code> へのエイリアス</dd>
</dl>
<p>浮動小数点数型の振る舞い</p>
<ul class="simple">
<li>浮動小数点数の定数は JavaScript や C言語と同じ文法を持ち、 <code class="docutils literal"><span class="pre">Float64</span></code> 型になる。詳細は  <a class="reference internal" href="syntax.html#floating-point-constants"><span class="std std-ref">浮動小数点数定数</span></a> を参照。</li>
<li>全算術演算子（ <a class="reference internal" href="ops-exprs.html#arithmetic-ops"><span class="std std-ref">arithmetic</span></a> ）、論理演算子（ <a class="reference internal" href="ops-exprs.html#logical-ops"><span class="std std-ref">logical</span></a> ）が浮動小数点数の値に対して使用できる。ビット演算子は使用不可能です。</li>
</ul>
<p>以下に浮動小数点数型の使用例を示します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">operator</span> <span class="n">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Float32</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">3.141</span><span class="p">;</span>
  <span class="n">report</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="n">Float64</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">2.718</span><span class="p">;</span>
  <span class="n">report</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
  <span class="n">Float32</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">;</span>
  <span class="n">report</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>出力:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">3.141</span>
<span class="mf">2.718</span>
<span class="mf">17.2534</span>
</pre></div>
</div>
</div>
<div class="section" id="the-string-type">
<span id="index-6"></span><h3>文字列型（<code class="docutils literal"><span class="pre">String</span></code> Type）<a class="headerlink" href="#the-string-type" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">文字列</span></code> 型はテキスト文字列 ―すなわちゼロ個以上の文字の連なりを表します。 <code class="docutils literal"><span class="pre">文字列</span></code> 型の値は <span class="target" id="index-29"></span>string value として参照されます。</p>
<p><code class="docutils literal"><span class="pre">文字列</span></code> 型のセマンティクスの理解は重要です。文字列の特徴：</p>
<ul class="simple">
<li>文字列とはゼロ個以上の文字の連なり</li>
<li>文字列の長さは、 <code class="docutils literal"><span class="pre">Size</span></code> 型であり、最大長は <span class="math">\(2^{31}-1\)</span></li>
<li>文字列定数はKLソースコード中にインライン指定可能です。JavaScript や Python 同様シングルクォーテーションもしくはダブルクォーテーションマークを使用します。文字列定数に関する詳細は <a class="reference internal" href="syntax.html#string-constants"><span class="std std-ref">文字列定数</span></a> を参照してください。</li>
<li>文字列は以下の操作とプロパティを持ちます。<ul>
<li>They have a <code class="docutils literal"><span class="pre">.length()</span></code> method which returns the number of characters in the string</li>
<li><code class="docutils literal"><span class="pre">+=</span></code> 代入演算子により他の文字列を所定の文字列に追記します。</li>
<li><code class="docutils literal"><span class="pre">+</span></code> 2項演算子を使用し、2つの文字列をつなぎ合わせ、新たな文字列を作成します。</li>
<li>論理演算子 <code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">!=</span></code>, <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code> により比較します。 さらに <code class="samp docutils literal"><em><span class="pre">string</span></em><span class="pre">.compare(</span><em><span class="pre">otherString</span></em><span class="pre">)</span></code> メソッでは -1, 0, 1 いずれかを返します。それぞれ <code class="samp docutils literal"><em><span class="pre">string</span></em></code> が <code class="samp docutils literal"><em><span class="pre">otherString</span></em></code> より 未満、等しい、超 に応じます。</li>
<li><code class="samp docutils literal"><em><span class="pre">string</span></em><span class="pre">[</span><em><span class="pre">index</span></em><span class="pre">]</span></code> を使用し、インデックスによるアクセスが可能です。与えられたインデックスに該当する1文字の文字列を結果として返します。 <code class="samp docutils literal"><em><span class="pre">index</span></em></code> は <span class="math">\([0...2^{31}-1]\)</span> の範囲である必要があります。</li>
<li><code class="samp docutils literal"><em><span class="pre">string</span></em><span class="pre">.hash()</span></code> メソッドにより、文字列の32-bit のハッシュ値を得ます。</li>
</ul>
</li>
<li>C/C++言語と異なり、文字列にはヌル文字(ASCII 0)を許容します。</li>
<li>文字列はそれ自体にエンコーディング（符号化）の概念を持ちません。つまりただの連続したバイトにすぎません。その文字列が使用されるアプリケーション空間において、文字列エンコーディングが決定されます。Fabric自体ではUTF-8エンコーディングを使用しますが、Fabricエクステンションでは、文字列をそれぞれ別のエンコーディングに変換する必要がある場合があります。</li>
<li>KLの他の全ての型は、キャストし文字列へ変換することができます。この変換によりある値を人間可読な文字列とすることができます。カスタム型においてこの変換 ―  <code class="samp docutils literal"><span class="pre">function</span> <em><span class="pre">Type</span></em><span class="pre">.appendDesc(io</span> <span class="pre">String</span> <span class="pre">string)</span></code> メソッド ― はオーバーライド可能です。 see <a class="reference internal" href="globals.html#conversion-funcs"><span class="std std-ref">変換関数</span></a> を参照してください。</li>
</ul>
<p><code class="docutils literal"><span class="pre">String</span></code> 型の使用例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">operator</span> <span class="n">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;A string&quot;</span><span class="p">;</span>
  <span class="n">report</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="n">report</span><span class="p">(</span><span class="s2">&quot;a has length &quot;</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">length</span><span class="p">());</span>
  <span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;Another string&quot;</span><span class="p">;</span>
  <span class="n">report</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="n">String</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="s2">&quot; and &quot;</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">report</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="n">b</span> <span class="o">+=</span> <span class="s2">&quot; now includes &quot;</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">report</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>出力:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="n">string</span>
<span class="n">a</span> <span class="n">has</span> <span class="n">length</span> <span class="mi">8</span>
<span class="n">Another</span> <span class="n">string</span>
<span class="n">A</span> <span class="n">string</span> <span class="ow">and</span> <span class="n">Another</span> <span class="n">string</span>
<span class="n">Another</span> <span class="n">string</span> <span class="n">now</span> <span class="n">includes</span> <span class="n">A</span> <span class="n">string</span>
</pre></div>
</div>
</div>
<div class="section" id="the-rtval-type">
<h3>The <code class="docutils literal"><span class="pre">RTVal</span></code> Type<a class="headerlink" href="#the-rtval-type" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The <code class="code docutils literal"><span class="pre">RTVal</span></code> type is a type that holds a dynamically-typed valued</p>
</div>
</div>
<div class="section" id="derived-types">
<span id="klpg-types-derived"></span><span id="index-8"></span><h2>派生型（Derived Types）<a class="headerlink" href="#derived-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>基本型に加え、KLは３つの派生型をサポートします。構造体（structures）配列（arrays）辞書（dictionaries）です。</p>
<div class="section" id="structures">
<span id="klpg-types-structures"></span><span id="index-9"></span><h3>構造体（Structures）<a class="headerlink" href="#structures" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>構造体（ <em class="dfn">structure</em> ）ではいくつかの型の値がメモリ上に一緒に配置されます。</p>
<p>構造体は通常、Fabric&#8217;s <span class="target" id="index-30"></span>registered type system を使いKL外に定義されますが、KLソースコード内に直接 <code class="docutils literal"><span class="pre">struct</span></code> キーワードを使い宣言することもできます。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">NewType</span> <span class="p">{</span>
  <span class="n">Float32</span> <span class="n">firstMember</span><span class="p">;</span>
  <span class="n">String</span> <span class="n">secondMember</span><span class="p">;</span>
  <span class="n">Integer</span> <span class="n">thirdMemberVarArray</span><span class="p">[],</span> <span class="n">fourthMemberFixedArray</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>注意：可変長配列は一番最後のメンバとして宣言します。派生型は任意にネストすることが可能です。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
全ての構造体の宣言は、グローバルスコープに置かれます。関数スコープ内での宣言は不可能です。</div>
<p>構造体に関する詳細：</p>
<ul class="simple">
<li>構造体のメンバに対するアクセスには <code class="docutils literal"><span class="pre">.</span></code> (ドット) 演算子をJavaScript同様、使用します。</li>
<li>現状、構造体メンバは C言語ライクなアライメントを使用します。 <a class="reference internal" href="#structure-alignment"><span class="std std-ref">構造体メンバのアライメント</span></a> 参照).</li>
<li>演算子オーバーロードが可能で、メソッド <em class="dfn">methods</em> を構造体に追加できます。 <a class="reference internal" href="globals.html#methods"><span class="std std-ref">メソッド</span></a> 参照</li>
<li><code class="docutils literal"><span class="pre">public</span></code>, <code class="docutils literal"><span class="pre">private</span></code>, <code class="docutils literal"><span class="pre">protected</span></code>, <code class="docutils literal"><span class="pre">permits</span></code> キーワードを使用し、構造体メンバ、メソッドに対するアクセス制御が可能です。 <a class="reference internal" href="#klpg-types-member-access"><span class="std std-ref">構造体、オブジェクト、インタフェースでのアクセス制御</span></a> 参照</li>
</ul>
<p>構造体の使用例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">MyNewType</span> <span class="p">{</span>
  <span class="n">Integer</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">String</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">function</span> <span class="n">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">MyNewType</span> <span class="n">mnt</span><span class="p">;</span>
  <span class="n">mnt</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Hello!&quot;</span><span class="p">;</span>
  <span class="n">mnt</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
  <span class="n">mnt</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;there!&quot;</span><span class="p">;</span>
  <span class="n">report</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>出力:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="n">s</span><span class="p">:</span><span class="s2">&quot;Hello!&quot;</span><span class="p">,</span><span class="n">t</span><span class="p">:</span><span class="s2">&quot;there!&quot;</span><span class="p">}</span>
</pre></div>
</div>
<div class="section" id="structure-member-alignment">
<span id="structure-alignment"></span><span id="index-11"></span><h4>構造体メンバのアライメント<a class="headerlink" href="#structure-member-alignment" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>構造体メンバのアライメントは、C言語でのそれと同一です。従い、 Fabric Engine の EDK コードとのインタフェースでは、KLでの構造体に合わせた特別なアライメントの指定は必要ありません。</p>
<p>参考までに、KLの構造体のアライメントに関するルール（つまりC言語のディフォルトと一緒）は：</p>
<ul class="simple">
<li>全ての型は、サイズとアライメントを持つ</li>
<li>基本型のアライメントは、その型のサイズと同一</li>
<li>構造体（全体）のアライメントはその構造体のメンバの型のうち一番大きい物</li>
<li>メンバの構造体内でのバイト位置は、次に利用可能な構造体のオフセットからメンバの型のアライメントへ切り上げ選択されます。</li>
</ul>
</div>
<div class="section" id="structure-inheritance">
<span id="kplg-structure-inheritance"></span><span id="index-12"></span><h4>構造体の継承<a class="headerlink" href="#structure-inheritance" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.13.0 で追加.</span></p>
</div>
<p>ある構造体は基となる一つの構造体を継承（ <cite>inherit</cite> もしくは <cite>derive</cite> ）できます。特殊化した構造体は、基底構造体より全てのメンバとメソッドを継承します。</p>
<p><code class="samp docutils literal"><span class="pre">struct</span> <em><span class="pre">SpecializedType</span></em> <span class="pre">:</span> <em><span class="pre">BaseType</span></em></code> 構文を使用し継承関係の宣言をします。特殊化した構造体は基底構造体へとノーコストで <cite>cast</cite> が可能です。 <code class="samp docutils literal"><span class="pre">.parent</span></code> アクセッサにより、明示的にキャストします。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">struct</span> <span class="nx">Shape</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">centerX</span><span class="p">,</span> <span class="nx">centerY</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">struct</span> <span class="nx">Circle</span> <span class="o">:</span> <span class="nx">Shape</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">radius</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Circle</span> <span class="nx">c</span><span class="p">;</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">centerX</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">centerY</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="nb">report</span><span class="p">(</span> <span class="nx">c</span> <span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span> <span class="nx">c</span><span class="p">.</span><span class="nx">parent</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{centerX:+1.0,centerY:+2.0,radius:+3.0}</span>
<span class="cm">{centerX:+1.0,centerY:+2.0}</span>

<span class="cm">*/</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>基底型へとキャストすると、その構造体は特殊化した振舞を全て失います。オブジェクト（ <span class="xref std std-ref">objects</span> ）との違いです。</p>
<div class="last highlight-kl"><div class="highlight"><pre><span></span><span class="kr">struct</span> <span class="nx">Shape</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">centerX</span><span class="p">,</span> <span class="nx">centerY</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">struct</span> <span class="nx">Circle</span> <span class="o">:</span> <span class="nx">Shape</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">radius</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">printShape</span><span class="p">(</span> <span class="nx">Shape</span> <span class="nx">s</span> <span class="p">)</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span> <span class="nx">s</span><span class="p">.</span><span class="nx">type</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="nx">s</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Circle</span> <span class="nx">c</span><span class="p">;</span>
  <span class="nx">printShape</span><span class="p">(</span> <span class="nx">c</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">Shape: {centerX:+0.0,centerY:+0.0}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="objects">
<span id="klpg-types-objects"></span><span id="index-13"></span><h3>オブジェクト（Objects）<a class="headerlink" href="#objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.12.0 で変更: </span>オブジェクト型変数の &#8220;empty construction&#8221; は不可能になりました</p>
</div>
<p>オブジェクト（ <em class="dfn">object</em> ）は、メモリ内に幾つかの型の値を一緒に保持するという点において構造体（ <a class="reference internal" href="#klpg-types-structures"><span class="std std-ref">structure</span></a> ）に似ています。違いは、オブジェクトが「参照によるコピー（copy-by-reference）」であるのに対し、構造体では「値によるコピー（copy-by-value）」な点です。オブジェクトは <em class="dfn">constructed</em> され内部において参照カウントされます。さらにオブジェクトでは、そのオブジェクトでのサポートが保証されるメソッドの集合の <a class="reference internal" href="#klpg-types-interfaces"><span class="std std-ref">interfaces</span></a> をサポートします。</p>
<p>オブジェクトは構造体とほぼ同じように使用できます。おおきな違いは、copy-by-referenceな点、コンストラクトされなくてはいけない点です。KLは内部に各オブジェクトの参照番号のトラックを保持し、そのオブジェクトの最後の参照が破棄された際、オブジェクトは開放されます。スコープから外れるか、オブジェクトに  <code class="code docutils literal"><span class="pre">null</span></code>  が割り当てられると、オブジェクトは参照を落とします。</p>
<p>KLコード中、 <code class="code docutils literal"><span class="pre">object</span></code> キーワードを使用しオブジェクトを定義します。このシンタックスは構造体とほぼ一緒です。 <a class="reference internal" href="#klpg-types-structures"><span class="std std-ref">structures</span></a> 参照</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="c1">// An object with two members</span>
<span class="kr">object</span> <span class="nx">Obj</span> <span class="p">{</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
  <span class="kr">UInt32</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>必要に応じ、オブジェクトはある1つの基底オブジェクトを継承し、さらに1つ以上の <a class="reference internal" href="#klpg-types-interfaces"><span class="std std-ref">interfaces</span></a> を実装することができます。オブジェクトの名前の後に、継承するオブジェクト、実装するインターフェースを示します。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="c1">// An object with two members that implements two interfaces</span>
<span class="kr">object</span> <span class="nx">MyObjType</span> <span class="o">:</span> <span class="nx">BaseObjType</span><span class="p">,</span> <span class="nx">IntOne</span><span class="p">,</span> <span class="nx">IntTwo</span> <span class="p">{</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
  <span class="kr">UInt32</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>型にオブジェクトを与えた変数は、そのオブジェクトの名とともに宣言します。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="c1">// A variable of type MyObjType</span>
<span class="nx">MyObjType</span> <span class="nx">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// reports: null</span>
</pre></div>
</div>
<p>値 <code class="code docutils literal"><span class="pre">null</span></code> は存在しないオブジェクトを参照します。オブジェクトが <code class="code docutils literal"><span class="pre">null</span></code> であると、report可能ですが、実行時にそのオブジェクトのメンバを参照したり、メソッドを呼び出すと、ランタイムエラーとなります。</p>
<p>どのオブジェクト型の変数も <code class="code docutils literal"><span class="pre">null</span></code> に設定可能です。 <code class="code docutils literal"><span class="pre">null</span></code> オブジェクトに対するほとんど操作は、実行時エラーとなります。正常なオブジェクトの作成には、コンストラクトします。コンストラクトする2種類の文法：</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="nx">MyObjType</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">MyObjType</span><span class="p">();</span> <span class="c1">// calls the default constructor</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// reports: {s:&quot;&quot;,n:0}</span>
<span class="nx">MyObjType</span> <span class="nx">obj2</span><span class="p">();</span> <span class="c1">// also calls the default constructor</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">obj2</span><span class="p">);</span> <span class="c1">// reports: {s:&quot;&quot;,n:0}</span>
<span class="nx">obj2</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// releases the object referenced by obj2</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">obj2</span><span class="p">);</span> <span class="c1">// throws an error</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
オブジェクトは&#8221;empty constructed&#8221;不可能です。明示的にコンストラクトするか、明示的に <code class="code docutils literal"><span class="pre">null</span></code> に設定します。</div>
<p><a class="reference internal" href="globals.html#klpg-constructor"><span class="std std-ref">Constructors</span></a> と <a class="reference internal" href="globals.html#klpg-destructor"><span class="std std-ref">destructors</span></a> を構造体同様、オブジェクトでも指定することができます</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="c1">// Provide a default constructor</span>
<span class="kd">function</span> <span class="nx">MyObjType</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Provide a constructor that takes parameters</span>
<span class="kd">function</span> <span class="nx">MyObjType</span><span class="p">(</span><span class="kr">String</span> <span class="nx">s</span><span class="p">,</span> <span class="kr">UInt32</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="nx">s</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// later..</span>
<span class="nx">MyObjType</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">MyObjType</span><span class="p">();</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// reports: {s:&quot;hello&quot;,n:42}</span>
<span class="nx">obj</span> <span class="o">=</span> <span class="nx">MyObjType</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// reports: {s:&quot;foo&quot;,n:7}</span>
</pre></div>
</div>
<p>他の同型オブジェクトから特定のオブジェクトをコンストラクトすると、新しいオブジェクトは古いオブジェクトを参照します。この場合、新しいオブジェクトは実際には作られていません。つまり参照を通し、そのうちの1つのオブジェクトに変更が加わると、もう片方のオブジェクトも同様、変更されます。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="nx">MyObjType</span> <span class="nx">o1</span><span class="p">(</span><span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="nx">MyObjType</span> <span class="nx">o2</span> <span class="o">=</span> <span class="nx">o1</span><span class="p">;</span>
<span class="nx">o2</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="s2">&quot;baz&quot;</span><span class="p">;</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">o1</span><span class="p">);</span> <span class="c1">// reports: {s:&quot;baz&quot;,n:3}</span>
</pre></div>
</div>
<p>ユーザ独自のコピーコンストラクタを定義することはできません。以下の理由のためです。コピーコンストラクタは既存のオブジェクトに対し、参照を常に１つ加算します。かりに新規オブジェクトをインスタンス化したいのであれば、 <code class="docutils literal"><span class="pre">clone()</span></code> メソッド（ <a class="reference internal" href="#klpg-types-objects-clone"><span class="std std-ref">Object clone() メソッド</span></a> 参照）か、カスタムメソッドを使用します。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Duplicating an object using a custom method</span>
<span class="cm">*/</span>

<span class="c1">// not permitted, custom copy constructor invalid for objects</span>
<span class="c1">// function MyObjType(MyObjType o)</span>
<span class="c1">// {</span>
<span class="c1">//   // ...</span>
<span class="c1">// }</span>

<span class="kr">object</span> <span class="nx">MyObjType</span>
<span class="p">{</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
  <span class="kr">Integer</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// return a new object using a custom method</span>
<span class="kd">function</span> <span class="nx">MyObjType</span> <span class="nx">MyObjType</span><span class="p">.</span><span class="nx">copy</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nx">MyObjType</span> <span class="nx">o</span> <span class="o">=</span> <span class="nx">MyObjType</span><span class="p">();</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">s</span><span class="p">;</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">n</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nx">MyObjType</span> <span class="nx">o1</span><span class="p">();</span>
  <span class="nx">o1</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">;</span>
  <span class="nx">o1</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

  <span class="nx">MyObjType</span> <span class="nx">o2</span> <span class="o">=</span> <span class="nx">o1</span><span class="p">.</span><span class="nx">copy</span><span class="p">();</span>

  <span class="nx">o2</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="s2">&quot;bar&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;o1 = &quot;</span> <span class="o">+</span> <span class="nx">o1</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;o2 = &quot;</span> <span class="o">+</span> <span class="nx">o2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">o1 = {s:&quot;foo&quot;,n:42}</span>
<span class="cm">o2 = {s:&quot;bar&quot;,n:42}</span>

<span class="cm">*/</span>
</pre></div>
</div>
<p>構造体同様、オブジェクトには任意のメソッドを定義できます。これらのメソッドは <code class="samp docutils literal"><em><span class="pre">object</span></em><span class="pre">.</span><em><span class="pre">methodName</span></em><span class="pre">(</span><em><span class="pre">arg</span></em><span class="pre">,</span><em><span class="pre">arg</span></em><span class="pre">,...)</span></code> 構文を使用し呼び出します。 <code class="code docutils literal"><span class="pre">null</span></code> に対するメソッドの呼び出しは実行時例外を引き起こします。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">MyObjType</span><span class="p">.</span><span class="nx">reportMe</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;reportMe: s=&quot;</span><span class="o">+</span><span class="k">this</span><span class="p">.</span><span class="nx">s</span><span class="o">+</span><span class="s2">&quot; n=&quot;</span><span class="o">+</span><span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">MyObjType</span> <span class="nx">obj</span><span class="p">(</span><span class="s2">&quot;Fred&quot;</span><span class="p">,</span> <span class="mi">49</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">reportMe</span><span class="p">();</span> <span class="c1">// reports: reportMe: s=Fred n=49</span>
</pre></div>
</div>
<p>構造体同様、オブジェクトのメンバへのアクセスには <code class="samp docutils literal"><em><span class="pre">object</span></em><span class="pre">.</span><em><span class="pre">memberName</span></em></code> 構文を使用します。<code class="code docutils literal"><span class="pre">null</span></code> オブジェクトに対する <code class="code docutils literal"><span class="pre">.</span></code> （ドット）の使用も実行時例外となります。</p>
<p>オブジェクトのさらなる特徴:</p>
<ul class="simple">
<li>オブジェクト型の値が <code class="code docutils literal"><span class="pre">Boolean</span></code> に変換されると、そのオブジェクトが <code class="code docutils literal"><span class="pre">null</span></code> ではない場合 <code class="code docutils literal"><span class="pre">true</span></code> となる</li>
<li><a class="reference internal" href="ops-exprs.html#equality-ops"><span class="std std-ref">equality operators</span></a> <code class="samp docutils literal"><em><span class="pre">obj1</span></em> <span class="pre">==</span> <em><span class="pre">obj2</span></em></code> and <code class="samp docutils literal"><em><span class="pre">obj1</span></em> <span class="pre">!=</span> <em><span class="pre">obj2</span></em></code> はオブジェクトがオーバーロドされているか、 <code class="code docutils literal"><span class="pre">null</span></code> と比較されている場合のみ、有効です。 <a class="reference internal" href="ops-exprs.html#identity-ops"><span class="std std-ref">identity operators</span></a> <code class="samp docutils literal"><em><span class="pre">obj1</span></em> <span class="pre">===</span> <em><span class="pre">obj2</span></em></code> and <code class="samp docutils literal"><em><span class="pre">obj1</span></em> <span class="pre">!==</span> <em><span class="pre">obj2</span></em></code> は常に有効で、同一のオブジェクトを参照してりうかどうかに依って比較されます。 (すなわち変更が双方に影響します)</li>
<li>オブジェクト型の値は、 <code class="samp docutils literal"><span class="pre">&lt;objectValue&gt;.uid()</span></code> をサポートしユニークな UInt64 を返します。オブジェクトの同定に使用できます。この値は、そのオブジェクトをそれがサポートするどのようなインターフェースにキャストしたものに対し <cite>.uid()</cite> を呼び出した結果と同一です。</li>
<li>オブジェクトに <code class="code docutils literal"><span class="pre">null</span></code> を代入するとそのオブジェクトが過去に示した参照全てをドロップします。</li>
<li><code class="docutils literal"><span class="pre">public</span></code>, <code class="docutils literal"><span class="pre">private</span></code>, <code class="docutils literal"><span class="pre">protected</span></code>, <code class="docutils literal"><span class="pre">permits</span></code> キーワードにより、オブジェクトのメンバ、メソッドに対するアクセス制御が可能です。 <a class="reference internal" href="#klpg-types-member-access"><span class="std std-ref">構造体、オブジェクト、インタフェースでのアクセス制御</span></a> 参照</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
オブジェクト型の変数は、構造体を示す事はできません。オブジェクト、またインターフェイスは根本的に構造体とは異なります。 <a class="reference internal" href="#klpg-objects-versus-structures"><span class="std std-ref">オブジェクト vs 構造体</span></a> 節参照</div>
<p>オブジェクトの別な使用例：</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Objects</span>
<span class="cm">*/</span>

<span class="kr">object</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="kr">SInt32</span> <span class="nx">intMember</span><span class="p">;</span>
  <span class="kr">String</span> <span class="nx">stringMember</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// A non-default constructor for Foo</span>
<span class="kd">function</span> <span class="nx">Foo</span><span class="p">(</span><span class="kr">SInt32</span> <span class="nx">i</span><span class="p">,</span> <span class="kr">String</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">intMember</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">stringMember</span> <span class="o">=</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Foo</span> <span class="nx">foo1</span> <span class="o">=</span> <span class="nx">Foo</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="s2">&quot;foo&quot;</span><span class="p">);</span> <span class="c1">// call the non-default constructor</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">foo1</span><span class="p">);</span>
  <span class="nx">Foo</span> <span class="nx">foo2</span><span class="p">();</span> <span class="c1">// call the default constructor</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">foo2</span><span class="p">);</span>
  <span class="nx">Foo</span> <span class="nx">foo3</span><span class="p">(</span><span class="nx">foo1</span><span class="p">);</span> <span class="c1">// make foo3 a reference to foo1</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">foo3</span><span class="p">);</span>
  <span class="nx">foo3</span><span class="p">.</span><span class="nx">intMember</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="c1">// since foo1 and foo3 refer to the same object, both change!</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">foo1</span><span class="p">);</span>
  <span class="nx">Foo</span> <span class="nx">foo4</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// a null object</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">foo4</span><span class="p">);</span>
  <span class="nx">foo4</span><span class="p">.</span><span class="nx">intMember</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// throws an exception</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{intMember:32,stringMember:&quot;foo&quot;}</span>
<span class="cm">{intMember:0,stringMember:&quot;&quot;}</span>
<span class="cm">{intMember:32,stringMember:&quot;foo&quot;}</span>
<span class="cm">{intMember:20,stringMember:&quot;foo&quot;}</span>
<span class="cm">null</span>
<span class="cm">Error: (stdin):29:3: dereferenced null object</span>
<span class="cm">KL stack trace:</span>
<span class="cm">[ST] 1 kl.internal.String.SetErrorDataPtrAndLength.AS0()</span>
<span class="cm">[ST] 2 function.setError.R.St()</span>
<span class="cm">[ST] 3 operator.entry() (stdin):29</span>
<span class="cm">[ST] 4 kl.internal.entry.stub.cpu()</span>

<span class="cm">*/</span>
</pre></div>
</div>
<div class="section" id="the-object-clone-method">
<span id="klpg-types-objects-clone"></span><h4>Object <code class="docutils literal"><span class="pre">clone()</span></code> メソッド<a class="headerlink" href="#the-object-clone-method" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.15.0 で追加.</span></p>
</div>
<p>KLでの他の多くの型同様オブジェクトは、オブジェクトのディープコピーを行う <code class="docutils literal"><span class="pre">clone()</span></code> メソッドをサポートします。全てのオブジェクトはディフォルトで <code class="docutils literal"><span class="pre">clone()</span></code> を実装しています。独自定義したメソッド <code class="docutils literal"><span class="pre">&lt;ObjectType&gt;.cloneMembersTo(io</span> <span class="pre">&lt;ObjectType&gt;</span> <span class="pre">that)</span></code> を記述し <code class="docutils literal"><span class="pre">clone()</span></code> の振舞を、変更できます。このメソッドはオブジェクトの複製処理を行う際、自動的に呼びだされます。以下に示す：</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Object Custom Clone</span>
<span class="cm">*/</span>

<span class="kr">object</span> <span class="nx">Obj</span>
<span class="p">{</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
  <span class="kr">Integer</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">Obj</span><span class="p">.</span><span class="nx">cloneMembersTo</span><span class="p">(</span><span class="k">io</span> <span class="nx">Obj</span> <span class="nx">that</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nx">that</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">s</span> <span class="o">+</span> <span class="s2">&quot; cloned&quot;</span><span class="p">;</span>
  <span class="nx">that</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nx">Obj</span> <span class="nx">obj1</span><span class="p">();</span>
  <span class="nx">obj1</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="s2">&quot;string&quot;</span><span class="p">;</span>
  <span class="nx">obj1</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj1 = &quot;</span> <span class="o">+</span> <span class="nx">obj1</span><span class="p">);</span>

  <span class="nx">Obj</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nx">obj1</span><span class="p">.</span><span class="nx">clone</span><span class="p">();</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj2 = &quot;</span> <span class="o">+</span> <span class="nx">obj2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">obj1 = {s:&quot;string&quot;,n:42}</span>
<span class="cm">obj2 = {s:&quot;string cloned&quot;,n:84}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="the-object-refcount-method">
<span id="kplg-types-objects-refcount"></span><h4>The Object <code class="docutils literal"><span class="pre">refCount()</span></code> Method<a class="headerlink" href="#the-object-refcount-method" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>You can query the number of references pointing to a certain object by using the method <code class="docutils literal"><span class="pre">refCount()</span></code>, as shown below:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Object Reference Count</span>
<span class="cm">*/</span>

<span class="kr">object</span> <span class="nx">Foo</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nx">Foo</span> <span class="nx">foo</span><span class="p">();</span>
  <span class="nx">Foo</span> <span class="nx">newRef</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span>
  <span class="nx">Foo</span> <span class="nx">newRef1</span> <span class="o">=</span> <span class="nx">newRef</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;foo ref count = &quot;</span> <span class="o">+</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">refCount</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">foo ref count = 3</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="object-inheritance">
<span id="klpg-object-inheritance"></span><h4>オブジェクトの継承<a class="headerlink" href="#object-inheritance" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.13.0 で追加.</span></p>
</div>
<p>構造体と同じように、オブジェクトは他のベースオブジェクトを1つ継承できます。特殊化したオブジェクトは、基底オブジェクトのすべてのメンバとメソッドを引き継ぎます。 <code class="samp docutils literal"><span class="pre">struct</span> <em><span class="pre">SpecializedType</span></em> <span class="pre">:</span> <em><span class="pre">BaseType</span></em></code> 構文を使用し継承関係を宣言します。</p>
<p><code class="samp docutils literal"><em><span class="pre">object</span></em><span class="pre">.</span><em><span class="pre">parent</span></em></code> 構文により、基底オブジェクトから継承している場合、明示的に基底型へとキャストを行います。特殊化したメンバやメソッドが基底オブジェクトと異なる定義を持つ場合、便利です。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">object</span> <span class="nx">MyBaseObject</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">f</span><span class="p">;</span>
  <span class="nx">Size</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">object</span> <span class="nx">MyObject</span> <span class="o">:</span> <span class="nx">MyBaseObject</span> <span class="p">{</span>
  <span class="nx">Size</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">MyObject</span> <span class="nx">o</span><span class="p">();</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">f</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{f:+0.5,s:1,s:2}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="interfaces">
<span id="klpg-types-interfaces"></span><span id="index-14"></span><h3>インタフェース（Interfaces）<a class="headerlink" href="#interfaces" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.12.0 で変更: </span>インタフェース型の変数の &#8220;empty construction&#8221; の使用が不可能になりました</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.15.0 で変更: </span><code class="docutils literal"><span class="pre">&lt;typeExpr&gt;.createNew()</span></code> メソッドが追加されました</p>
</div>
<p><em class="dfn">interface</em> とは、あるオブジェクトが必ず実装しなければならないメソッドの一連の集合です。オブジェクトは、オブジェクトの宣言に単にインタフェースの名前を入れるだけでなくインタフェースの各メソッドを実際に実装することで、インタフェースを実装します。プログラマはどのようなオブジェクトの型であっても、インタフェースを実装するオブジェクトであれば、ファーストクラス型としてインタフェースを使用し参照することができます。</p>
<p><code class="code docutils literal"><span class="pre">interface</span></code> キーワードによりインタフェースを定義します。インタフェース定義は構造体や、オブジェクト定義に似ています。メンバやメソッドは指定することを除きます。例えば：</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">MyInt</span> <span class="p">{</span>
  <span class="kr">UInt32</span> <span class="nx">foo</span><span class="p">();</span>
  <span class="nx">bar</span><span class="o">?</span><span class="p">(</span><span class="k">io</span> <span class="kr">String</span> <span class="nx">s</span><span class="p">);</span>
  <span class="kr">Float32</span> <span class="nx">baz</span><span class="o">!</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>このサンプルでは、インタフェース <code class="code docutils literal"><span class="pre">MyInt</span></code> に３つのメソッドを与え、定義します。引数パラメータと、返り値の型は、構造体やオブジェクト同様におきます（ <a class="reference internal" href="globals.html#methods"><span class="std std-ref">methods</span></a> ）。ただし、 <code class="code docutils literal"><span class="pre">function</span></code> キーワードと、型名は省きます。メソッド呼び出しによりそのオブジェクトが変更されるかどうか明示的に示す <code class="code docutils literal"><span class="pre">!</span></code> and <code class="code docutils literal"><span class="pre">?</span></code> は機能します。</p>
<p>インタフェースには、それを実装するオブジェクトがサポートしなければならない一連のメソッド「のみ」を指定します。インタフェースを使用するには、そのインタフェースをサポートしたオブジェクトを定義する必要があります。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="c1">// An object type that implements MyInt</span>
<span class="kr">object</span> <span class="nx">MyObj</span> <span class="o">:</span> <span class="nx">MyInt</span> <span class="p">{</span>
  <span class="kr">UInt32</span> <span class="nx">n</span><span class="p">;</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="kr">UInt32</span> <span class="nx">MyObj</span><span class="p">.</span><span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">MyObj</span><span class="p">.</span><span class="nx">bar</span><span class="o">?</span><span class="p">(</span><span class="k">io</span> <span class="kr">String</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="kr">Float32</span> <span class="nx">MyObj</span><span class="p">.</span><span class="nx">baz</span><span class="o">!</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mf">3.14</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>インタフェースの実装には、オブジェクト型名直後にインタフェースを、そして各メソッドの実装の一覧を列記します。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
オブジェクトの実装に、インタフェースに必要なメソッド定義が一つでも欠けていると、コンパイル時エラーとなります。</div>
<p>オブジェクトには複数のインタフェースを実装できます。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">MyOtherInt</span> <span class="p">{</span>
  <span class="nx">fred</span><span class="p">();</span>
  <span class="kr">Float32</span> <span class="nx">baz</span><span class="o">!</span><span class="p">();</span>
<span class="p">};</span>

<span class="kr">object</span> <span class="nx">MyDoubleObj</span> <span class="o">:</span> <span class="nx">MyInt</span><span class="p">,</span> <span class="nx">MyOtherInt</span> <span class="p">{</span>
  <span class="kr">Boolean</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="kr">UInt32</span> <span class="nx">MyDoubleObj</span><span class="p">.</span><span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ....</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">MyDoubleObj</span><span class="p">.</span><span class="nx">bar</span><span class="o">?</span><span class="p">(</span><span class="k">io</span> <span class="kr">String</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ....</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="kr">Float32</span> <span class="nx">MyDoubleObj</span><span class="p">.</span><span class="nx">baz</span><span class="o">!</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="p">;</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="o">?</span> <span class="o">-</span><span class="mf">7.5</span><span class="o">:</span> <span class="mf">14.5</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">MyDoubleObj</span><span class="p">.</span><span class="nx">fred</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>メソッドを共有するような複数のインタフェースを、オブジェクトがサポートすることは可能です。それにはメソッドを1度だけ実装します。実装したメソッドは全てのインタフェースから共有されます。</p>
<p>インタフェースを定義すると、あるインタフェースを実装したオブジェクトを参照する変数を宣言できます。 <code class="samp docutils literal"><em><span class="pre">int</span></em><span class="pre">.</span><em><span class="pre">methodName</span></em><span class="pre">(</span><em><span class="pre">arg</span></em><span class="pre">,</span> <em><span class="pre">arg</span></em><span class="pre">,</span> <span class="pre">...)</span></code> 構文により、そのオブジェクトのメソッドを呼び出します。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="nx">MyInt</span> <span class="nx">myInt</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// does not refer to an object</span>
<span class="nx">myInt</span> <span class="o">=</span> <span class="nx">MyObj</span><span class="p">();</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">myInt</span><span class="p">);</span> <span class="c1">// reports: {n:0, s:&quot;&quot;} since it is a MyObj</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">myInt</span><span class="p">.</span><span class="nx">baz</span><span class="p">());</span> <span class="nx">reports</span><span class="o">:</span> <span class="mf">0.0</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">myInt</span><span class="p">.</span><span class="nx">baz</span><span class="p">());</span> <span class="nx">reports</span><span class="o">:</span> <span class="mf">3.14</span>
<span class="nx">myInt</span> <span class="o">=</span> <span class="nx">MyDoubleObj</span><span class="p">();</span> <span class="c1">// releases old object</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">myInt</span><span class="p">);</span> <span class="c1">// reports: {b:false}</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">myInt</span><span class="p">.</span><span class="nx">baz</span><span class="p">());</span> <span class="nx">reports</span><span class="o">:</span> <span class="o">-</span><span class="mf">7.5</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">myInt</span><span class="p">.</span><span class="nx">baz</span><span class="p">());</span> <span class="nx">reports</span><span class="o">:</span> <span class="mf">14.5</span>
</pre></div>
</div>
<p><code class="samp docutils literal"><em><span class="pre">interface</span></em><span class="pre">.type()</span></code> メソッドのより、インタフェースから参照しているオブジェクトの型を確認します。割当もしくはキャストにより、特定のオブジェクトを得ます。これにより、KLでの単純な「弱い（もしくは実行時）型付け」の形式（simple form of weak(or runtime) typing）を可能にします。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="nx">myInt</span><span class="p">.</span><span class="nx">type</span><span class="p">()</span> <span class="o">==</span> <span class="nx">MyObj</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">MyObj</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="nx">myInt</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">myInt</span><span class="p">.</span><span class="nx">type</span><span class="p">()</span> <span class="o">==</span> <span class="nx">MyDoubleObj</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">MyDoubleObj</span> <span class="nx">myDoubleObj</span> <span class="o">=</span> <span class="nx">myInt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このケースでは、この式の型は <code class="code docutils literal"><span class="pre">Type</span></code> 型です。したがって、 <code class="docutils literal"><span class="pre">&lt;typeExpr&gt;.createNew()</span></code> メソッドを呼ぶと、新しいオブジェクトインスタンスを作成します。インタフェースは空コンストラクタを使用しインスタンスになります。結果として、  <a class="reference internal" href="#klpg-interfaces-object"><span class="std std-ref">Object interface</span></a>  型になります。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: &lt;typeExpr&gt;.createNew()</span>
<span class="cm">*/</span>

<span class="kr">object</span> <span class="nx">Obj</span>
<span class="p">{</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nx">Obj</span> <span class="nx">obj1</span><span class="p">();</span>
  <span class="nx">obj1</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj1 = &quot;</span> <span class="o">+</span> <span class="nx">obj1</span><span class="p">);</span>

  <span class="nx">Object</span> <span class="nx">abstractObject</span> <span class="o">=</span> <span class="nx">obj1</span><span class="p">;</span>

  <span class="nx">Obj</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nx">abstractObject</span><span class="p">.</span><span class="nx">type</span><span class="p">().</span><span class="nx">createNew</span><span class="p">();</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj2 = &quot;</span> <span class="o">+</span> <span class="nx">obj2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">obj1 = {s:&quot;hello&quot;}</span>
<span class="cm">obj2 = {s:&quot;&quot;}</span>

<span class="cm">*/</span>
</pre></div>
</div>
<p>インタフェースを、間違ったオブジェクトへ割当もしくはキャストすると、実行時例外となります。「型がインタフェースな値」を、「型が他のインタフェースである変数」へと割り当てる事もできます。つまり、基礎となるオブジェクトが、第2のインタフェースをサポートする場合、そのオブジェクトの第2のインタフェースへの <code class="code docutils literal"><span class="pre">null</span></code> ではない参照を得ることができます。第2のインタフェースをサポートしていなければ、実行時例外が発生します。</p>
<p>インタフェースのさらなる特徴</p>
<ul class="simple">
<li><code class="code docutils literal"><span class="pre">Boolean</span></code> へのキャストがオブジェクト同様正常に可能です。 <code class="code docutils literal"><span class="pre">null</span></code> を参照しているかどうかをチェックします</li>
<li>比較演算子 <code class="samp docutils literal"><em><span class="pre">int1</span></em> <span class="pre">==</span> <em><span class="pre">int2</span></em></code>, <code class="samp docutils literal"><em><span class="pre">int1</span></em> <span class="pre">!=</span> <em><span class="pre">int2</span></em></code>,そして同一比較演算子 <code class="samp docutils literal"><em><span class="pre">int1</span></em> <span class="pre">===</span> <em><span class="pre">int2</span></em></code>, <code class="samp docutils literal"><em><span class="pre">int1</span></em> <span class="pre">!==</span> <em><span class="pre">int2</span></em></code>, では2つのインタフェース同士が、同一（あるは別）のオブジェクトを参照するかどうかを判断します。（以前に参照されていたオブジェクトならなんでも）</li>
<li>インタフェース型の値は <code class="samp docutils literal"><span class="pre">&lt;interfaceValue&gt;.uid()</span></code> メソッドをサポートし、インタフェースの参照するオブジェクトの同一性に依存した、ユニークな UInt64 を返します。この値はそのインタフェースの参照するオブジェクトで  <cite>.uid()</cite> を呼んだ時の値と同じになります。</li>
<li><code class="docutils literal"><span class="pre">public</span></code>, <code class="docutils literal"><span class="pre">private</span></code>, <code class="docutils literal"><span class="pre">protected</span></code>, <code class="docutils literal"><span class="pre">permits</span></code> キーワードによりインタフェースのメソッドに対するアクセス制御が可能です。 <a class="reference internal" href="#klpg-types-member-access"><span class="std std-ref">構造体、オブジェクト、インタフェースでのアクセス制御</span></a> 参照</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
インタフェース型の変数では構造体を示すことはできません。オブジェクトとインタフェースは根本的に構造体とは異なります。  <a class="reference internal" href="#klpg-objects-versus-structures"><span class="std std-ref">オブジェクト vs 構造体</span></a> 節参照</div>
<div class="section" id="the-object-interface">
<span id="klpg-interfaces-object"></span><h4><code class="code docutils literal"><span class="pre">Object</span></code> インタフェース<a class="headerlink" href="#the-object-interface" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>事前に定義された <code class="code docutils literal"><span class="pre">Object</span></code> と呼ばれる特別なインタフェースが存在します。全てのKLでのオブジェクトで常にサポートします。このインタフェースにより、KL言語の過去のバージョンとの後方互換性と、さらに任意のオブジェクトへの参照を渡すシンプルな方法（C言語での &#8220;void pointer&#8221;のようなもの）を提供します。この <code class="code docutils literal"><span class="pre">Object</span></code> インタフェースではメソッドを提供しません。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">object</span> <span class="nx">MyObj</span> <span class="p">{</span> <span class="c1">// implicitly implements Object</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Object</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">MyObj</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="structure-object-and-interface-access-contols">
<span id="klpg-types-member-access"></span><h4>構造体、オブジェクト、インタフェースでのアクセス制御<a class="headerlink" href="#structure-object-and-interface-access-contols" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.15.0 で追加.</span></p>
</div>
<p>構造体、オブジェクト、インタフェースのメンバやメソッドへのアクセスは、 <code class="docutils literal"><span class="pre">public</span></code>, <code class="docutils literal"><span class="pre">private</span></code> and <code class="docutils literal"><span class="pre">protected</span></code> キーワードにより制御されます。これらのキーワードは C++と同じように動作します。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">public</span></code> が付けられたメンバやメソッドは、ソースコードどこからでもアクセス可能です。アクセス修飾子がつけられない場合のディフォルトの動作でもあります。</li>
<li><code class="docutils literal"><span class="pre">private</span></code> と付けられたメンバやメソッドは、構造体もしくはオブジェクトないのメソッドからのみアクセス可能です。他の場からのアクセスは、コンパイル時エラーとなります。</li>
<li><code class="docutils literal"><span class="pre">protected</span></code> と付けられたメンバやメソッドは、その構造体もしくはオブジェクトおよび、それらを継承した構造体もしくはオブジェクトからのみアクセス可能です。それ以外の場からのアクセスはコンパイル時エラーとなります。</li>
</ul>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Member and Method Access Controls</span>
<span class="cm">*/</span>

<span class="kr">struct</span> <span class="nx">A</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="kr">UInt32</span> <span class="nx">n</span><span class="p">;</span> <span class="c1">// can only be access by methods of A</span>
  <span class="k">protected</span> <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span> <span class="c1">// can only be accessed by methods of A and structures that inherit from A</span>
<span class="p">};</span>

<span class="k">protected</span> <span class="nx">A</span><span class="p">.</span><span class="nx">bar</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kr">struct</span> <span class="nx">B</span> <span class="o">:</span> <span class="nx">A</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="k">public</span> <span class="nx">B</span><span class="p">.</span><span class="nx">foo</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">n</span><span class="p">);</span> <span class="c1">// error since n is private</span>
  <span class="nb">report</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">s</span><span class="p">);</span> <span class="c1">// ok since n is protected</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span> <span class="c1">// ok since A.bar() is procted</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nx">B</span> <span class="nx">b</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">n</span><span class="p">);</span> <span class="c1">// error since n is private</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">s</span><span class="p">);</span> <span class="c1">// error since n is protected</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span> <span class="c1">// ok since B.foo() is public</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span> <span class="c1">// error since A.bar() is protected</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>
<span class="cm">(stdin):30:3: Calling function &#39;report&#39;:</span>
<span class="cm">(stdin):30:10:   Parameter 1:</span>
<span class="cm">(stdin):30:3: error: cannot access private member n</span>
<span class="cm">(stdin):31:3: Calling function &#39;report&#39;:</span>
<span class="cm">(stdin):31:10:   Parameter 1:</span>
<span class="cm">(stdin):31:3: error: cannot access protected member s</span>
<span class="cm">(stdin):33:3: error: cannot access protected function A.bar?()</span>
<span class="cm">(stdin):22:3: Calling function &#39;report&#39;:</span>
<span class="cm">(stdin):22:10:   Parameter 1:</span>
<span class="cm">(stdin):22:3: error: cannot access private member n</span>


<span class="cm">*/</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">permits</span></code> キーワードの使用により、構造体もしくはオブジェクトがこのメカニズムを迂回させることができます。構造体やオブジェクトが、他の構造体もしくはオブジェクトの <code class="docutils literal"><span class="pre">permits</span></code> セクションにリストされていれば、private や protected メンバもしくはメソッドにアクセス可能です。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Bypassing Acess Controls Using ``permits``</span>
<span class="cm">*/</span>

<span class="kr">object</span> <span class="nx">A</span><span class="p">;</span>

<span class="kr">object</span> <span class="nx">Base</span> <span class="k">permits</span> <span class="nx">A</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="kr">UInt32</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">object</span> <span class="nx">A</span> <span class="p">{</span> <span class="nx">Base</span> <span class="nx">b</span><span class="p">;</span> <span class="p">};</span>
<span class="nx">A</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">Base</span><span class="p">();</span> <span class="p">}</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">foo</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">n</span><span class="p">);</span> <span class="c1">// OK since Base permits A</span>
<span class="p">}</span>

<span class="kr">object</span> <span class="nx">B</span><span class="p">;</span>
<span class="kr">object</span> <span class="nx">C</span><span class="p">;</span>

<span class="kr">object</span> <span class="nx">Derived</span> <span class="o">:</span> <span class="nx">Base</span> <span class="k">permits</span> <span class="nx">B</span><span class="p">,</span> <span class="nx">C</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="k">private</span> <span class="nx">Derived</span><span class="p">.</span><span class="nx">bar</span><span class="p">()</span> <span class="p">{}</span>

<span class="kr">object</span> <span class="nx">B</span> <span class="p">{</span> <span class="nx">Derived</span> <span class="nx">d</span><span class="p">;</span> <span class="p">};</span>
<span class="nx">B</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">d</span> <span class="o">=</span> <span class="nx">Derived</span><span class="p">();</span> <span class="p">}</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">baz</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">d</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span>  <span class="c1">// OK since Derived permits B</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nx">A</span> <span class="nx">a</span><span class="p">();</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
  <span class="nx">B</span> <span class="nx">b</span><span class="p">();</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">baz</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">0</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="interfaces-and-inheritance">
<span id="klpg-interfaces-inheritance"></span><h4>インタフェースと継承<a class="headerlink" href="#interfaces-and-inheritance" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.13.0 で追加.</span></p>
</div>
<p><span class="xref std std-ref">base object type</span> を継承し特殊化したオブジェクトでも追加のインタフェースを実装できます。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">object</span> <span class="nx">MyObj</span> <span class="o">:</span> <span class="nx">MyBaseObj</span><span class="p">,</span> <span class="nx">MyInt</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>基底オブジェクトがインタフェースを実装していると、そのオブジェクトを継承し特殊化したオブジェクトからも、基底オブジェクトでそのインタフェースを実装したメソッドをさらに、 <cite>override</cite> した実装が使用可能です。このような場面では、特別なシンタックスが必要となります。同一のインタフェースを実装した基底クラスのメソッドを呼ぶには <a class="reference internal" href="globals.html#klpg-method-interface-inheritance"><span class="std std-ref">インターフェイスメソッドと継承</span></a> 参照してください。</p>
</div>
<div class="section" id="forward-declaration-of-objects-and-interfaces">
<span id="klpg-forward-declarations"></span><h4>オブジェクト、インタフェースの前方宣言<a class="headerlink" href="#forward-declaration-of-objects-and-interfaces" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.12.0 で追加: </span>オブジェクト、インタフェースの前方宣言</p>
</div>
<p>オブジェクトやインタフェースの存在を、実際のメンバの定義抜きに宣言できます。オブジェクトやインタフェースが相互依存するような場合便利です。オブジェクトやインタフェースの前方定義するには、単にメンバやメソッドそしてインタフェースの実装を省略します。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Forward Declaration of Objects and Interfaces</span>
<span class="cm">*/</span>

<span class="c1">// Forward declaration of interface IntTwo</span>
<span class="kr">interface</span> <span class="nx">IntTwo</span><span class="p">;</span>

<span class="kr">interface</span> <span class="nx">IntOne</span> <span class="p">{</span>
  <span class="nx">add</span><span class="o">!</span><span class="p">(</span><span class="nx">IntTwo</span> <span class="nx">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="kr">interface</span> <span class="nx">IntTwo</span> <span class="p">{</span>
  <span class="nx">sub</span><span class="o">!</span><span class="p">(</span><span class="nx">IntOne</span> <span class="nx">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// Forward declaration of object ObjTwo</span>
<span class="kr">object</span> <span class="nx">ObjTwo</span><span class="p">;</span>

<span class="kr">object</span> <span class="nx">ObjOne</span> <span class="o">:</span> <span class="nx">IntOne</span><span class="p">,</span> <span class="nx">IntTwo</span> <span class="p">{</span>
  <span class="kr">UInt32</span> <span class="nx">a</span><span class="p">;</span>
  <span class="nx">ObjTwo</span> <span class="nx">objTwo</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">object</span> <span class="nx">ObjTwo</span> <span class="p">{</span>
  <span class="nx">ObjOne</span> <span class="nx">objOne</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">ObjOne</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">ObjOne</span><span class="p">.</span><span class="nx">add</span><span class="o">!</span><span class="p">(</span><span class="nx">IntTwo</span> <span class="nx">intTwo</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">ObjOne</span> <span class="nx">objOne</span> <span class="o">=</span> <span class="nx">ObjOne</span><span class="p">(</span><span class="nx">intTwo</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">+=</span> <span class="nx">objOne</span><span class="p">.</span><span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">ObjOne</span><span class="p">.</span><span class="nx">sub</span><span class="o">!</span><span class="p">(</span><span class="nx">IntOne</span> <span class="nx">intOne</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">ObjOne</span> <span class="nx">objOne</span> <span class="o">=</span> <span class="nx">ObjOne</span><span class="p">(</span><span class="nx">intOne</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">-=</span> <span class="nx">objOne</span><span class="p">.</span><span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">ObjOne</span> <span class="nx">objOne</span><span class="p">();</span>
  <span class="nx">objOne</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span> <span class="nx">IntOne</span><span class="p">(</span><span class="nx">objOne</span><span class="p">)</span> <span class="p">);</span>
  <span class="nx">objOne</span><span class="p">.</span><span class="nx">sub</span><span class="p">(</span> <span class="nx">IntTwo</span><span class="p">(</span><span class="nx">objOne</span><span class="p">)</span> <span class="p">);</span>
  <span class="nx">objOne</span><span class="p">.</span><span class="nx">objTwo</span> <span class="o">=</span> <span class="nx">ObjTwo</span><span class="p">();</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">objOne</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{a:0,objTwo:{objOne:null}}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="unowned-object-and-interface-references">
<span id="unowned-object-references"></span><h4>未所有オブジェクト、インタフェースへの参照<a class="headerlink" href="#unowned-object-and-interface-references" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>オブジェクト、インタフェースへの参照全てを追跡するランタイムコストはとても高価となりえます。特定の状況、例えばオブジェクトへの参照が常に1つ以上あることが事前に判明している時などは、パフォーマンス上の理由からこの追跡を避けるのが望ましいです。KLでは <code class="samp docutils literal"><span class="pre">Ref&lt;</span><em><span class="pre">ObjectType</span></em><span class="pre">&gt;</span></code>, <code class="samp docutils literal"><span class="pre">Ref&lt;</span><em><span class="pre">InterfaceType</span></em><span class="pre">&gt;</span></code> 構文を使いこの状況を避けることができます。これにより、メモリリークを発生させず、オブジェクトやインタフェースの参照を繰り返し作成する機能を提供します。</p>
<p>未所有参照（Unowned reference）は通常のオブジェクトやインタフェースの参照と全く同様に動作します。ただひとつの違いは、参照を追跡しないことです。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
未所有参照の使用すると、細かいバグにより、クラッシュを非常に簡単に引き起こしてしまいます。使用はあなたの責任です。未所有参照が、他の何かが所有するオブジェクトを正しく確実に参照するようにしましょう。つまり、既に破棄されたオブジェクトを参照する未所有参照をそのまま放置することができてしまい、プログラム中からその参照を使用し何かさせようとするとクラッシュしてしまうのです。</div>
<p>未所有参照の使用例：</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Unowned References</span>
<span class="cm">*/</span>

<span class="kr">object</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="kr">SInt32</span> <span class="nx">intMember</span><span class="p">;</span>
  <span class="kr">String</span> <span class="nx">stringMember</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Foo</span> <span class="nx">foo</span><span class="p">();</span> <span class="c1">// Construct a new specific object</span>
  <span class="nx">foo</span><span class="p">.</span><span class="nx">stringMember</span> <span class="o">=</span> <span class="s2">&quot;me!&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;foo = &quot;</span> <span class="o">+</span> <span class="nx">foo</span><span class="p">);</span>
  <span class="nx">Ref</span><span class="o">&lt;</span><span class="nx">Foo</span><span class="o">&gt;</span> <span class="nx">fooRef</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span> <span class="c1">// fooRef is an unowned reference to foo</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;fooRef = &quot;</span> <span class="o">+</span> <span class="nx">fooRef</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">foo = {intMember:0,stringMember:&quot;me!&quot;}</span>
<span class="cm">fooRef = {intMember:0,stringMember:&quot;me!&quot;}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="the-type-type">
<span id="klpg-types-type"></span><h4><code class="code docutils literal"><span class="pre">Type</span></code> 型<a class="headerlink" href="#the-type-type" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>KLには <code class="code docutils literal"><span class="pre">Type</span></code> 型と呼ばれる特別な型があります。KLでのある値の型を表します。KLでの全ての値は <code class="code docutils literal"><span class="pre">{value}.type()</span></code> メソッドをサポートします。これによりそのオブジェクトの型、 <code class="code docutils literal"><span class="pre">Type</span></code>　型の値を得ます。</p>
<p>変数の <code class="code docutils literal"><span class="pre">Type</span></code> のディフォルト値は、特別な値 <code class="code docutils literal"><span class="pre">None</span></code> です。これはいかに説明する幾つかのメソッドの返り値でもあります。 <code class="code docutils literal"><span class="pre">None</span></code> はどの <code class="code docutils literal"><span class="pre">{value}</span></code> に対する <code class="code docutils literal"><span class="pre">{value}.type()</span></code> とも等しくありません。</p>
<p><code class="code docutils literal"><span class="pre">Type</span></code> 型の値をつかい、いくつかできることがあります。おもに、インタフェースとオブジェクトの実行時型推論に用います。</p>
<ul>
<li>まず値の型を参照し <code class="code docutils literal"><span class="pre">Type</span></code> 型の値を参照し、そして比較に使用することができます：<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Type Comparisons</span>
<span class="cm">*/</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nx">Type</span> <span class="nx">booleanType</span> <span class="o">=</span> <span class="kr">Boolean</span><span class="p">;</span>
  <span class="kr">UInt32</span> <span class="nx">uint32</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;booleanType == uint32.type &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">booleanType</span> <span class="o">==</span> <span class="nx">uint32</span><span class="p">.</span><span class="nx">type</span><span class="p">()));</span>
  <span class="kr">Boolean</span> <span class="nx">boolean</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;booleanType == boolean.type &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">booleanType</span> <span class="o">==</span> <span class="nx">boolean</span><span class="p">.</span><span class="nx">type</span><span class="p">()));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">booleanType == uint32.type false</span>
<span class="cm">booleanType == boolean.type true</span>

<span class="cm">*/</span>
</pre></div>
</div>
</li>
<li><a class="reference internal" href="#klpg-types-interfaces"><span class="std std-ref">インタフェース（Interfaces）</span></a> では <code class="code docutils literal"><span class="pre">{value}.type()</span></code> メソッドで、生成されたオブジェクトが参照する特定オブジェクトの型を返します。これによりオブジェクトの型推論を行います。 <a class="reference internal" href="#klpg-types-interfaces"><span class="std std-ref">インタフェース（Interfaces）</span></a> 節に詳細があります。</li>
<li><code class="code docutils literal"><span class="pre">Type</span></code> 型の値は <code class="code docutils literal"><span class="pre">{value}.parentType()</span></code> メソッドをサポートします。この場合 <code class="code docutils literal"><span class="pre">{value}</span></code> は親を継承したオブジェクトもしくは構造体です。 <code class="code docutils literal"><span class="pre">parentType()</span></code> は親の型を返します。未継承であれば <code class="code docutils literal"><span class="pre">parentType()</span></code> <code class="code docutils literal"><span class="pre">None</span></code> を返します。<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: parentType</span>
<span class="cm">*/</span>

<span class="kr">object</span> <span class="nx">Obj</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
<span class="kr">object</span> <span class="nx">SubObj</span> <span class="o">:</span> <span class="nx">Obj</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Type</span> <span class="nx">type</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;type = &quot;</span> <span class="o">+</span> <span class="nx">type</span> <span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;type.parentType() = &quot;</span> <span class="o">+</span> <span class="nx">type</span><span class="p">.</span><span class="nx">parentType</span><span class="p">());</span>
  <span class="nx">type</span> <span class="o">=</span> <span class="nx">Obj</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;type = &quot;</span> <span class="o">+</span> <span class="nx">type</span> <span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;type.parentType() = &quot;</span> <span class="o">+</span> <span class="nx">type</span><span class="p">.</span><span class="nx">parentType</span><span class="p">());</span>
  <span class="nx">type</span> <span class="o">=</span> <span class="nx">SubObj</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;type = &quot;</span> <span class="o">+</span> <span class="nx">type</span> <span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;type.parentType() = &quot;</span> <span class="o">+</span> <span class="nx">type</span><span class="p">.</span><span class="nx">parentType</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">type = None</span>
<span class="cm">type.parentType() = None</span>
<span class="cm">type = Obj</span>
<span class="cm">type.parentType() = None</span>
<span class="cm">type = SubObj</span>
<span class="cm">type.parentType() = Obj</span>

<span class="cm">*/</span>
</pre></div>
</div>
</li>
<li><code class="code docutils literal"><span class="pre">Type</span></code> 型の値は <code class="code docutils literal"><span class="pre">{value}.isA({interfaceType})</span></code> メソッドをサポートします。 <code class="code docutils literal"><span class="pre">{value}</span></code> がインタフェース <code class="code docutils literal"><span class="pre">{interfaceType}</span></code> をサポートしている場合のみ <code class="code docutils literal"><span class="pre">true</span></code> を返します。<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: isA</span>
<span class="cm">*/</span>

<span class="kr">interface</span> <span class="nx">Int1</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
<span class="kr">interface</span> <span class="nx">Int2</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
<span class="kr">interface</span> <span class="nx">Int3</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
<span class="kr">object</span> <span class="nx">Obj</span> <span class="o">:</span> <span class="nx">Int1</span><span class="p">,</span> <span class="nx">Int2</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
<span class="kr">object</span> <span class="nx">SubObj</span> <span class="o">:</span> <span class="nx">Obj</span><span class="p">,</span> <span class="nx">Int3</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Type</span> <span class="nx">nullType</span><span class="p">;</span>
  <span class="nx">Obj</span> <span class="nx">obj</span><span class="p">();</span>
  <span class="nx">SubObj</span> <span class="nx">subObj</span><span class="p">();</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;nullType.isA(nullType) = &quot;</span> <span class="o">+</span> <span class="nx">nullType</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">nullType</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;nullType.isA(Obj) = &quot;</span> <span class="o">+</span> <span class="nx">nullType</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Obj</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;nullType.isA(SubObj) = &quot;</span> <span class="o">+</span> <span class="nx">nullType</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">SubObj</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;nullType.isA(Int1) = &quot;</span> <span class="o">+</span> <span class="nx">nullType</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int1</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;nullType.isA(Int2) = &quot;</span> <span class="o">+</span> <span class="nx">nullType</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int2</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;nullType.isA(Int3) = &quot;</span> <span class="o">+</span> <span class="nx">nullType</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int3</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj.type().isA(nullType) = &quot;</span> <span class="o">+</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">type</span><span class="p">().</span><span class="nx">isA</span><span class="p">(</span><span class="nx">nullType</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj.type().isA(Obj) = &quot;</span> <span class="o">+</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">type</span><span class="p">().</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Obj</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj.type().isA(SubObj) = &quot;</span> <span class="o">+</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">type</span><span class="p">().</span><span class="nx">isA</span><span class="p">(</span><span class="nx">SubObj</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj.type().isA(Int1) = &quot;</span> <span class="o">+</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">type</span><span class="p">().</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int1</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj.type().isA(Int2) = &quot;</span> <span class="o">+</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">type</span><span class="p">().</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int2</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj.type().isA(Int3) = &quot;</span> <span class="o">+</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">type</span><span class="p">().</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int3</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;subObj.type().isA(nullType) = &quot;</span> <span class="o">+</span> <span class="nx">subObj</span><span class="p">.</span><span class="nx">type</span><span class="p">().</span><span class="nx">isA</span><span class="p">(</span><span class="nx">nullType</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;subObj.type().isA(Obj) = &quot;</span> <span class="o">+</span> <span class="nx">subObj</span><span class="p">.</span><span class="nx">type</span><span class="p">().</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Obj</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;subObj.type().isA(SubObj) = &quot;</span> <span class="o">+</span> <span class="nx">subObj</span><span class="p">.</span><span class="nx">type</span><span class="p">().</span><span class="nx">isA</span><span class="p">(</span><span class="nx">SubObj</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;subObj.type().isA(Int1) = &quot;</span> <span class="o">+</span> <span class="nx">subObj</span><span class="p">.</span><span class="nx">type</span><span class="p">().</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int1</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;subObj.type().isA(Int2) = &quot;</span> <span class="o">+</span> <span class="nx">subObj</span><span class="p">.</span><span class="nx">type</span><span class="p">().</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int2</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;subObj.type().isA(Int3) = &quot;</span> <span class="o">+</span> <span class="nx">subObj</span><span class="p">.</span><span class="nx">type</span><span class="p">().</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int3</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">nullType.isA(nullType) = false</span>
<span class="cm">nullType.isA(Obj) = false</span>
<span class="cm">nullType.isA(SubObj) = false</span>
<span class="cm">nullType.isA(Int1) = false</span>
<span class="cm">nullType.isA(Int2) = false</span>
<span class="cm">nullType.isA(Int3) = false</span>
<span class="cm">obj.type().isA(nullType) = false</span>
<span class="cm">obj.type().isA(Obj) = true</span>
<span class="cm">obj.type().isA(SubObj) = false</span>
<span class="cm">obj.type().isA(Int1) = true</span>
<span class="cm">obj.type().isA(Int2) = true</span>
<span class="cm">obj.type().isA(Int3) = false</span>
<span class="cm">subObj.type().isA(nullType) = false</span>
<span class="cm">subObj.type().isA(Obj) = true</span>
<span class="cm">subObj.type().isA(SubObj) = true</span>
<span class="cm">subObj.type().isA(Int1) = true</span>
<span class="cm">subObj.type().isA(Int2) = true</span>
<span class="cm">subObj.type().isA(Int3) = true</span>

<span class="cm">*/</span>
</pre></div>
</div>
</li>
<li><code class="code docutils literal"><span class="pre">{typeValue}.jsonDesc()</span></code> メソッドにより、型の説明を取得できます。実行時に構造体のメンバのようなものを探しだすことができます。<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Type Description</span>
<span class="cm">*/</span>

<span class="kr">struct</span> <span class="nx">S</span>
<span class="p">{</span>
  <span class="kr">String</span> <span class="nx">string</span><span class="p">;</span>
  <span class="kr">UInt32</span> <span class="nx">uint32</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">S</span><span class="p">.</span><span class="nx">jsonDesc</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{</span>
<span class="cm">  &quot;name&quot; : &quot;S&quot;,</span>
<span class="cm">  &quot;size&quot; : 32,</span>
<span class="cm">  &quot;owningExt&quot; : null,</span>
<span class="cm">  &quot;members&quot; : [</span>
<span class="cm">    {</span>
<span class="cm">      &quot;name&quot; : &quot;string&quot;,</span>
<span class="cm">      &quot;type&quot; : &quot;String&quot;</span>
<span class="cm">      },</span>
<span class="cm">    {</span>
<span class="cm">      &quot;name&quot; : &quot;uint32&quot;,</span>
<span class="cm">      &quot;type&quot; : &quot;UInt32&quot;</span>
<span class="cm">      }</span>
<span class="cm">    ]</span>
<span class="cm">  }</span>

<span class="cm">*/</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="klpg-types-rtval">
<span id="id1"></span><h4>The <code class="code docutils literal"><span class="pre">RTVal</span></code> Type<a class="headerlink" href="#klpg-types-rtval" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The <code class="code docutils literal"><span class="pre">RTVal</span></code> type is once which contains a dynamically-typed value.  A value of type <code class="code docutils literal"><span class="pre">RTVal</span></code> can be created from a value of any other type in KL, except <code class="code docutils literal"><span class="pre">RTVal</span></code> itself.</p>
<p>Using the <code class="code docutils literal"><span class="pre">RTVal</span></code> type allows you to work with values whose types are only known at runtime.  In order to determine the type of the value inside of an <code class="code docutils literal"><span class="pre">RTVal</span></code> value, use its <code class="code docutils literal"><span class="pre">.type()</span></code> method as shown below:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: RTVal Type</span>
<span class="cm">*/</span>

<span class="nx">unwrapValue</span><span class="p">(</span><span class="nx">RTVal</span> <span class="nx">rtVal</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">rtVal</span><span class="p">.</span><span class="nx">type</span><span class="p">()</span> <span class="o">==</span> <span class="kr">UInt32</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">UInt32</span> <span class="nx">val</span><span class="p">(</span><span class="nx">rtVal</span><span class="p">);</span>
    <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;Value is UInt32: &quot;</span> <span class="o">+</span> <span class="nx">val</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">rtVal</span><span class="p">.</span><span class="nx">type</span><span class="p">()</span> <span class="o">==</span> <span class="kr">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">String</span> <span class="nx">val</span><span class="p">(</span><span class="nx">rtVal</span><span class="p">);</span>
    <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;Value is String: &quot;</span> <span class="o">+</span> <span class="nx">val</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
    <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;Unhandled type: &quot;</span> <span class="o">+</span> <span class="nx">rtVal</span><span class="p">.</span><span class="nx">type</span><span class="p">());</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">unwrapValue</span><span class="p">(</span><span class="nx">RTVal</span><span class="p">(</span><span class="mi">4056u32</span><span class="p">));</span>
  <span class="nx">unwrapValue</span><span class="p">(</span><span class="nx">RTVal</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">));</span>
  <span class="nx">unwrapValue</span><span class="p">(</span><span class="nx">RTVal</span><span class="p">(</span><span class="mf">3.141</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>
<span class="cm">Connection refused at server (-111)</span>
<span class="cm">Cannot connect to server (comm: -4)</span>

<span class="cm">Value is UInt32: 4056</span>
<span class="cm">Value is String: foo</span>
<span class="cm">Unhandled type: floating-point constant</span>

<span class="cm">*/</span>
</pre></div>
</div>
<p>Notice above that, unlike most conversions, conversions to and from the <code class="code docutils literal"><span class="pre">RTVal</span></code> type must be explicit; this is because it&#8217;s too easy for bugs to slip by if the conversions are done for you automatically.</p>
</div>
<div class="section" id="the-dfgbinding-type">
<span id="klpg-types-dfgbinding"></span><h4>The <code class="code docutils literal"><span class="pre">DFGBinding</span></code> Type<a class="headerlink" href="#the-dfgbinding-type" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The <code class="code docutils literal"><span class="pre">DFGBinding</span></code> type represents a Canvas (historically called &#8220;the DFG&#8221;) binding.</p>
<p>Currently, the only supported use of the <code class="code docutils literal"><span class="pre">DFGBinding</span></code> type is as follows:</p>
<blockquote>
<div><ul class="simple">
<li>A value of type <code class="code docutils literal"><span class="pre">DFGBinding</span></code> can be constructed from a JSON-formatted binding description (ie. <code class="code docutils literal"><span class="pre">.canvas</span></code> file)</li>
<li>The methods <code class="code docutils literal"><span class="pre">.getArgValue({index})</span></code> and <code class="code docutils literal"><span class="pre">setArgValue({index},</span> <span class="pre">{rtVal})</span></code> are supported</li>
<li>The method <code class="code docutils literal"><span class="pre">.execute()</span></code> is supported.</li>
</ul>
</div></blockquote>
<p>This allows you to load and execute a Canvas graph entirely from KL.  There is also a CAPI entry point for converting DFGBindings to and from RTVals, which will allow you to pass them in from client applications.</p>
<p>This documentation will be expanded in the future to cover complex use cases.</p>
</div>
<div class="section" id="objects-versus-structures">
<span id="klpg-objects-versus-structures"></span><span id="index-15"></span><h4>オブジェクト vs 構造体<a class="headerlink" href="#objects-versus-structures" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>型の合成に、構造体をつかうかオブジェクトを使うかの決定は、実行時の動作や性能に対してだけではなく、プログラムの設計にも影響する極めて重要な選択です。</p>
<p>構造体は、通常、パフォーマンスクリティカルな小さな型に対して最善な選択です。与えられた型の値を一時的に大量に作成する、複雑な式の場合、オブジェクトではなく、構造体を使いましょう。1点致命的なパフォーマンスの観点は、構造体の型をもった変数は、プログラム「スタック」に確保されるということです。つまり、構造体ではメモリ確保、開放のオーバーヘッドが事実上存在しないことを意味します。例えば、ベクタやトランスフォーム型などの数学的な型は、通常構造体です。</p>
<p>オブジェクトは、通常、使用回数が作成／破棄よりも著しく多いような、大規模な型に対して最善の選択です。オブジェクトは、スタックよりも顕著に遅い「ヒープ」に確保されます。さらに、異なる沢山の変数が同じオブジェクトを指すことができ、オブジェクトは同じデータに対し沢山参照する場合、とても良い選択です。データ階層などは通常オブジェクトで表現します。</p>
</div>
</div>
<div class="section" id="arrays">
<span id="index-16"></span><span id="id2"></span><h3>配列<a class="headerlink" href="#arrays" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><em class="dfn">array</em> とは同型（配列の <em class="dfn">element type</em> 呼ばれる)の値を集めた一連のシーケンスです。整数によって索引付け（インデックス）され、メモリ上に連続配置されます。KLでは３種類の配列をサポートします: 可変長配列（variable-size arrays）, 固定長配列（fixed-length arrays）,外部配列（external arrays）です。各配列の詳細については後述します。</p>
<p id="array-properties">３つのうちいずれであっても、KLにおける配列は幾つかの共通の振舞をもちます。</p>
<ul>
<li>配列は <code class="docutils literal"><span class="pre">[..]</span></code> 演算子をつかい索引付されます。JavaScriptやC言語と同一です。配列の索引は 0 基点です。これもJavaScriptやC言語と一緒です:<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Size</span> <span class="n">values</span><span class="p">[];</span>    <span class="o">//</span> <span class="n">Declare</span> <span class="n">a</span> <span class="n">variable</span><span class="o">-</span><span class="n">size</span> <span class="n">array</span>
<span class="n">values</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>  <span class="o">//</span> <span class="n">Push</span> <span class="n">some</span> <span class="n">elements</span> <span class="n">onto</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
<span class="n">values</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">21</span><span class="p">);</span>
<span class="n">values</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">report</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="o">//</span> <span class="n">outputs</span> <span class="s2">&quot;21&quot;</span>
</pre></div>
</div>
</li>
<li>配列のサイズの型は <code class="docutils literal"><span class="pre">Size</span></code> 型です。インデクシング演算子は、 <code class="docutils literal"><span class="pre">Index</span></code> 型（ <code class="docutils literal"><span class="pre">Size</span></code> へのエイリアス）を取ります。</li>
<li>配列の宣言はネスト（入れ子）可能です、さらに他の配列の型ともネストできます。<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Integer</span> <span class="n">b</span><span class="p">[][];</span>  <span class="o">//</span> <span class="n">A</span> <span class="n">variable</span><span class="o">-</span><span class="n">size</span> <span class="n">array</span> <span class="n">of</span> <span class="n">variable</span><span class="o">-</span><span class="n">size</span> <span class="n">arrays</span> <span class="n">of</span> <span class="n">integers</span>
<span class="n">Boolean</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">][];</span> <span class="o">//</span> <span class="n">An</span> <span class="n">array</span> <span class="n">of</span> <span class="mi">2</span> <span class="n">variable</span><span class="o">-</span><span class="n">size</span> <span class="n">arrays</span> <span class="n">of</span> <span class="n">booleans</span>
<span class="n">String</span> <span class="n">c</span><span class="o">&lt;&gt;</span><span class="p">[];</span>   <span class="o">//</span> <span class="n">An</span> <span class="n">external</span> <span class="n">array</span> <span class="n">of</span> <span class="n">variable</span><span class="o">-</span><span class="n">size</span> <span class="n">arrays</span> <span class="n">of</span> <span class="n">strings</span>
</pre></div>
</div>
</li>
<li>配列は参照渡し（ <em class="dfn">passed by reference</em> ）により関数やオペレータに渡ります。すなわち、コピーされません。このことは、100万要素を持つ１つの配列を関数に渡すのも、1つの要素の1つの配列を渡すのも、かかる時間は同じです。</li>
<li>Fabricクライアントを境界チェック（bounds-checks)を有効にし実行した場合、インデクシング演算子を使った配列へのインデクシングは、境界チェックされます。インデックスが配列の終端に達し、超えると、例外が投げられます。</li>
</ul>
<div class="section" id="variable-size-arrays">
<span id="variable-arrays"></span><span id="index-17"></span><h4>可変長配列（Variable-Size Arrays）<a class="headerlink" href="#variable-size-arrays" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><em class="dfn">variable-size array</em> とは、実行時に長さを帰ることのできる配列です。可変長配列の宣言は変数（パラメータもしくは構造体メンバが宣言された）の名前の直後 <code class="docutils literal"><span class="pre">[]</span></code> を付与します。例： <code class="docutils literal"><span class="pre">String</span> <span class="pre">strings[]</span></code></p>
<p>可変長配列は <a class="reference internal" href="#array-properties"><span class="std std-ref">properties of arrays</span></a> を全て持ち、さらに以下の追加の特徴があります：</p>
<ul class="simple">
<li>可変長配列の最大サイズは <span class="math">\(2^{31}-1\)</span></li>
<li>可変長配列は、割り当て共有（ <em class="dfn">share-on-assign</em> ）です。つまりある可変長配列を他の配列へ割り当てると、要素はコピーされるのでは「なく」、要素への「参照をコピー」します。片方の配列へのどのような変更も、もう片方の配列に影響します。これはシャローコピー（対義語はディープコピー）と呼ばれます。配列のディープコピーを行うには、後述する <code class="docutils literal"><span class="pre">clone()</span></code>  メソッドを使用します。</li>
<li>可変長配列は、以下のメソッド、関数をサポートします。<ul>
<li>ディフォルトで可変長配列は空です。コンストラクト時に整数を与えた場合、その配列初期化時初めからは要素を複数持つことになります。</li>
<li><code class="docutils literal"><span class="pre">push(element)</span></code> メソッドにより、末端に要素を追加します。結果配列サイズは１繰り上がります。</li>
<li><code class="docutils literal"><span class="pre">pop()</span></code> メソッドにより、末端要素を取り除き、その要素を返します。結果配列サイズは１小さくなります。空の配列に対し <code class="docutils literal"><span class="pre">pop()</span></code> を呼ぶとエラーが返ります。</li>
<li><code class="docutils literal"><span class="pre">size()</span></code> メソッドによりその可変長配列の要素数を返します。</li>
<li><code class="docutils literal"><span class="pre">resize(newSize)</span></code> メソッドにより配列のサイズを変更します。末端新規要素を、その要素の型のディフォルト値で初期化します。</li>
<li><code class="docutils literal"><span class="pre">reserve(count)</span></code> メソッドでは少なくとも <code class="docutils literal"><span class="pre">count</span></code> 分の要素の場が確保されていることを保証します。事前に要素の最終的な数がわかっているのであれば、<code class="docutils literal"><span class="pre">push(...)</span></code> を何度も呼ぶ前に <code class="docutils literal"><span class="pre">reserve(...)</span></code> すると速度面で優位になります。</li>
<li><code class="docutils literal"><span class="pre">clone()</span></code> メソッドによりその可変長配列のディープコピーを作成します。結果のコピー物は初期状態で他の可変長配列から共有されていません。</li>
<li><code class="docutils literal"><span class="pre">swap(Size</span> <span class="pre">lhsIndex,</span> <span class="pre">Size</span> <span class="pre">rhsIndex)</span></code> メソッドにより、２つのインデクスにより指定された配列の値を入れ替えます。</li>
<li><code class="samp docutils literal"><span class="pre">swap(</span><em><span class="pre">Type</span></em> <span class="pre">lhs[],</span> <em><span class="pre">Type</span></em> <span class="pre">rhs[])</span></code> 関数により、２つの可変長配列の内容を入れ替えます。この操作はデータのコピーを伴わず、一定時間で完了します。</li>
</ul>
</li>
</ul>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Variable-Size Arrays</span>
<span class="cm">*/</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">Integer</span> <span class="nx">a</span><span class="p">[];</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;The array a has size &quot;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot; and value &quot;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">);</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">84</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;The array NOW has size &quot;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot; and value &quot;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">);</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">resize</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;The array NOW has size &quot;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot; and value &quot;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">);</span>
  <span class="kr">String</span> <span class="nx">b</span><span class="p">[](</span><span class="mi">4</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;b is initially &quot;</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">The array a has size 0 and value []</span>
<span class="cm">The array NOW has size 2 and value [42,84]</span>
<span class="cm">The array NOW has size 4 and value [42,84,0,0]</span>
<span class="cm">b is initially [&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;]</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="fixed-size-arrays">
<span id="fixed-arrays"></span><span id="index-18"></span><h4>固定長配列（Fixed-Size Arrays）<a class="headerlink" href="#fixed-size-arrays" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>固定長配列（ <em class="dfn">fixed-size array</em> ）とは、実行時サイズが固定されている配列です。固定長配列は可変長配列よりもパフォーマンス特性に優れ、コンパイル時に配列のサイズが判明している場合、可変長配列のかわりに使用します。固定長配列を宣言するには、変数、パラメータ、構造体メンバ名の後に <code class="samp docutils literal"><span class="pre">[</span><em><span class="pre">size</span></em><span class="pre">]</span></code> を付け足します。例： <code class="docutils literal"><span class="pre">String</span> <span class="pre">strings[4]</span></code></p>
<p>固定長配列は <a class="reference internal" href="#array-properties"><span class="std std-ref">properties of arrays</span></a> をすべて持ち、さらに追加の特徴があります：</p>
<ul>
<li>配列の最大サイズは <span class="math">\(2^31-1\)</span>.<div class="admonition warning">
<p class="first admonition-title">警告</p>
固定長配列はスタック上に確保される（ヒープではありません）ため、巨大な固定長配列を使用するとスタックオーバーフローを引き起こします。固定長配列を使用する際は、適正な大きさである場合に限りましょう。</div>
</li>
<li>固定長配列は、割当時にコピーされます。つまり <em class="dfn">copy-by-value</em> です。</li>
</ul>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Fixed-Size Arrays</span>
<span class="cm">*/</span>

<span class="kd">function</span> <span class="kr">Float32</span> <span class="nx">det</span><span class="p">(</span><span class="kr">Float32</span> <span class="nx">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nx">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nx">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
  <span class="nx">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.5</span><span class="p">;</span>
  <span class="nx">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">9.2</span><span class="p">;</span>
  <span class="nx">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.1</span><span class="p">;</span>
  <span class="nx">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">8.6</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;The determinant of &quot;</span> <span class="o">+</span> <span class="nx">mat</span> <span class="o">+</span> <span class="s2">&quot; is &quot;</span> <span class="o">+</span> <span class="nx">det</span><span class="p">(</span><span class="nx">mat</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">The determinant of [[+3.5,-9.2],[-2.1,+8.6]] is +10.78</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="external-arrays">
<span id="index-19"></span><span id="id3"></span><h4>外部配列（External Arrays）<a class="headerlink" href="#external-arrays" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><em class="dfn">external array</em> とは作成時にサイズが固定され、データ操作時にはそのデータを所有しません。外部配列はおもに、オペレータのパラメータ ― Fabric Engine dependency graph 内でのスライスデータと結合（bind）されたパラメータだけでなく、 Fabric Engine エクステンション内の外部のデータと結合されたパラメータにも使います。また、KL内で使用することも可能です。外部配列の宣言には、変数、パラメータ、構造体メンバの名前の後ろに、 <code class="docutils literal"><span class="pre">&lt;&gt;</span></code> を食わ会えます。例： <code class="docutils literal"><span class="pre">String</span> <span class="pre">strings&lt;&gt;</span></code></p>
<p>外部配列は、 <a class="reference internal" href="#array-properties"><span class="std std-ref">properties of arrays</span></a> をすべて持ちさらに追加の特徴を持ちます：</p>
<ul>
<li>外部配列は、既存の可変長配列からコンストラクト可能です。これは単に、その可変長配列がコンストラクトされた時点の可変長配列に含まれるデータを指します。ただし、この使用方法にはたくさんの穴があります。たとえば可変長配列をリサイズした場合などです。これは主にテストのため使用してください。<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">va</span><span class="p">[];</span>
<span class="n">va</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">);</span>
<span class="n">String</span> <span class="n">ea</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
<span class="n">report</span><span class="p">(</span><span class="n">ea</span><span class="p">);</span> <span class="o">//</span> <span class="n">prints</span> <span class="p">[</span><span class="s2">&quot;hello&quot;</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li>外部配列は空コンストラクタ（empty constructor）をサポートします。（空の外部配列がコンストラクトされます）<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Size</span> <span class="n">ea</span><span class="o">&lt;&gt;</span><span class="p">;</span>
<span class="n">report</span><span class="p">(</span><span class="n">ea</span><span class="p">);</span> <span class="o">//</span> <span class="n">prints</span> <span class="p">[]</span>
</pre></div>
</div>
</li>
<li>外部配列は、コピーコンストラクタ、代入演算子両方サポートし、他方の配列と同じデータを参照する外部配列を作成します。<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">va</span><span class="p">[];</span>
<span class="n">va</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">);</span>
<span class="n">String</span> <span class="n">ea1</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
<span class="n">String</span> <span class="n">ea2</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">ea1</span><span class="p">);</span>
<span class="n">report</span><span class="p">(</span><span class="n">ea2</span><span class="p">);</span> <span class="o">//</span> <span class="n">prints</span> <span class="p">[</span><span class="s2">&quot;hello&quot;</span><span class="p">]</span>
<span class="n">String</span> <span class="n">ea3</span><span class="o">&lt;&gt;</span><span class="p">;</span>
<span class="n">ea3</span> <span class="o">=</span> <span class="n">ea2</span><span class="p">;</span>
<span class="n">report</span><span class="p">(</span><span class="n">ea3</span><span class="p">);</span> <span class="o">//</span> <span class="n">prints</span> <span class="p">[</span><span class="s2">&quot;hello&quot;</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li>外部配列は、 <code class="docutils literal"><span class="pre">size()</span></code> メソッドをサポートし、外部配列の要素数を返します。</li>
<li>外部配列は、 <code class="docutils literal"><span class="pre">data</span></code> ポインタだけでなく <code class="docutils literal"><span class="pre">size</span></code> を指定し初期化できます。これにより任意のメモリを配列として割り当てできます。とくにC++からKLへと（もしくはその逆）データを渡す際に便利です。このコンストラクタを使い、どんなメモリも配列として再解釈することができます:<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Float32</span> <span class="n">floats</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="k">for</span><span class="p">(</span><span class="n">Size</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">floats</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="n">floats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Float32</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

<span class="n">Vec3</span> <span class="n">vectors</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">floats</span><span class="o">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">floats</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">report</span><span class="p">(</span><span class="n">vectors</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li>可変長配列とは逆に、外部配列は参照カウントされないオブジェクトです。つまり受け渡し低価でありますが、メモリのライフタイムを管理することはできなくなります。（次項参照）</li>
<li>外部配列は、それが操作されるデータの生存期間を管理できません。可変長配列は破棄時にメモリが開放されますが、外部配列は単に他のオブジェクトが所持するメモリをマップしたものに過ぎません。外部配列は真のデータ所持者より長生きしてはいけません、さもなくば不要なゴミデータにマップされてしまいます。<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">ea</span><span class="o">&lt;&gt;</span><span class="p">;</span>
<span class="p">{</span>
  <span class="n">String</span> <span class="n">va</span><span class="p">[];</span>
  <span class="k">for</span><span class="p">(</span><span class="n">Integer</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">2023</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">va</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s2">&quot;hello:&quot;</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">String</span> <span class="n">ea1</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
  <span class="n">ea</span> <span class="o">=</span> <span class="n">ea1</span><span class="p">;</span>
  <span class="o">//</span> <span class="n">At</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">this</span> <span class="n">scope</span><span class="p">,</span> <span class="n">the</span> <span class="n">variable</span> <span class="n">array</span> <span class="ow">is</span> <span class="n">freed</span><span class="p">,</span> <span class="n">along</span> <span class="k">with</span> <span class="n">its</span> <span class="n">data</span><span class="o">.</span>
<span class="p">}</span>
<span class="o">//</span> <span class="n">The</span> <span class="n">memory</span> <span class="n">of</span> <span class="n">the</span> <span class="n">variable</span> <span class="n">array</span> <span class="ow">is</span> <span class="n">now</span> <span class="n">garbage</span> <span class="n">because</span> <span class="n">it</span> <span class="n">has</span> <span class="n">been</span> <span class="n">destroyed</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Printing</span> <span class="n">the</span> <span class="n">data</span> <span class="n">will</span> <span class="k">return</span> <span class="n">garbage</span> <span class="n">data</span> <span class="ow">or</span> <span class="n">crash</span> <span class="n">KL</span><span class="o">.</span>
<span class="o">//</span> <span class="n">External</span> <span class="n">arrays</span> <span class="n">must</span> <span class="n">be</span> <span class="n">used</span> <span class="k">with</span> <span class="n">care</span> <span class="n">to</span> <span class="n">avoid</span> <span class="n">mapping</span> <span class="n">to</span> <span class="n">garbage</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">way</span><span class="o">.</span>
<span class="n">report</span><span class="p">(</span><span class="n">ea</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
<p>外部配列の使用例:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: External Arrays</span>
<span class="cm">*/</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">String</span> <span class="nx">va</span><span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">Size</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span>
    <span class="nx">va</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&quot;string &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>

  <span class="kr">String</span> <span class="nx">strings</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="nx">va</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">Size</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span>
    <span class="nx">strings</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot; appended&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;strings = &quot;</span> <span class="o">+</span> <span class="nx">strings</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;va = &quot;</span> <span class="o">+</span> <span class="nx">va</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">strings = [&quot;string 1 appended&quot;,&quot;string 2 appended&quot;,&quot;string 3 appended&quot;,&quot;string 4 appended&quot;,&quot;string 5 appended&quot;,&quot;string 6 appended&quot;,&quot;string 7 appended&quot;,&quot;string 8 appended&quot;]</span>
<span class="cm">va = [&quot;string 1 appended&quot;,&quot;string 2 appended&quot;,&quot;string 3 appended&quot;,&quot;string 4 appended&quot;,&quot;string 5 appended&quot;,&quot;string 6 appended&quot;,&quot;string 7 appended&quot;,&quot;string 8 appended&quot;]</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="dictionaries">
<span id="index-20"></span><span id="id4"></span><h3>辞書（Dictionaries）<a class="headerlink" href="#dictionaries" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>KLは、キーと値のペア、辞書（ <em class="dfn">dictionaries</em> ）をサポートします。辞書のキーにはKL基本型（ <code class="code docutils literal"><span class="pre">Boolean</span></code>, <code class="docutils literal"><span class="pre">String</span></code>, 整数型、浮動小数点型）だけでなく、 <code class="samp docutils literal"><span class="pre">.hash</span></code> メソッドが定義された独自定義した型 (see <a class="reference internal" href="#klpg-dictionaries-custom-key-types"><span class="std std-ref">キーにカスタム型を使用した辞書</span></a>)を、そして辞書の値にはどのような型も取れます。辞書の宣言には、変数（パラメータ、メンバ名）に <code class="samp docutils literal"><span class="pre">[</span><em><span class="pre">KeyType</span></em><span class="pre">]</span></code> を付けます。例:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">String</span> <span class="nx">scalarToString</span><span class="p">[</span><span class="kr">Float32</span><span class="p">];</span>     <span class="c1">// A Float32-to-String dictionary</span>
<span class="kr">Boolean</span> <span class="nx">integerToBoolean</span><span class="p">[</span><span class="kr">Integer</span><span class="p">];</span>  <span class="c1">// An Integer-to-Boolean dictionary</span>
</pre></div>
</div>
<p>KL での辞書には以下の特徴があります:</p>
<ul>
<li><em class="dfn">share-on-assign</em> です。他の辞書に割当てる際、内容そのものをコピーするのではなく内容への参照をコピーします。つまり、一方の辞書への変更が、他方にも作用します。これはシャローコピーと呼ばれます。（対義語はディープコピー）辞書のディープコピーを得るには、 <code class="docutils literal"><span class="pre">clone()</span></code> メソッドを用います。以下に説明します。</li>
<li>ネスト可能です。配列型をネストさせることができます。例:<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">Integer</span> <span class="nx">b</span><span class="p">[</span><span class="kr">String</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// An String-to-Fixed-Length-Integer-Array dictionary</span>
<span class="kr">Boolean</span> <span class="nx">a</span><span class="p">[][</span><span class="kr">Integer</span><span class="p">];</span> <span class="c1">// A variable array of Integer-to-Boolean dictionaries</span>
</pre></div>
</div>
</li>
<li>最大要素数は  <span class="math">\(2^{32}-1\)</span></li>
<li><code class="samp docutils literal"><span class="pre">has(</span><em><span class="pre">key</span></em><span class="pre">)</span></code> メソッドにより、与えられた key 要素が存在するかどうかを <code class="code docutils literal"><span class="pre">Boolean</span></code> の値で返します。</li>
<li><code class="samp docutils literal"><span class="pre">get(</span><em><span class="pre">key</span></em><span class="pre">)</span></code> メソッドにより、与えられた key に対応する値を返します。対応する値が存在しない場合例外を投げます。</li>
<li><code class="samp docutils literal"><span class="pre">set(</span><em><span class="pre">key</span></em><span class="pre">,</span> <em><span class="pre">value</span></em><span class="pre">)</span></code> メソッドにより、 key に対応した 値 を設定します。キーに対応する値が既に存在する場合、値を上書きします。</li>
<li><code class="samp docutils literal"><span class="pre">[</span><em><span class="pre">key</span></em><span class="pre">]</span></code> インデクサ演算子によるインデクシングに対応しています。代入ターゲットとしての使用、あるいは関数の ioパラメータとしての使用は（例： <code class="samp docutils literal"><em><span class="pre">dict</span></em><span class="pre">[</span><em><span class="pre">key</span></em><span class="pre">]</span> <span class="pre">=</span> <em><span class="pre">value</span></em></code> ）、 <code class="samp docutils literal"><span class="pre">set(</span><em><span class="pre">key</span></em><span class="pre">,</span> <em><span class="pre">value</span></em><span class="pre">)</span></code> メソッドと同等です。read-onlyな式としての使用は、（例： <code class="samp docutils literal"><em><span class="pre">value</span></em> <span class="pre">=</span> <em><span class="pre">dict</span></em><span class="pre">[</span><em><span class="pre">key</span></em><span class="pre">]</span></code>)は、 <code class="samp docutils literal"><span class="pre">get(</span><em><span class="pre">key</span></em><span class="pre">)</span></code> と同等です。</li>
<li><code class="samp docutils literal"><span class="pre">get(</span><em><span class="pre">key</span></em><span class="pre">,</span> <em><span class="pre">defaultValue</span></em><span class="pre">)</span></code> メソッドにより、key に対応する値が存在すればその値を、そうでなければ  <code class="samp docutils literal"><em><span class="pre">defaultValue</span></em><span class="pre">`</span></code> を返します。</li>
<li><code class="samp docutils literal"><span class="pre">delete(</span><em><span class="pre">key</span></em><span class="pre">)</span></code> メソッドにより、与えられた key に対する値を削除します。与えられたkeyが存在しない場合は、なにも置きません。</li>
<li><code class="docutils literal"><span class="pre">clone()</span></code> メソッドにより、辞書のディープコピーを作成します。作成されたコピーは初期状態で他の何物の辞書からも共有されません。</li>
<li><code class="docutils literal"><span class="pre">clear()</span></code> メソッドにより、全てのキーと値を取り除きます。</li>
<li>JavaScriptのように <code class="docutils literal"><span class="pre">in</span></code> により、繰り返しが可能です。<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">String</span> <span class="nx">dict</span><span class="p">[</span><span class="kr">String</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="nx">k</span> <span class="k">in</span> <span class="nx">dict</span><span class="p">)</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;dict[&quot;</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">+</span> <span class="s2">&quot;] = &quot;</span> <span class="o">+</span> <span class="nx">dict</span><span class="p">[</span><span class="nx">k</span><span class="p">]);</span>
</pre></div>
</div>
<p>パフォーマンス向上のため、キーと値の両方を <code class="docutils literal"><span class="pre">in</span></code> の反復中利用可能とななります。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">String</span> <span class="nx">dict</span><span class="p">[</span><span class="kr">String</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="k">in</span> <span class="nx">dict</span><span class="p">)</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;dict[&quot;</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">+</span> <span class="s2">&quot;] = &quot;</span> <span class="o">+</span> <span class="nx">v</span><span class="p">);</span>
</pre></div>
</div>
<p>辞書の反復処理中、値はその辞書自体が割り当て済であれば、代入可能です。一方キーは反復処理中での代入は不可能です。</p>
</li>
<li>挿入順（ソート順ではなく）が、反復処理の順序となります。JavaScriptのオブジェクトと同じです。<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">String</span> <span class="nx">numbers</span><span class="p">[</span><span class="kr">Integer</span><span class="p">];</span>
  <span class="nx">numbers</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;three&quot;</span><span class="p">;</span>
  <span class="nx">numbers</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;two&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">numbers</span><span class="p">);</span>
  <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;one&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">numbers</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{3:&quot;three&quot;,2:&quot;two&quot;}</span>
<span class="cm">{3:&quot;three&quot;,2:&quot;two&quot;,1:&quot;one&quot;}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</li>
</ul>
<p>辞書の利用例：</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Dictionaries</span>
<span class="cm">*/</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">a</span><span class="p">[</span><span class="kr">String</span><span class="p">];</span>
  <span class="nx">a</span><span class="p">[</span><span class="s1">&#39;pi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
  <span class="nx">a</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.71</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;a is:&quot;</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="k">in</span> <span class="nx">a</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;a[&#39;&quot;</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">+</span> <span class="s2">&quot;&#39;] = &quot;</span> <span class="o">+</span> <span class="nx">v</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">delete</span><span class="p">(</span><span class="s1">&#39;pi&#39;</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;a is now:&quot;</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="k">in</span> <span class="nx">a</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;a[&#39;&quot;</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">+</span> <span class="s2">&quot;&#39;] = &quot;</span> <span class="o">+</span> <span class="nx">v</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">a is:</span>
<span class="cm">a[&#39;pi&#39;] = +3.14</span>
<span class="cm">a[&#39;e&#39;] = +2.71</span>
<span class="cm">a is now:</span>
<span class="cm">a[&#39;e&#39;] = +2.71</span>

<span class="cm">*/</span>
</pre></div>
</div>
<div class="section" id="dictionaries-using-custom-key-types">
<span id="klpg-dictionaries-custom-key-types"></span><span id="index-21"></span><h4>キーにカスタム型を使用した辞書<a class="headerlink" href="#dictionaries-using-custom-key-types" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>独自定義した構造体 <code class="samp docutils literal"><span class="pre">struct</span></code> を辞書のキーの型として使用できます。型に <code class="samp docutils literal"><span class="pre">.hash</span></code> メソッド、 <code class="samp docutils literal"><span class="pre">==</span></code> 演算子 を実装します。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Dictionary with Custom Key Type</span>
<span class="cm">*/</span>

<span class="kr">struct</span> <span class="nx">S</span> <span class="p">{</span>
  <span class="kr">UInt32</span> <span class="nx">n</span><span class="p">;</span>
  <span class="kr">Float32</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">};</span>


<span class="kd">function</span> <span class="nx">S</span><span class="p">(</span><span class="kr">UInt32</span> <span class="nx">n</span><span class="p">,</span> <span class="kr">Float32</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="kr">Boolean</span> <span class="o">==</span><span class="p">(</span><span class="nx">S</span> <span class="nx">lhs</span><span class="p">,</span> <span class="nx">S</span> <span class="nx">rhs</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">lhs</span><span class="p">.</span><span class="nx">n</span> <span class="o">==</span> <span class="nx">rhs</span><span class="p">.</span><span class="nx">n</span> <span class="o">&amp;&amp;</span> <span class="nx">lhs</span><span class="p">.</span><span class="nx">x</span> <span class="o">==</span> <span class="nx">rhs</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="kr">UInt32</span> <span class="nx">S</span><span class="p">.</span><span class="nx">hash</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">n</span><span class="p">.</span><span class="nx">hash</span><span class="p">()</span> <span class="o">^</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">hash</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">String</span> <span class="nx">d</span><span class="p">[</span><span class="nx">S</span><span class="p">];</span>
  <span class="nx">d</span><span class="p">[</span><span class="nx">S</span><span class="p">(</span><span class="mi">56</span><span class="p">,</span><span class="mf">2.4</span><span class="p">)]</span> <span class="o">=</span> <span class="s2">&quot;one&quot;</span><span class="p">;</span>
  <span class="nx">d</span><span class="p">[</span><span class="nx">S</span><span class="p">(</span><span class="mi">78</span><span class="p">,</span><span class="o">-</span><span class="mf">1.2</span><span class="p">)]</span> <span class="o">=</span> <span class="s2">&quot;two&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{{n:56,x:+2.4}:&quot;one&quot;,{n:78,x:-1.2}:&quot;two&quot;}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="map-reduce-types">
<span id="index-22"></span><h3>Map-Reduce 型<a class="headerlink" href="#map-reduce-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Fabric の map-reduce フレームワークには、排他的に使用可能な２つの派生型があります:</p>
<ul class="simple">
<li><code class="samp docutils literal"><span class="pre">ValueProducer&lt;</span><em><span class="pre">Type</span></em><span class="pre">&gt;</span></code></li>
<li><code class="samp docutils literal"><span class="pre">ArrayProducer&lt;</span><em><span class="pre">Type</span></em><span class="pre">&gt;</span></code></li>
</ul>
<p><a class="reference internal" href="map-reduce.html#map-reduce"><span class="std std-ref">Map-Reduce</span></a> の詳細を参照してください。</p>
</div>
</div>
<div class="section" id="implicit-type-casting-rules-in-kl">
<span id="index-23"></span><h2>KL での型の暗黙的キャスト<a class="headerlink" href="#implicit-type-casting-rules-in-kl" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>KLにおいて、引数の型がその関数（もしくはメソッド）のどの多態なパラメータとも一致させずに、関数やメソッドを呼んぶと、KLは、最善の型を探すため暗黙のキャストを行います。以下に従い最善なものが選択されます:</p>
<ul class="simple">
<li>引数の数は、パラメータの数と完全に一致させます。仮にミスマッチがあると、多態バージョンは無視されます。例を挙げると、関数呼び出し <code class="code docutils literal"><span class="pre">foo(14,</span> <span class="pre">23)</span></code> がなされ、対して <code class="code docutils literal"><span class="pre">foo(Integer)</span></code> が利用可能な場合、関数で処理可能なパラメータは１つなのに、与えられた引数が２つなため適切に処理されません。</li>
<li>引数（複数）の数と、パラメータの数が合っている場合、呼び出し『コスト』はそれぞれの引数の最大のコストと等しくなります。それぞれの引数のコストは以下:<ul>
<li>型が一致していればコストは 0</li>
<li>継承関係であればコストは 極小 （例：受付パラメータの型が <code class="code docutils literal"><span class="pre">A</span></code>, 呼び出し引数の型が <code class="code docutils literal"><span class="pre">B</span></code>, <code class="code docutils literal"><span class="pre">B</span></code> が <code class="code docutils literal"><span class="pre">A</span></code> を引き継ぎ）</li>
<li>以上に当てはまらない場合、コストは型のよりけりです。一般的に期待される通りではあります。例えば、小さい整数型からより大きい整数型（ <code class="code docutils literal"><span class="pre">UInt16</span></code> to <code class="code docutils literal"><span class="pre">UInt32</span></code> など)はとても低コストです。一方高価な操作（文字列への変換, 精度を失うような数値変換)は高コストになります。</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="type-aliases">
<h2>型の別名(Type Aliases)<a class="headerlink" href="#type-aliases" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>エイリアス（ <code class="docutils literal"><span class="pre">alias</span></code> ）文により、ある型に別名を振りコードの可読性を向上させます。変数宣言の文法と同一の文法です:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">alias</span> <span class="n">Integer</span> <span class="n">Int32</span><span class="p">;</span>        <span class="o">//</span> <span class="n">Int32</span> <span class="ow">is</span> <span class="n">now</span> <span class="n">an</span> <span class="n">alias</span> <span class="k">for</span> <span class="n">Integer</span>
<span class="n">alias</span> <span class="n">Float32</span> <span class="nb">float</span><span class="p">;</span>        <span class="o">//</span> <span class="nb">float</span> <span class="ow">is</span> <span class="n">now</span> <span class="n">an</span> <span class="n">alias</span> <span class="k">for</span> <span class="n">Float32</span>
<span class="n">alias</span> <span class="n">Float32</span> <span class="n">Mat22</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>  <span class="o">//</span> <span class="n">Mat22</span> <span class="ow">is</span> <span class="n">now</span> <span class="n">an</span> <span class="n">alias</span> <span class="k">for</span> <span class="n">Float32</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">ie</span><span class="o">.</span> <span class="n">a</span> <span class="n">size</span><span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="n">array</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">size</span><span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="n">arrays</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">Float32</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">alias</span></code> 文はKLプログラム中、グローバルスコープに置きます。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Type Aliases</span>
<span class="cm">*/</span>

<span class="nx">alias</span> <span class="kr">Float32</span> <span class="nx">Mat22</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Mat22</span> <span class="nx">mat22</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">mat22</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">[[+0.0,+0.0],[+0.0,+0.0]]</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="the-data-type-and-the-data-and-datasize-methods">
<span id="index-24"></span><h2><code class="docutils literal"><span class="pre">Data</span></code> 型 <code class="docutils literal"><span class="pre">data</span></code>, <code class="docutils literal"><span class="pre">dataSize</span></code> メソッド<a class="headerlink" href="#the-data-type-and-the-data-and-datasize-methods" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>OpenGLなどの外部ライブラリとの接続を行う際、値の基礎となるデータへ直接のアクセスを必要とすることがあります。例えば、データへのポインタを受け付けるライブラリです。KL自体にはポインタの概念がありません。ですが、KLには <code class="docutils literal"><span class="pre">Data</span></code> 型 ―この型の値は外部ライブラリ呼び出しの際に渡されるデータへのポインタを示す― のコンセプトがあります。</p>
<p>KLでの多くの値は、組み込みメソッド <code class="docutils literal"><span class="pre">data</span></code> を持ち、 <code class="docutils literal"><span class="pre">Data</span></code> 型の値を返します。さらに組み込みメソッド  <code class="docutils literal"><span class="pre">dataSize</span></code> を持ち、 <code class="docutils literal"><span class="pre">Size</span></code> 型の値を返します。 <code class="docutils literal"><span class="pre">data</span></code> メソッドは値の基であるデータへのポインタを返し、  <code class="docutils literal"><span class="pre">dataSize</span></code> はメモリに占める値のバイト数を返します。ただひとつ、辞書（およびその派生型）はこの  <code class="docutils literal"><span class="pre">data</span></code> and <code class="docutils literal"><span class="pre">dataSize</span></code> メソッドを持ちません。なぜなならこの型の値の要素（もしくはメンバ）は、メモリ上に連続して配置されるわけではないからです。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Valid and Invalid Use of .data() and .dataSize()</span>
<span class="cm">*/</span>

<span class="kr">Integer</span> <span class="nx">integers</span><span class="p">[];</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">integers</span><span class="p">.</span><span class="nx">data</span><span class="p">());</span>  <span class="c1">// OK: integers are contiguous in memory</span>
<span class="kr">String</span> <span class="nx">strings</span><span class="p">[];</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">data</span><span class="p">());</span>   <span class="c1">// ERROR: string data is not contiguous in memory</span>
</pre></div>
</div>
<p>CやC++言語のポインターと異なり、 <code class="docutils literal"><span class="pre">data</span></code> メソッドの返す値はインスペクト不可、いかなる式での使用も不可です。この値は、 <code class="code docutils literal"><span class="pre">Boolean</span></code> へのキャストだけが行えます。 <code class="docutils literal"><span class="pre">Data</span></code> の値が 0以上の値を示していれば <code class="code docutils literal"><span class="pre">true</span></code> になります。しかし <code class="docutils literal"><span class="pre">Data</span></code> の値はそのまま直接外部ライブラリの関数 ―Fabric自身もしくはFabricエクステンションでも、メモリ上のデータへのポインタを使用する箇所でこへでも与えることができます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">For values of type <code class="docutils literal"><span class="pre">String</span></code>, the value returned by <code class="docutils literal"><span class="pre">dataSize</span></code> includes a null terminator that is automatically appended to the string by Fabric; this is so that the string data can be directly used in C library calls as a regular C string.  If you want to pass the number of characters in the string, pass <code class="docutils literal"><span class="pre">string.length()</span></code> instead.</p>
</div>
<p><code class="docutils literal"><span class="pre">Data</span></code> の値 <code class="docutils literal"><span class="pre">data</span></code>, <code class="docutils literal"><span class="pre">dataSize</span></code> メソッドの使用例:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: .data() and .dataSize()</span>
<span class="cm">*/</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;s = &#39;&quot;</span> <span class="o">+</span> <span class="nx">s</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;s.data() = &quot;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">data</span><span class="p">());</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;Boolean(s.data()) = &quot;</span> <span class="o">+</span> <span class="kr">Boolean</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">data</span><span class="p">()));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;s.dataSize() = &quot;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">dataSize</span><span class="p">());</span>
  <span class="nx">s</span> <span class="o">=</span> <span class="s2">&quot;Hello&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;s = &#39;&quot;</span> <span class="o">+</span> <span class="nx">s</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;s.data() = &quot;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">data</span><span class="p">());</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;Boolean(s.data()) = &quot;</span> <span class="o">+</span> <span class="kr">Boolean</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">data</span><span class="p">()));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;s.dataSize() = &quot;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">dataSize</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">s = &#39;&#39;</span>
<span class="cm">s.data() = &lt;Opaque&gt;</span>
<span class="cm">Boolean(s.data()) = true</span>
<span class="cm">s.dataSize() = 1</span>
<span class="cm">s = &#39;Hello&#39;</span>
<span class="cm">s.data() = &lt;Opaque&gt;</span>
<span class="cm">Boolean(s.data()) = true</span>
<span class="cm">s.dataSize() = 6</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/FE_logo_211_37.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">KLの型システム</a><ul>
<li><a class="reference internal" href="#base-types">基本型（Base Types）</a><ul>
<li><a class="reference internal" href="#the-boolean-type">論理型（ <code class="code docutils literal"><span class="pre">Boolean</span></code> Type）</a></li>
<li><a class="reference internal" href="#integer-types">整数型（Integer Types）</a><ul>
<li><a class="reference internal" href="#integer-atomic-methods">整数型のアトミックメソッド</a></li>
</ul>
</li>
<li><a class="reference internal" href="#floating-point-types">浮動小数点数型（Floating-Point Types）</a></li>
<li><a class="reference internal" href="#the-string-type">文字列型（<code class="docutils literal"><span class="pre">String</span></code> Type）</a></li>
<li><a class="reference internal" href="#the-rtval-type">The <code class="docutils literal"><span class="pre">RTVal</span></code> Type</a></li>
</ul>
</li>
<li><a class="reference internal" href="#derived-types">派生型（Derived Types）</a><ul>
<li><a class="reference internal" href="#structures">構造体（Structures）</a><ul>
<li><a class="reference internal" href="#structure-member-alignment">構造体メンバのアライメント</a></li>
<li><a class="reference internal" href="#structure-inheritance">構造体の継承</a></li>
</ul>
</li>
<li><a class="reference internal" href="#objects">オブジェクト（Objects）</a><ul>
<li><a class="reference internal" href="#the-object-clone-method">Object <code class="docutils literal"><span class="pre">clone()</span></code> メソッド</a></li>
<li><a class="reference internal" href="#the-object-refcount-method">The Object <code class="docutils literal"><span class="pre">refCount()</span></code> Method</a></li>
<li><a class="reference internal" href="#object-inheritance">オブジェクトの継承</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interfaces">インタフェース（Interfaces）</a><ul>
<li><a class="reference internal" href="#the-object-interface"><code class="code docutils literal"><span class="pre">Object</span></code> インタフェース</a></li>
<li><a class="reference internal" href="#structure-object-and-interface-access-contols">構造体、オブジェクト、インタフェースでのアクセス制御</a></li>
<li><a class="reference internal" href="#interfaces-and-inheritance">インタフェースと継承</a></li>
<li><a class="reference internal" href="#forward-declaration-of-objects-and-interfaces">オブジェクト、インタフェースの前方宣言</a></li>
<li><a class="reference internal" href="#unowned-object-and-interface-references">未所有オブジェクト、インタフェースへの参照</a></li>
<li><a class="reference internal" href="#the-type-type"><code class="code docutils literal"><span class="pre">Type</span></code> 型</a></li>
<li><a class="reference internal" href="#klpg-types-rtval">The <code class="code docutils literal"><span class="pre">RTVal</span></code> Type</a></li>
<li><a class="reference internal" href="#the-dfgbinding-type">The <code class="code docutils literal"><span class="pre">DFGBinding</span></code> Type</a></li>
<li><a class="reference internal" href="#objects-versus-structures">オブジェクト vs 構造体</a></li>
</ul>
</li>
<li><a class="reference internal" href="#arrays">配列</a><ul>
<li><a class="reference internal" href="#variable-size-arrays">可変長配列（Variable-Size Arrays）</a></li>
<li><a class="reference internal" href="#fixed-size-arrays">固定長配列（Fixed-Size Arrays）</a></li>
<li><a class="reference internal" href="#external-arrays">外部配列（External Arrays）</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dictionaries">辞書（Dictionaries）</a><ul>
<li><a class="reference internal" href="#dictionaries-using-custom-key-types">キーにカスタム型を使用した辞書</a></li>
</ul>
</li>
<li><a class="reference internal" href="#map-reduce-types">Map-Reduce 型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implicit-type-casting-rules-in-kl">KL での型の暗黙的キャスト</a></li>
<li><a class="reference internal" href="#type-aliases">型の別名(Type Aliases)</a></li>
<li><a class="reference internal" href="#the-data-type-and-the-data-and-datasize-methods"><code class="docutils literal"><span class="pre">Data</span></code> 型 <code class="docutils literal"><span class="pre">data</span></code>, <code class="docutils literal"><span class="pre">dataSize</span></code> メソッド</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="syntax.html"
                        title="前の章へ">KLの文法</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="globals.html"
                        title="次の章へ">関数と他のグローバルな宣言</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/KLProgrammingGuide/types.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    <li><a href="http://docs.fabric-engine.com/FabricEngine/latest/HTML/KLProgrammingGuide/types.html"
              rel="nofollow">原文公式ページへ移動 (goto official page)</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="globals.html" title="関数と他のグローバルな宣言"
             >次へ</a> |</li>
        <li class="right" >
          <a href="syntax.html" title="KLの文法"
             >前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Fabric Engine 2.4.0 Unofficial Documentation (ja)</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >KL プログラミングガイド</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2010-2017 Fabric Software Inc.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1 で生成しました。
    </div>
  </body>
</html>