<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>PolygonMesh’s structure &#8212; Fabric Engine 2.4.0 Unofficial Documentation (ja)</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.4.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="検索" href="../../search.html" />
    <link rel="next" title="ジオメトリを用いた空間分析群(Spatial queries)の使用" href="spatialqueriesusage.html" />
    <link rel="prev" title="Geometry エクステンション" href="index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="spatialqueriesusage.html" title="ジオメトリを用いた空間分析群(Spatial queries)の使用"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="index.html" title="Geometry エクステンション"
             accesskey="P">前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Fabric Engine 2.4.0 Unofficial Documentation (ja)</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >KL エクステンションガイド</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">Geometry エクステンション</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="polygonmesh-s-structure">
<span id="polygonmeshstructure"></span><h1>PolygonMesh&#8217;s structure<a class="headerlink" href="#polygonmesh-s-structure" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="introduction">
<h2>概要<a class="headerlink" href="#introduction" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="PolygonMesh.html#polygonmesh"><span class="std std-ref">PolygonMesh</span></a> はポリゴン群で作られた幾何学表面(geometric surface)を表し、それぞれのポリゴンは3つ以上の3Dポイント(以下&#8221;頂点&#8221;)の閉じたループで定義されます。1つの頂点は複数のポリゴンを結びつけることができます。 <a class="reference internal" href="PolygonMesh.html#polygonmesh"><span class="std std-ref">PolygonMesh</span></a> の基本定義はとても標準的ですが、 <a class="reference internal" href="PolygonMesh.html#polygonmesh"><span class="std std-ref">PolygonMesh</span></a> 構造はメモリ消費とパフォーマンスのバランスを取ることを可能にするという特性を含んでいます。</p>
<ul class="simple">
<li><p class="first">構造はインデックス付けされた頂点とポリゴンで識別できます。エッジやポリゴン頂点(フェース頂点(face-vertex))は含まれません。詳細は <a class="reference internal" href="utilizinggpucompute.html#polygonmeshcomponents"><span class="std std-ref">ポリゴンメッシュ</span></a> をご覧ください。</p>
</li>
<li><p class="first"><a class="reference internal" href="GeometryAttribute.html#geometryattribute"><span class="std std-ref">GeometryAttribute</span></a> 要素は、OpenGLなどのAPIハードウェアドローイングのダイレクトマッピングのために整列されています。詳細は <a class="reference internal" href="#polygonmeshattributes"><span class="std std-ref">ポリゴンメッシュアトリビュート</span></a> をご覧ください。</p>
</li>
<li><p class="first">メッシュ構造を変更する際には、いくつかの特別なルールが適用されます。詳細は <a class="reference internal" href="#modifyingpolygonmeshstructure"><span class="std std-ref">メッシュ構造の変更</span></a> をご覧ください。</p>
</li>
<li>the <a class="reference internal" href="PolygonMesh.html#polygonmesh"><span class="std std-ref">PolygonMesh</span></a> structure tries to reduce memory consumption and fragmentation by
grouping most of its topological data into a few contiguous arrays, which can improve speed, particularly for
larger meshes. See <a class="reference internal" href="#internalpolygonmeshdata"><span class="std std-ref">内部データの構成</span></a> for more details.</li>
</ul>
<p><strong>ポリゴンメッシュは配列を大量に使用するため、 通常`unguarded` KLコンパイルは大半のポリゴンメッシュメソッド群で30％の高速化をもたらします</strong></p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">特に記述がない限り、メッシュの読み込みを行う関数はメッシュ構造やアトリビュートの共有レイアウトが変更されない場合にはスレッド セーフです。メッシュまたはアトリビュートの共有レイアウトを変更する関数はスレッド セーフではありません。</p>
</div>
</div>
<div class="section" id="polygonmeshtopology">
<span id="polygonmeshcomponents"></span><h2>ポリゴンメッシュトポロジー<a class="headerlink" href="#polygonmeshtopology" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="PolygonMeshTopology.html#polygonmeshtopology"><span class="std std-ref">PolygonMeshTopology</span></a> は1つの <a class="reference internal" href="PolygonMesh.html#polygonmesh"><span class="std std-ref">PolygonMesh</span></a> のトポロジー情報をカプセル化します。これは主に頂点データとポリゴンデータの格納という2つのシンメトリ構造から構成されます。各頂点はインデックスに関連付けられ、隣接するポリゴンのコーナー群 (ポリゴン頂点) へのリファレンスを格納したコンパクトな配列を持っています。同様に、各ポリゴンもインデックスに関連付けられ、ポリゴンに連結した頂点群へのリファレンスを格納したコンパクトな配列を持っています。</p>
<p>次の図は、頂点やポリゴンそしてそれらのローカルインデックス ( &#8216;neighborPolygonIndex&#8217;, &#8216;neighborPointIndex&#8217; ) の概念を示しています。</p>
<img alt="../../_images/components.png" src="../../_images/components.png" />
<p>次の表は、ストレージ及びこれらのコンポーネント間の関係の概略図です。</p>
<img alt="../../_images/component_tables.png" src="../../_images/component_tables.png" />
<p>この例では、上記図で示した構造のレポートを行うために <a class="reference internal" href="PolygonMesh.html#id63322"><span class="std std-ref">PolygonMesh.getDesc</span></a> 関数を使用しています。</p>
<div class="highlight-kl" id="griddumpexample"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Structure dump of a 2X2 grid:</span>
<span class="cm">*/</span>

<span class="kr">require</span> <span class="nx">Geometry</span><span class="p">;</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//Add a 2X2 grid if size 2.0</span>
  <span class="nx">PolygonMesh</span> <span class="nx">p</span><span class="p">();</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">addPlane</span><span class="p">(</span><span class="nx">Xfo</span><span class="p">(),</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span> <span class="nx">p</span><span class="p">.</span><span class="nx">getDesc</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">Mesh: pointCount: 9 polygonCount: 4 nbAttributeVectors: 9</span>
<span class="cm">  Points (adjacent polygons as &#39;polygon.neighborPolygonIndex&#39;, </span>
<span class="cm">          borders as &#39;|&#39;, closed wing starts as &#39;&lt;&lt;&#39;):</span>
<span class="cm">    0: 1 polygons:  |0.1</span>
<span class="cm">    1: 2 polygons:  |0.0, 1.1</span>
<span class="cm">    2: 1 polygons:  |1.0</span>
<span class="cm">    3: 2 polygons:  |2.1, 0.2</span>
<span class="cm">    4: 4 polygons:  &lt;&lt;3.1, 1.2, 0.3, 2.0</span>
<span class="cm">    5: 2 polygons:  |1.3, 3.0</span>
<span class="cm">    6: 1 polygons:  |2.2</span>
<span class="cm">    7: 2 polygons:  |3.2, 2.3</span>
<span class="cm">    8: 1 polygons:  |3.3</span>
<span class="cm">  Polygons (connected points as &#39;point.polygonPointIndex&#39;, borders as &#39;|&#39;):</span>
<span class="cm">    0: 4 points: 1.0 |, 0.0 |, 3.1, 4.2</span>
<span class="cm">    1: 4 points: 2.0 |, 1.1, 4.1, 5.0 |</span>
<span class="cm">    2: 4 points: 4.3, 3.0 |, 6.0 |, 7.1</span>
<span class="cm">    3: 4 points: 5.1, 4.0, 7.0 |, 8.0 |</span>


<span class="cm">*/</span>
</pre></div>
</div>
<p>様々なコンポーネント型やインデックスの詳細について:</p>
<ul class="simple">
<li><p class="first"><em class="dfn">point</em>: インデックスで表され、１つの頂点は可変数のポリゴン (または無し) に接続されます。ポリゴンメッシュの頂点は <cite>vertex</cite> と同じです。頂点の特定データを取得または設定する <a class="reference internal" href="PolygonMesh.html#polygonmesh"><span class="std std-ref">PolygonMesh</span></a> 関数は、通常それぞれ <cite>.getPoint</cite> または <cite>.setPoint</cite> で開始します。</p>
</li>
<li><p class="first"><em class="dfn">polygon</em>: インデックスで表され、1つのポリゴンは3つ以上の頂点の順序付けリストで定義されます。ポリゴンの特定データを取得または設定する <a class="reference internal" href="PolygonMesh.html#polygonmesh"><span class="std std-ref">PolygonMesh</span></a> 関数は、通常それぞれ <cite>.getPolygon</cite> または <cite>.setPolygon</cite> で開始します。</p>
</li>
</ul>
<ul id="neighborpolygonindex">
<li><p class="first"><em class="dfn">neighborPolygon</em>: 1つの頂点と、頂点を取り囲むポリゴン群の内の１つとのペアです。 <cite>neighborPolygon</cite> は、頂点インデックスと <cite>neighborPolygonIndex</cite> によるインデックスのペアで表されます。 <cite>neighborPolygonIndex</cite> は頂点ごとに割り振られた　[<cite>0</cite> ~ <a class="reference internal" href="PolygonMesh.html#id62799"><span class="std std-ref">PolygonMesh.getPointPolygonCount</span></a> <cite>()-1</cite> ]の範囲のローカルインデックスで、各インデックスは頂点に接続するポリゴンに相当します。 <cite>neighborPolygon</cite> と <cite>polygonPoint</cite> (後述します)は同じ位置を指しますが、それぞれ&#8217;頂点からの相対位置&#8217;と&#8217;ポリゴンからの相対位置&#8217;です。</p>
</li>
<li><p class="first"><em class="dfn">polygonPoint</em>: 1つのポリゴンと、頂点に接続されたポリゴンの角にあたる部分( <cite>フェース頂点</cite> や <cite>ポリゴンノード</cite> と呼ばれるもの)とのペアです。 <cite>polygonPoint</cite> は、ポリゴンインデックスと <cite>polygonPointIndex</cite> によるインデックスのペアで表されます。 <cite>polygonPointIndex</cite> はポリゴンごとに割り振られた [ <cite>0</cite> ～ <a class="reference internal" href="PolygonMesh.html#id62939"><span class="std std-ref">PolygonMesh.getPolygonSize</span></a> <cite>()-1</cite> ] の範囲のローカルインデックスで、各インデックスはポリゴンに接続する頂点に相当します。 <cite>neighborPolygon</cite> と <cite>polygonPoint</cite> は同じ位置を指しますが、それぞれ&#8217;頂点からの相対位置&#8217;と&#8217;ポリゴンからの相対位置&#8217;です。</p>
</li>
<li><p class="first"><a class="reference internal" href="PolygonMeshEdge.html#polygonmeshedge"><span class="std std-ref">PolygonMeshEdge</span></a>: 大半のメッシュ構造とは対照的に、ポリゴンエッジ群はファーストクラスコンポーネントではありません。しかし、ポリゴンインデックスと頂点インデックスのペアで定義される構造体によって表されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="PolygonMesh.html#polygonmesh"><span class="std std-ref">PolygonMesh (object)</span></a> 構造はエッジとポリゴン頂点群(フェース頂点)を明確なインデックスに関連付けせず、助長を回避することでよりコンパクトにできます。一般的には、エッジインデックスはDCCツール等で他のメッシュに対し転送する、もしくは転送されることは無いのでこれは問題にはならないでしょう。エッジやポリゴン頂点のテーブルの格納を回避することは、同等のハーフエッジ構造よりも50%のデータ縮小を可能にします。そして、メモリの局所性によって大半のオペレーションが高速で実行されます。</p>
</div>
</li>
</ul>
<p>ポリゴンメッシュ構造データの構成方法に関する詳細は <a class="reference internal" href="#internalpolygonmeshdata"><span class="std std-ref">内部データの構成</span></a> を参照してください。</p>
<div class="section" id="bounds-checking">
<h3>境界チェック(Bounds checking)<a class="headerlink" href="#bounds-checking" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="PolygonMesh.html#polygonmesh"><span class="std std-ref">PolygonMesh</span></a> の内部構造は、単一のメモリ バッファーに複数の小さい配列を格納します。このためKL guarded モードでは、大半の関数でインデックスが境界を順守するかどうかの検証を（特殊な Fabric_Guarded KLコンディションを使用し）明示的に行います。たとえば..</p>
<ul class="simple">
<li><p class="first"><cite>point</cite> と <cite>neighborPolygonIndex</cite> を取得する関数で、後者は [0 ～ <a class="reference internal" href="PolygonMesh.html#id62799"><span class="std std-ref">PolygonMesh.getPointPolygonCount</span></a> -1] の範囲内であると保証されます。</p>
</li>
<li><p class="first"><cite>polygon</cite> と <cite>polygonPointIndex</cite> を取得する関数で、後者は [0 ～ <a class="reference internal" href="PolygonMesh.html#id62939"><span class="std std-ref">PolygonMesh.getPolygonSize</span></a> -1] の範囲内であると保証されます。</p>
</li>
</ul>
<p>これらの正確な限界値のチェックと <a class="reference internal" href="PolygonMesh.html#polygonmesh"><span class="std std-ref">PolygonMesh (object)</span></a> では配列の使用率が高いことが合わさり、通常 <cite>unguarded</cite> コンパイルは大半のPolygonMeshメソッドで30%の高速化をもたらします。</p>
</div>
</div>
<div class="section" id="polygonmesh-attributes">
<span id="polygonmeshattributes"></span><h2>ポリゴンメッシュアトリビュート<a class="headerlink" href="#polygonmesh-attributes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>他の <a class="reference internal" href="Geometry.html#geometry"><span class="std std-ref">Geometry</span></a> 型のように、 <a class="reference internal" href="PolygonMesh.html#polygonmesh"><span class="std std-ref">PolygonMesh</span></a> はアトリビュート群を <a class="reference internal" href="GeometryAttributes.html#geometryattributes"><span class="std std-ref">GeometryAttributes</span></a> コンテナに格納します。このことは、全ての <a class="reference internal" href="GeometryAttribute.html#geometryattribute"><span class="std std-ref">GeometryAttribute</span></a> の値は整列したインデックスで、かつ同じサイズを持つことを意味し、アトリビュート値の配列をOpenGLのようなドローイングバッファーに直接マッピングすることを可能にします。しかし、頂点の周りの共有の値をサポートすると同時にグローバル値の配置を維持するには、 <a class="reference internal" href="PolygonMesh.html#polygonmesh"><span class="std std-ref">PolygonMesh</span></a> にアトリビュートの管理機能の追加を必要とします。そしてこれはAPIに影響を与えます。</p>
<p><a class="reference internal" href="PolygonMesh.html#polygonmesh"><span class="std std-ref">PolygonMesh</span></a> のAPIにおいて、 <em class="dfn">attributeIndex</em> は <a class="reference internal" href="GeometryAttribute.html#geometryattribute"><span class="std std-ref">GeometryAttribute</span></a> の値の配列（ <a class="reference internal" href="GeometryAttributes.html#id52602"><span class="std std-ref">GeometryAttributes.size</span></a> のエレメントの合計）と関連があります。 <cite>attributeIndex</cite> と頂点インデックスが一致するかは、頂点の周りのアトリビュート値の共有（もしくは分割）レイアウトに依存する重要な問題です。様々なアトリビュートの中で１つでも頂点を分割したアトリビュートが存在するなら、頂点と連結する各 <cite>polygonPoint</cite> の値は異なる <cite>attributeIndex`に格納されます。一方[0～:kl-ref:`PolygonMesh.pointCount</cite> () - 1] の範囲内の <cite>attributeIndex</cite> は、同じインデックスの頂点に所有します。</p>
<p>以下の図では、分割したアトリビュート値が <cite>attributeIndex</cite> へ追加で割り当てられる方法を紹介します。</p>
<img alt="../../_images/attribute_indices.png" src="../../_images/attribute_indices.png" />
<p>頂点位置の値についても、グローバルアトリビュートの配列を確保するために順に沿って複製されることに注意してください。</p>
<p>次の例では、アトリビュート値と共にメッシュ構造をダンプします。 <cite>attributeIndex</cite> は共有していない(分割した)アトリビュート値を持つ頂点群のレポートのみです。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: dump of the structure of a 2X2 grid:</span>
<span class="cm">*/</span>

<span class="kr">require</span> <span class="nx">Geometry</span><span class="p">;</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//Add a 2X2 grid if size 2.0</span>
  <span class="nx">PolygonMesh</span> <span class="nx">p</span><span class="p">();</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">addPlane</span><span class="p">(</span><span class="nx">Xfo</span><span class="p">(),</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

  <span class="c1">//Set the weights of polygons 0 and 1 to 1.0, and</span>
  <span class="c1">//the weiths of polygons 2 and 3 to 0.0.</span>
  <span class="nx">Ref</span><span class="o">&lt;</span><span class="nx">ScalarAttribute</span><span class="o">&gt;</span> <span class="nx">weights</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">getOrCreateScalarAttribute</span><span class="p">(</span><span class="s1">&#39;weights&#39;</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span> <span class="kr">UInt32</span> <span class="nx">polygon</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">polygon</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="nx">polygon</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span> <span class="kr">UInt32</span> <span class="nx">polygonPointIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">polygonPointIndex</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="nx">polygonPointIndex</span> <span class="p">)</span>
      <span class="nx">p</span><span class="p">.</span><span class="nx">setPolygonAttribute</span><span class="p">(</span> <span class="nx">polygon</span><span class="p">,</span> <span class="nx">polygonPointIndex</span><span class="p">,</span> <span class="nx">weights</span><span class="p">,</span> <span class="nx">polygon</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">0.0</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="nb">report</span><span class="p">(</span> <span class="nx">p</span><span class="p">.</span><span class="nx">getDesc</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">Mesh: pointCount: 9 polygonCount: 4 nbAttributeVectors: 12</span>
<span class="cm">  Points (adjacent polygons as &#39;polygon.neighborPolygonIndex&#39;, </span>
<span class="cm">          borders as &#39;|&#39;, closed wing starts as &#39;&lt;&lt;&#39;,</span>
<span class="cm">          unshared attribute as value@attributeIndex ):</span>
<span class="cm">    0: 1 polygons:  |0.1</span>
<span class="cm">      Attr positions:{x:-1.0,y:+0.0,z:-1.0}</span>
<span class="cm">      Attr weights:+1.0</span>
<span class="cm">    1: 2 polygons:  |0.0, 1.1</span>
<span class="cm">      Attr positions:{x:+0.0,y:+0.0,z:-1.0}</span>
<span class="cm">      Attr weights:+1.0</span>
<span class="cm">    2: 1 polygons:  |1.0</span>
<span class="cm">      Attr positions:{x:+1.0,y:+0.0,z:-1.0}</span>
<span class="cm">      Attr weights:+1.0</span>
<span class="cm">    3: 2 polygons:  |2.1, 0.2</span>
<span class="cm">      Attr positions:{x:-1.0,y:+0.0,z:+0.0}</span>
<span class="cm">      Attr weights:+0.0@10 +1.0@3 </span>
<span class="cm">    4: 4 polygons:  &lt;&lt;3.1, 1.2, 0.3, 2.0</span>
<span class="cm">      Attr positions:{x:+0.0,y:+0.0,z:+0.0}</span>
<span class="cm">      Attr weights:+0.0@9 +1.0@4 +1.0@4 +0.0@9 </span>
<span class="cm">    5: 2 polygons:  |1.3, 3.0</span>
<span class="cm">      Attr positions:{x:+1.0,y:+0.0,z:+0.0}</span>
<span class="cm">      Attr weights:+1.0@5 +0.0@11 </span>
<span class="cm">    6: 1 polygons:  |2.2</span>
<span class="cm">      Attr positions:{x:-1.0,y:+0.0,z:+1.0}</span>
<span class="cm">      Attr weights:+0.0</span>
<span class="cm">    7: 2 polygons:  |3.2, 2.3</span>
<span class="cm">      Attr positions:{x:+0.0,y:+0.0,z:+1.0}</span>
<span class="cm">      Attr weights:+0.0</span>
<span class="cm">    8: 1 polygons:  |3.3</span>
<span class="cm">      Attr positions:{x:+1.0,y:+0.0,z:+1.0}</span>
<span class="cm">      Attr weights:+0.0</span>
<span class="cm">  Polygons (connected points as &#39;point.polygonPointIndex&#39;, borders as &#39;|&#39;):</span>
<span class="cm">    0: 4 points: 1.0 |, 0.0 |, 3.1, 4.2</span>
<span class="cm">    1: 4 points: 2.0 |, 1.1, 4.1, 5.0 |</span>
<span class="cm">    2: 4 points: 4.3, 3.0 |, 6.0 |, 7.1</span>
<span class="cm">    3: 4 points: 5.1, 4.0, 7.0 |, 8.0 |</span>


<span class="cm">*/</span>
</pre></div>
</div>
<p>以下のメソッド群では、明示的なアトリビュート値をセットすることが可能です。</p>
<ul>
<li><p class="first">頂点共有の値(一律の値)： <a class="reference internal" href="PolygonMesh.html#id63612"><span class="std std-ref">PolygonMesh.setPointAttribute</span></a> <cite>(Size point, io GeometryAttribute attribute, Value value)</cite>: これらメソッド群は、同じ頂点でも非共有のアトリビュートがある場合に備えて、すべての値が明示的な設定であると保証します。 <a class="reference internal" href="PolygonMesh.html#id62755"><span class="std std-ref">PolygonMesh.setPointPosition</span></a> と <a class="reference internal" href="PolygonMesh.html#id62784"><span class="std std-ref">PolygonMesh.setPointNormal</span></a> の特別なメソッドは類似しています。これらメソッドはアトリビュートの共通レイアウト( <cite>attributeIndex</cite> )を変更せず、レイアウトが変更しない場合はスレッドセーフです。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">これらメソッドは、GeometryAttribute型(例えば <a class="reference internal" href="Vec3Attribute.html#vec3attribute"><span class="std std-ref">Vec3Attribute</span></a> )の特定のセットのみで定義されています。 カスタムアトリビュート型を含むような他の型では、コード内で似たような関数を定義することで簡単に機能を拡張します。</p>
</div>
</li>
<li><p class="first">頂点の周りで共有が解除される可能性のある値:</p>
<ul class="simple">
<li><p class="first">隣接頂点ごと: <a class="reference internal" href="PolygonMesh.html#id63612"><span class="std std-ref">PolygonMesh.setPointAttribute</span></a> <cite>(Size point, Size neighborPolygonIndex, io GeometryAttribute attribute, Value value)</cite></p>
</li>
<li><p class="first">ポリゴン頂点ごと: <a class="reference internal" href="PolygonMesh.html#id63764"><span class="std std-ref">PolygonMesh.setPolygonAttribute</span></a> <cite>(Size polygon, Size polygonPointIndex, io GeometryAttribute attribute, Value value)</cite></p>
</li>
</ul>
<p>これらのメソッドは、特定の隣接するポリゴン(ポリゴン頂点)に値を設定します。それらは、以前に設定された値との比較によって頂点の共有が維持できるかどうかをチェックし、可能でない場合には新しい <cite>attributeIndex</cite> を割り当てます。これらのメソッド群は、アトリビュートの共有レイアウト( <cite>attributeIndex</cite> )を変更するのであればスレッド セーフでは&#8221;ありません&#8221;。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">これらメソッドは、GeometryAttribute型(例えば <a class="reference internal" href="Vec3Attribute.html#vec3attribute"><span class="std std-ref">Vec3Attribute</span></a> )の特定のセットのみで定義されています。 カスタムアトリビュート型を含むような他の型では、コード内で似たような関数を定義することで簡単に機能を拡張します。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>値の共有を正しく管理するために、ポリゴンメッシュは内部でアトリビュートごとの <cite>Boolean initialized</cite> 状態を管理します。それは明示的に設定された値と既定値の両者の区別をすることができます。</p>
<p class="last"><a class="reference internal" href="PolygonMesh.html#id63437"><span class="std std-ref">PolygonMesh.resetAttributeAndAvoidSharingChanges</span></a> メソッドは、不要な分割および既存のアトリビュートの共有レイアウト( <cite>attributeIndex</cite> )を維持しようとしたアトリビュート値を無効にすることができます。</p>
</div>
</li>
</ul>
<p><cite>attributeIndex</cite> は <a class="reference internal" href="PolygonMesh.html#id63445"><span class="std std-ref">PolygonMesh.getPointAttributeIndex</span></a> か <a class="reference internal" href="PolygonMesh.html#id63668"><span class="std std-ref">PolygonMesh.getPolygonAttributeIndex</span></a> メソッドのいずれかを使用して取得できます。</p>
<p><a class="reference internal" href="PolygonMesh.html#id63457"><span class="std std-ref">PolygonMesh.arePointAttributesUniform</span></a> と <a class="reference internal" href="PolygonMesh.html#id63461"><span class="std std-ref">PolygonMesh.isPointAttributeUniform</span></a> は、それぞれ全てまたは特定のアトリビュートで値が１つのポイントで共有されているかどうかを教えてくれます。</p>
<p>メッシュは描画API(OpenGLなど)で使いやすい整列されたアトリビュート値を維持するので、トライアングル描画リストは <cite>attributeIndex</cite> の3つセットと直接一致します。 <a class="reference internal" href="PolygonMesh.html#id63310"><span class="std std-ref">PolygonMesh.generateAttributesTriangleList</span></a> メソッドはそのリストを返します。</p>
</div>
<div class="section" id="borders-and-wings">
<span id="borderandwings"></span><h2>ボーダーとウィング<a class="headerlink" href="#borders-and-wings" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>大半の頂点は、通常規則的なサーフェース( <cite>manifold</cite> )で形成するポリゴンに接続されいると同時に、 <cite>borders</cite> と <cite>wings</cite> といった特別なトポロジーの特徴を持っています。注意して処理しない場合、これらの珍しい機能はメッシュ構造を扱うときの問題の原因になります。</p>
<ul>
<li><p class="first"><em class="dfn">border</em> は1つのポリゴンに隣接する境界エッジです。</p>
</li>
<li><p class="first"><em class="dfn">wing</em> は同じ頂点に接続しているポリゴン群のセットであり、その頂点に対して相対的に隣接するグループです。つまり <cite>wing</cite> は、指定された頂点の周りの非境界エッジ群を横切ることができるポリゴン群のひとまとめのことです。</p>
<ul class="simple">
<li><p class="first"><cite>オープンウィング</cite> は2本の境界エッジで区切られたウィングです。 <cite>オープンウィング</cite> は1つ以上のポリゴン群を含めることができます。</p>
</li>
<li><p class="first"><cite>クローズドウィング</cite> は、ウィングのすべてのエッジが境界エッジではないポリゴンのループによって形成されます。 <cite>クローズドウィング</cite> には2つ以上のポリゴンが含まれます。</p>
</li>
</ul>
<p>.</p>
</li>
</ul>
<p>頂点ポリゴン群が順序付けされたとき (頂点ポリゴンの順序付けについては <a class="reference internal" href="#modifyingpolygonmeshstructure"><span class="std std-ref">メッシュ構造の変更</span></a> を参照してください)、指定した頂点に対してウィングが持つ連続した <cite>polygonNeighborIndex</cite> と同じポリゴン群が保証されます。</p>
<blockquote>
<div></div></blockquote>
<p>イラストではウィングとボーダーの概念を示します。</p>
<img alt="../../_images/borders_and_wings.png" src="../../_images/borders_and_wings.png" />
<p>この例では、さまざまな関数を使用して頂点0のウィングとボーダーの情報を収集します。メッシュは、前の図に対応しています。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Getting border and wing information</span>
<span class="cm">*/</span>

<span class="kr">require</span> <span class="nx">Geometry</span><span class="p">;</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//Create the 2 wings structure around point 0</span>
  <span class="nx">PolygonMesh</span> <span class="nx">p</span><span class="p">();</span>

  <span class="nx">p</span><span class="p">.</span><span class="nx">beginStructureChanges</span><span class="p">();</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">createPoints</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

  <span class="c1">//Open wing: polygons 0 and 1</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">addPolygon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">addPolygon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">//Closed wing: polygons 2..5</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">addPolygon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">);</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">addPolygon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">addPolygon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">addPolygon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>

  <span class="nx">p</span><span class="p">.</span><span class="nx">endStructureChanges</span><span class="p">();</span>

  <span class="c1">//Get border information around point 0</span>
  <span class="nx">Size</span> <span class="nx">pointPolygonCount</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">getPointPolygonCount</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span> <span class="nx">Size</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">pointPolygonCount</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span> <span class="p">)</span> <span class="p">{</span>

    <span class="kr">Boolean</span> <span class="nx">precededByBorder</span><span class="p">,</span> <span class="nx">atClosedWingStart</span><span class="p">;</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">getPointBorderInfo</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">precededByBorder</span><span class="p">,</span> <span class="nx">atClosedWingStart</span> <span class="p">);</span>

    <span class="nb">report</span><span class="p">(</span>  <span class="s2">&quot;Point 0, neighbor &quot;</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">+</span> <span class="s2">&quot;: polygon=&quot;</span> <span class="o">+</span> <span class="nx">p</span><span class="p">.</span><span class="nx">getPointPolygon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
           <span class="o">+</span> <span class="s2">&quot; precededByBorder=&quot;</span> <span class="o">+</span> <span class="nx">precededByBorder</span> <span class="o">+</span> <span class="s2">&quot; atClosedWingStart=&quot;</span> <span class="o">+</span> <span class="nx">atClosedWingStart</span><span class="p">);</span>

    <span class="kr">UInt32</span> <span class="nx">prevPolygonPointIndex</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">getPointPrevNeighborPolygonIndexInWing</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
    <span class="kr">UInt32</span> <span class="nx">nextPolygonPointIndex</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">getPointNextNeighborPolygonIndexInWing</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>

    <span class="nb">report</span><span class="p">(</span>  <span class="s2">&quot;  Prev polygon: &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">prevPolygonPointIndex</span> <span class="o">==</span> <span class="nx">InvalidIndex</span> <span class="o">?</span> <span class="s2">&quot;(none)&quot;</span> <span class="o">:</span> <span class="kr">String</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">getPointPolygon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">prevPolygonPointIndex</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
           <span class="o">+</span> <span class="s2">&quot;, next polygon: &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">nextPolygonPointIndex</span> <span class="o">==</span> <span class="nx">InvalidIndex</span> <span class="o">?</span> <span class="s2">&quot;(none)&quot;</span> <span class="o">:</span> <span class="kr">String</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">getPointPolygon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">nextPolygonPointIndex</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">);</span>

    <span class="nx">Size</span> <span class="nx">wingPolygonPointIndexBegin</span><span class="p">,</span> <span class="nx">wingPolygonPointIndexEnd</span><span class="p">;</span>
    <span class="kr">Boolean</span> <span class="nx">isClosedWing</span><span class="p">;</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">getPointPolygonFullBorderInfo</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">wingPolygonPointIndexBegin</span><span class="p">,</span> <span class="nx">wingPolygonPointIndexEnd</span><span class="p">,</span> <span class="nx">isClosedWing</span> <span class="p">);</span>

    <span class="kr">String</span> <span class="nx">wingPolygons</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="nx">Size</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">wingPolygonPointIndexBegin</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">wingPolygonPointIndexEnd</span><span class="p">;</span> <span class="o">++</span><span class="nx">j</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span> <span class="nx">j</span> <span class="o">!=</span> <span class="nx">wingPolygonPointIndexBegin</span> <span class="p">)</span>
        <span class="nx">wingPolygons</span> <span class="o">+=</span> <span class="s1">&#39;,&#39;</span><span class="p">;</span>
      <span class="nx">wingPolygons</span> <span class="o">+=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">getPointPolygon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">j</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nb">report</span><span class="p">(</span>   <span class="s2">&quot;  Part of &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">isClosedWing</span> <span class="o">?</span> <span class="s2">&quot;a closed&quot;</span> <span class="o">:</span> <span class="s2">&quot;an open&quot;</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot; wing made of poygons &quot;</span> <span class="o">+</span> <span class="nx">wingPolygons</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//Get border information around polygon 0</span>
  <span class="k">for</span><span class="p">(</span> <span class="nx">Size</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kr">UInt32</span> <span class="nx">nextI</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">nextPolygonPointIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span><span class="c1">//next point of the triangle; same as (i+1)%3</span>
    <span class="nb">report</span><span class="p">(</span>  <span class="s2">&quot;Polygon 0: edge from point &quot;</span> <span class="o">+</span> <span class="nx">p</span><span class="p">.</span><span class="nx">getPolygonPoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
           <span class="o">+</span> <span class="s2">&quot; to point &quot;</span> <span class="o">+</span> <span class="nx">p</span><span class="p">.</span><span class="nx">getPolygonPoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">nextI</span><span class="p">)</span>
           <span class="o">+</span> <span class="s2">&quot;: border=&quot;</span> <span class="o">+</span> <span class="nx">p</span><span class="p">.</span><span class="nx">isPolygonBorder</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">Point 0, neighbor 0: polygon=0 precededByBorder=true atClosedWingStart=false</span>
<span class="cm">  Prev polygon: (none), next polygon: 1</span>
<span class="cm">  Part of an open wing made of poygons 0,1</span>
<span class="cm">Point 0, neighbor 1: polygon=1 precededByBorder=false atClosedWingStart=false</span>
<span class="cm">  Prev polygon: 0, next polygon: (none)</span>
<span class="cm">  Part of an open wing made of poygons 0,1</span>
<span class="cm">Point 0, neighbor 2: polygon=5 precededByBorder=false atClosedWingStart=true</span>
<span class="cm">  Prev polygon: 4, next polygon: 2</span>
<span class="cm">  Part of a closed wing made of poygons 5,2,3,4</span>
<span class="cm">Point 0, neighbor 3: polygon=2 precededByBorder=false atClosedWingStart=false</span>
<span class="cm">  Prev polygon: 5, next polygon: 3</span>
<span class="cm">  Part of a closed wing made of poygons 5,2,3,4</span>
<span class="cm">Point 0, neighbor 4: polygon=3 precededByBorder=false atClosedWingStart=false</span>
<span class="cm">  Prev polygon: 2, next polygon: 4</span>
<span class="cm">  Part of a closed wing made of poygons 5,2,3,4</span>
<span class="cm">Point 0, neighbor 5: polygon=4 precededByBorder=false atClosedWingStart=false</span>
<span class="cm">  Prev polygon: 3, next polygon: 5</span>
<span class="cm">  Part of a closed wing made of poygons 5,2,3,4</span>
<span class="cm">Polygon 0: edge from point 0 to point 3: border=true</span>
<span class="cm">Polygon 0: edge from point 3 to point 2: border=true</span>
<span class="cm">Polygon 0: edge from point 2 to point 0: border=false</span>

<span class="cm">*/</span>
</pre></div>
</div>
<ul class="simple">
<li><p class="first">頂点のボーダーとウィングの情報は、 <a class="reference internal" href="PolygonMesh.html#id62871"><span class="std std-ref">PolygonMesh.getPointBorderInfo</span></a> と <a class="reference internal" href="PolygonMesh.html#id62886"><span class="std std-ref">PolygonMesh.getPointPolygonFullBorderInfo</span></a> メソッドで取得できます。</p>
</li>
<li><p class="first">ポリゴンのボーダー情報は、 <a class="reference internal" href="PolygonMesh.html#id63078"><span class="std std-ref">PolygonMesh.isPolygonBorder</span></a> メソッドで取得できます。</p>
</li>
<li><p class="first"><cite>neighborPolygonIndex</cite> について、ウィング内の前後の <cite>neighborPolygonIndex</cite> は <a class="reference internal" href="PolygonMesh.html#id62904"><span class="std std-ref">PolygonMesh.getPointPrevNeighborPolygonIndexInWing</span></a> と <a class="reference internal" href="PolygonMesh.html#id62909"><span class="std std-ref">PolygonMesh.getPointNextNeighborPolygonIndexInWing</span></a> で取得することができます。</p>
</li>
</ul>
</div>
<div class="section" id="modifying-the-mesh-structure">
<span id="modifyingpolygonmeshstructure"></span><h2>メッシュ構造の変更<a class="headerlink" href="#modifying-the-mesh-structure" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Various methods can modify the mesh structure, such as <a class="reference internal" href="PolygonMesh.html#id63168"><span class="std std-ref">PolygonMesh.addPolygon</span></a>, <a class="reference internal" href="PolygonMesh.html#id63139"><span class="std std-ref">PolygonMesh.createPoints</span></a>
and <a class="reference internal" href="PolygonMesh.html#id63943"><span class="std std-ref">PolygonMesh.deletePolygon</span></a>. All these functions are not threadsafe, and a calls to one of these while another
thread is accessing the mesh will cause an undefined behavior.</p>
<p>ここで少しだけ触れておくと、メッシュ構造の変更は <a class="reference internal" href="PolygonMesh.html#id63102"><span class="std std-ref">PolygonMesh.beginStructureChanges</span></a> と <a class="reference internal" href="PolygonMesh.html#id63136"><span class="std std-ref">PolygonMesh.endStructureChanges</span></a> のブラケット(または <cite>PolygonMeshStructureChangeBracket</cite> の使用)を呼び出した間で発生させる必要があります。この要求は、頂点の配列の概念(以下に示す)に従い、最適なパフォーマンスを可能にすると同時により複雑なメッシュAPIを作り出します。</p>
<p>いくつかの規定されたメッシュモデリングメソッドは、構造変更ブラケット外で呼ばれた場合エラーメッセージが出力されます。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Missing :kl-ref:`PolygonMesh.beginStructureChanges` and :kl-ref:`PolygonMesh.endStructureChanges`</span>
<span class="cm">*/</span>

<span class="kr">require</span> <span class="nx">Geometry</span><span class="p">;</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">PolygonMesh</span> <span class="nx">p</span><span class="p">();</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">createPoints</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">addPolygon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">Error: PolygonMesh.addPolygon: must be called within a begin/endStructureChanges() bracket</span>
<span class="cm">KL stack trace:</span>
<span class="cm">[ST] 1 kl.internal.String.SetErrorDataPtrAndLength.AS0()</span>
<span class="cm">[ST] 2 function.setError.R.St()</span>
<span class="cm">[ST] 3 method._addPolygon.L.Uo11PolygonMesh.R.Re18LocalL8UInt32Array.R.Bo() PolygonMeshBase.kl:1076</span>
<span class="cm">[ST] 4 method.addPolygon.L.Uo11PolygonMesh.R.Iu32.R.Iu32.R.Iu32() PolygonMeshBase.kl:1220</span>
<span class="cm">[ST] 5 operator.entry() (stdin):11</span>
<span class="cm">[ST] 6 kl.internal.entry.stub.cpu()</span>

<span class="cm">*/</span>
</pre></div>
</div>
<p>構造変更ブラケットの呼び出しは、パフォーマンスと以下に示す実用的な理由のために存在しています。</p>
<div class="section" id="delayed-point-ordering">
<span id="delayedpointordering"></span><h3>頂点の順序付けを遅らせる<a class="headerlink" href="#delayed-point-ordering" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ある頂点に対し全ての隣り合う隣接ポリゴンが連続した &#8216;polygonPointNeighbor&#8217; のインデックスを有せば、頂点は <cite>順序付けされたポリゴン群</cite> を持っています。頂点を囲むポリゴンの順序の更新に併せて、頂点の順序付けプロセスには頂点へのウィングやボーダーの情報の更新も含まれます( <a class="reference internal" href="#borderandwings"><span class="std std-ref">ボーダーとウィング</span></a> を参照してください)。</p>
<p>複数のポリゴンを修正する際、最適なパフォーマンスを得るために <a class="reference internal" href="PolygonMesh.html#id63168"><span class="std std-ref">PolygonMesh.addPolygon</span></a> のようないくつかのメソッドではメッシュ構造変更ブラケットを閉じる( <a class="reference internal" href="PolygonMesh.html#id63136"><span class="std std-ref">PolygonMesh.endStructureChanges</span></a> を使う)までは頂点の順序を更新しません。順序付けされていない頂点の内部リストを用いて、メッシュは順序付けられていない頂点だけを更新するようにします。</p>
<p>複数ポリゴンを追加または削除するといった状況で頂点ポリゴン群の順序付けを遅らせることは、これら２つの最適化を可能にします。</p>
<ul class="simple">
<li><p class="first">１つの頂点は通常 4 つ以上のポリゴンに隣接しているため、隣接するポリゴンを追加または削除するたびに更新するのではなく、一度だけの更新で頂点の順序付けを行うようにします。</p>
</li>
<li><p class="first">多数の順序付けされていないポリゴン(特に全メッシュの構築後)に更新がかかる可能性があり、全頂点はマルチスレッドを活かしたバッチ内で並べ替えることができます。</p>
</li>
</ul>
<p>順序付けされていないポリゴン群を持つ頂点を照会する大半のメソッドは、( <cite>guarded</cite> KL をコンパイルする場合でのみ) エラーをレポートします。同様に、ポリゴンの隣接情報を照会するメソッド群が適切に順序付けされた頂点を必要とした場合、同様のエラーをレポートします。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Missing :kl-ref:`PolygonMesh.beginStructureChanges` and :kl-ref:`PolygonMesh.endStructureChanges`</span>
<span class="cm">*/</span>

<span class="kr">require</span> <span class="nx">Geometry</span><span class="p">;</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">PolygonMesh</span> <span class="nx">p</span><span class="p">();</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">beginStructureChanges</span><span class="p">();</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">createPoints</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">addPolygon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">isPolygonBorder</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>


<span class="cm">*/</span>
</pre></div>
</div>
<p>特殊な状況では、構造変更ブラケット内であっても強制的に頂点ポリゴンの順序付けを行う必要があるかもしれません。以下のメソッドは、このような更新を許可します。</p>
<ul class="simple">
<li><p class="first"><a class="reference internal" href="PolygonMesh.html#id63129"><span class="std std-ref">PolygonMesh.updatePointsPolygonOrder</span></a> : すべての順序付けされていない全ての頂点に適するようにポリゴン群を順序付けます。</p>
</li>
<li><p class="first"><a class="reference internal" href="PolygonMesh.html#id63132"><span class="std std-ref">PolygonMesh.updatePointPolygonOrder</span></a> : 順序付けされていない特定の頂点のためにポリゴンを順序付けます。</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="PolygonMesh.html#id63152"><span class="std std-ref">PolygonMesh.addPolygonAndUpdateStructure</span></a> は <a class="reference internal" href="PolygonMesh.html#id63168"><span class="std std-ref">PolygonMesh.addPolygon</span></a> メソッドに似ていますが、関連する頂点を直ちに順序付けます。</p>
</div>
</div>
<div class="section" id="replacement-of-deleted-component-indices">
<span id="deletedcomponentsreplacement"></span><h3>削除されたコンポーネントインデックス群の置換<a class="headerlink" href="#replacement-of-deleted-component-indices" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一般的に、 <a class="reference internal" href="PolygonMesh.html#polygonmesh"><span class="std std-ref">PolygonMesh</span></a> は頂点とポリゴンのインデックスの連続した範囲(<cite>0..N-1</cite>)を維持します。このため、シンプルなインデックスループを用いたポリゴンや頂点の反復処理は安全です。</p>
<p>ただし <a class="reference internal" href="PolygonMesh.html#id63943"><span class="std std-ref">PolygonMesh.deletePolygon</span></a> のような頂点やポリゴンを削除するモデリングオペレーションでは、関連するインデックスは <a class="reference internal" href="PolygonMesh.html#id63136"><span class="std std-ref">PolygonMesh.endStructureChanges</span></a> ブラケットが呼ばれるまで未使用のまま存在し続けます。この方策の目的は、複数のモデリングオペレーションで安全かつ安定的にポリゴンや頂点のインデックスの使用を可能にすることです。</p>
<p>これは、コンポーネント群を削除したメッシュを処理するコードでは、インデックスがすでに無効（コンポーネントが削除された）となっているものがあるため注意を要します。PolygonMesh.isPolygonDeleted や PolygonMesh.isPointDeletedメソッドを使用することで、ある特定のインデックスが有効であるかを確認することができます。</p>
<p>一度 <a class="reference internal" href="PolygonMesh.html#id63136"><span class="std std-ref">PolygonMesh.endStructureChanges</span></a> に達すると、メッシュは利用可能な未使用インデックスに置き換えることによってインデックスを圧縮し直し、インデックスの範囲を減らします。この時点で、シンプルなインデックス ループを使用する全ての頂点やポリゴンにおいて反復処理は再び安全です。</p>
</div>
</div>
<div class="section" id="internal-data-organization">
<span id="internalpolygonmeshdata"></span><h2>内部データの構成<a class="headerlink" href="#internal-data-organization" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The internal data structure of the <a class="reference internal" href="PolygonMesh.html#polygonmesh"><span class="std std-ref">PolygonMesh</span></a> is very complex in order to allow both
a low memory consumption and fast query and modeling operations. In order to achieve this,
the structure does the following:</p>
<ul class="simple">
<li><p class="first">エッジとポリゴン頂点 (フェース頂点) 情報の格納を避けることによって冗長性を最小限に抑えます</p>
</li>
<li><p class="first">シングルメモリバッファに配列群を保つことを可能にする特別なアロケータ (<a class="reference internal" href="ArrayOffsetAllocator.html#arrayoffsetallocator"><span class="std std-ref">ArrayOffsetAllocator</span></a>) を使うことで、連続したメモリ空間にポリゴンと頂点データをパックします。これはメモリ使用量を低減しメモリの断片化を下げますが、より重要なのはCPUメモリキャッシュの効率的な使用を行うことで全てのメッシュオペレーターの速度が向上することです。一定割合のメモリバッファがフリーの時(例：多くのポリゴンを削除した後）、メッシュは最適なメモリ使用量を確保するために全ての内部データを自動的に再圧縮します。</p>
</li>
<li><p class="first">32 ビットのインデックスか少しのインダイレクションの使用で、64ビットのポインタに基づいた実装のメッシュと比較してメモリ使用量を50%低減します。別の利点として、独立したメモリロケーションにあり、高速なコピー操作を行えます。</p>
</li>
<li><p class="first">特別なビットパッキングを使用してポリゴンと頂点データをエンコードし、さらに50%のメモリ消費量を低減できます。例えば &#8220;polygon + pointNeighborIndex&#8221; ペアは、ほとんどの場合単体のUInt32としてエンコードされます。</p>
</li>
<li><p class="first">頂点とポリゴンのデータ(データオフセットを直接格納する) の間でジャンプすることを必要とするオペレーションのためのインダイレクションを減らすことによって、メモリのキャッシュミスを削減します。</p>
</li>
<li><p class="first">グローバルな <cite>attributeIndex</cite> (アトリビュートが非共有な場合の)データを頂点データ内に格納し、アトリビュートごとのインデックステーブルの発生を防ぎ、バッファに優しいGPU描画を維持します(詳しくは <a class="reference internal" href="#polygonmeshattributes"><span class="std std-ref">ポリゴンメッシュアトリビュート</span></a> を参照してください)。</p>
</li>
</ul>
<p>下の図はメッシュの内部データ構造の概念を表します。 <cite>pointData</cite> と <cite>polygonData</cite> は <a class="reference internal" href="ArrayOffsetAllocator.html#arrayoffsetallocator"><span class="std std-ref">ArrayOffsetAllocator</span></a> 構造群の対称として実装され、それらコンテンツはお互いを参照します。1つの <cite>pointIter</cite> と1つの <cite>polyIter</cite> はそれぞれパックされた頂点かデータバッファ内のオフセット(UInt32型)を指定します。 <cite>startIters</cite> 配列は頂点もしくはポリゴンインデックスに対応するオフセット(<cite>pointIter</cite> か <cite>polyIter</cite>) を含み、頂点とポリゴンデータを直接呼び出すことを可能にします。</p>
<img alt="../../_images/internal_structures.png" src="../../_images/internal_structures.png" />
</div>
<div class="section" id="current-limitations">
<span id="polygonmeshlimitations"></span><h2>現在の制限<a class="headerlink" href="#current-limitations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="PolygonMesh.html#polygonmesh"><span class="std std-ref">PolygonMesh</span></a> 構造には現在次の制限があります。</p>
<ul class="simple">
<li><p class="first">メッシュのポリゴン群は常に三角形化され、凹形ポリゴンを生成することができます。</p>
</li>
<li><p class="first">ポリゴンのホールはサポートされていません。</p>
</li>
<li><p class="first">ポリゴンごとやポリゴン共有のアトリビュートは存在しません。</p>
</li>
<li><p class="first">モデリングAPIにはcollapseEdgeやmergePointsといった様々な基本機能が欠けており、将来的に追加されるはずです。</p>
</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/FE_logo_211_37.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">PolygonMesh&#8217;s structure</a><ul>
<li><a class="reference internal" href="#introduction">概要</a></li>
<li><a class="reference internal" href="#polygonmeshtopology">ポリゴンメッシュトポロジー</a><ul>
<li><a class="reference internal" href="#bounds-checking">境界チェック(Bounds checking)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#polygonmesh-attributes">ポリゴンメッシュアトリビュート</a></li>
<li><a class="reference internal" href="#borders-and-wings">ボーダーとウィング</a></li>
<li><a class="reference internal" href="#modifying-the-mesh-structure">メッシュ構造の変更</a><ul>
<li><a class="reference internal" href="#delayed-point-ordering">頂点の順序付けを遅らせる</a></li>
<li><a class="reference internal" href="#replacement-of-deleted-component-indices">削除されたコンポーネントインデックス群の置換</a></li>
</ul>
</li>
<li><a class="reference internal" href="#internal-data-organization">内部データの構成</a></li>
<li><a class="reference internal" href="#current-limitations">現在の制限</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="index.html"
                        title="前の章へ">Geometry エクステンション</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="spatialqueriesusage.html"
                        title="次の章へ">ジオメトリを用いた空間分析群(Spatial queries)の使用</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/KLExtensionsGuide/Geometry/polygonmeshstructure.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    <li><a href="http://docs.fabric-engine.com/FabricEngine/latest/HTML/KLExtensionsGuide/Geometry/polygonmeshstructure.html"
              rel="nofollow">原文公式ページへ移動 (goto official page)</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="spatialqueriesusage.html" title="ジオメトリを用いた空間分析群(Spatial queries)の使用"
             >次へ</a> |</li>
        <li class="right" >
          <a href="index.html" title="Geometry エクステンション"
             >前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Fabric Engine 2.4.0 Unofficial Documentation (ja)</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >KL エクステンションガイド</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >Geometry エクステンション</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2010-2017 Fabric Software Inc.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1 で生成しました。
    </div>
  </body>
</html>