<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>関数と他のグローバルな宣言 &#8212; Fabric Engine 2.4.0 Unofficial Documentation (ja)</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.4.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="演算子・式" href="ops-exprs.html" />
    <link rel="prev" title="KLの型システム" href="types.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="ops-exprs.html" title="演算子・式"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="types.html" title="KLの型システム"
             accesskey="P">前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Fabric Engine 2.4.0 Unofficial Documentation (ja)</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">KL プログラミングガイド</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="functions-and-other-global-declarations">
<span id="globals"></span><h1>関数と他のグローバルな宣言<a class="headerlink" href="#functions-and-other-global-declarations" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>この章では、KLプログラムのグローバルスコープの中で現れる、関数や関数ライクなエンティティ、名前定数、そして <code class="docutils literal"><span class="pre">require</span></code> ステートメントのインスタンスを含む、それぞれのエンティティの詳細について触れていきます。構造体とオブジェクトの定義もグローバルスコープの中に現れます。そしてこれらについては、 <a class="reference internal" href="types.html#klpg-types"><span class="std std-ref">KLの型システム</span></a> 節で触れていきます。</p>
<div class="section" id="functions">
<span id="index-0"></span><span id="id1"></span><h2>関数<a class="headerlink" href="#functions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>関数はプログラムの他の部分から呼ばれるプログラム文の集まりです。関数はゼロまたはそれ以上の <em class="dfn">parameters</em> のリストを受け取り、オプションとして、 <em class="dfn">return value</em> を返します。</p>
<div class="section" id="function-definitions">
<span id="index-1"></span><h3>関数定義<a class="headerlink" href="#function-definitions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>KLにおける関数定義は、JavaScriptにおける &#8220;伝統的な&#8221; 関数定義の文法とほとんど同じです。次の重要な違いを除いて：</p>
<ul class="simple">
<li><p class="first">戻り値の型と関数の各パラメーターの型は明示的に宣言しなければなりません。もし関数が値を返さないのなら、戻り値の型の指定は取り除く必要があります。</p>
</li>
<li><p class="first">パラメーター宣言では、追加的に、<code class="docutils literal"><span class="pre">in</span></code> を前につけることで、入力(読み込みのみ：デフォルトです)パラメーターとして、または、 <code class="docutils literal"><span class="pre">io</span></code> を前につけることで、入出力（読み書き）パラメーターとして宣言することができます。</p>
</li>
<li><p class="first">関数はオプションとして <code class="docutils literal"><span class="pre">function</span></code> の代わりに <code class="docutils literal"><span class="pre">inline</span></code> キーワードを使って定義することができます。詳細は <a class="reference internal" href="#inline"><span class="std std-ref">Inline 関数,メソッド</span></a> を見てください。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">function</span></code> キーワードはオプションです。もし <code class="docutils literal"><span class="pre">function</span></code> や <code class="docutils literal"><span class="pre">inline</span></code> が指定されなかった場合は、<code class="docutils literal"><span class="pre">function</span></code> が指定されたとみなされます。</p>
</li>
</ul>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Function Definitions</span>
<span class="cm">*/</span>

<span class="c1">// Function returning a value and using only</span>
<span class="c1">// input parameters</span>

<span class="kd">function</span> <span class="kr">Float32</span> <span class="nx">add</span><span class="p">(</span><span class="kr">Float32</span> <span class="nx">lhs</span><span class="p">,</span> <span class="kr">Float32</span> <span class="nx">rhs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">lhs</span> <span class="o">+</span> <span class="nx">rhs</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Function not returning a value and using both</span>
<span class="c1">// input and input-output parameters</span>

<span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="k">in</span> <span class="kr">Float32</span> <span class="nx">lhs</span><span class="p">,</span> <span class="k">in</span> <span class="kr">Float32</span> <span class="nx">rhs</span><span class="p">,</span> <span class="k">io</span> <span class="kr">Float32</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">result</span> <span class="o">=</span> <span class="nx">lhs</span> <span class="o">+</span> <span class="nx">rhs</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// The &#39;function&#39; keyword is totally optional</span>
<span class="kr">Float32</span> <span class="nx">double</span><span class="p">(</span><span class="kr">Float32</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>

  <span class="kr">Float32</span> <span class="nx">addResult</span><span class="p">;</span>
  <span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">addResult</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">addResult</span><span class="p">);</span>

  <span class="nb">report</span><span class="p">(</span><span class="nx">double</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">+4.0</span>
<span class="cm">+4.0</span>
<span class="cm">+4.0</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="function-invocations">
<span id="index-2"></span><h3>関数呼び出し<a class="headerlink" href="#function-invocations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>関数呼び出し（&#8221;コール&#8221;）はJavaScriptと同じ文法で作られています。すなわち、関数名に対してコンマ区切りの引数リストを加え、丸カッコで囲みます。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Function Invocation</span>
<span class="cm">*/</span>

<span class="kd">function</span> <span class="kr">Integer</span> <span class="nx">add</span><span class="p">(</span><span class="kr">Integer</span> <span class="nx">lhs</span><span class="p">,</span> <span class="kr">Integer</span> <span class="nx">rhs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">lhs</span> <span class="o">+</span> <span class="nx">rhs</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;2 plus 2 is &quot;</span> <span class="o">+</span> <span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">2 plus 2 is 4</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="function-prototypes">
<span id="index-3"></span><h3>関数プロトタイプ<a class="headerlink" href="#function-prototypes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>KLにおける <em class="dfn">function prototype</em> はボディ（関数本体）のない関数宣言です。関数プロトタイプを使うことで、関数の定義より前の位置から、その関数を呼び出すことができます。</p>
<ul>
<li><p class="first">二つもしくはそれ以上の関数が互いを呼ぶとき、そのような関数は <em class="dfn">co-recursive</em> と呼ばれることがあります：</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Co-recursive Functions</span>
<span class="cm">*/</span>

<span class="c1">// Function prototype for &#39;two&#39;, so that &#39;one&#39; can call it before it is defined</span>
<span class="kd">function</span> <span class="nx">two</span><span class="p">(</span><span class="kr">Integer</span> <span class="nx">n</span><span class="p">);</span>

<span class="c1">// The function &#39;one&#39; calls &#39;two&#39; even though it is not yet defined</span>
<span class="kd">function</span> <span class="nx">one</span><span class="p">(</span><span class="kr">Integer</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;one&quot;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nx">two</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// The definition of the function &#39;two&#39; comes after its prototype</span>
<span class="kd">function</span> <span class="nx">two</span><span class="p">(</span><span class="kr">Integer</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;two&quot;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nx">one</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">one</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">one</span>
<span class="cm">two</span>
<span class="cm">one</span>
<span class="cm">two</span>
<span class="cm">one</span>

<span class="cm">*/</span>
</pre></div>
</div>
</li>
<li><p class="first">関数定義がFabricエクステンションから与えられたものだった場合、そのFabricエクステンション内の関数のシンボル名は、関数プロトタイプに <code class="samp docutils literal"><span class="pre">=</span> <span class="pre">&quot;</span><em><span class="pre">symbol</span> <span class="pre">name</span></em><span class="pre">&quot;</span></code> または <code class="samp docutils literal"><span class="pre">=</span> <span class="pre">'</span><em><span class="pre">symbol</span> <span class="pre">name</span></em><span class="pre">'</span></code> を追加したものになります。これらは通常、 <em class="dfn">external functions</em>: と呼ばれます。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: External Functions</span>
<span class="cm">*/</span>

<span class="c1">// The prototype &#39;libc_perror&#39; is linked to an external function &#39;perror&#39;</span>
<span class="kd">function</span> <span class="nx">libc_perror</span><span class="p">(</span><span class="nx">Data</span> <span class="nx">cString</span><span class="p">)</span> <span class="o">=</span> <span class="s1">&#39;perror&#39;</span><span class="p">;</span>

<span class="c1">// The KL function &#39;perror&#39; is what KL functions actually call</span>
<span class="kd">function</span> <span class="nx">perror</span><span class="p">(</span><span class="kr">String</span> <span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">libc_perror</span><span class="p">(</span><span class="nx">string</span><span class="p">.</span><span class="nx">data</span><span class="p">());</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">perror</span><span class="p">(</span><span class="s2">&quot;something that caused an error&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="polymorphism">
<span id="index-4"></span><span id="id4"></span><h2>ポリモーフィズム<a class="headerlink" href="#polymorphism" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>KLは <em class="dfn">compile-time function polymorphism</em> をサポートしています。これは、関数のパラメーターの数が異なるか、または、これらのパラメーターで型やin/ioの修飾が異なる場合に限り、同じ名前の複数の関数を持つことができる、というものです。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">全く同じ型のパラメータ群を持つ同じ名前の関数を２つ持とうとするとエラーになります（異なる型を返していたとしてもです）。</p>
</div>
<p>関数呼び出しがKLソース内で書かれていた時に、もし同じ名前の複数の関数が存在していたら、その時はKLコンパイラはどの関数を呼び出すべきか決めるためにベストマッチ・システムを使用します。厳格なパラメーターの型のマッチング（訳者注：暗黙のキャストなどを伴わずに、互いに全く同じ型であると判別すること）は常に型キャストより優先して行われます。もしコンパイラが唯一の最適な関数を選べなかった場合は、多義性（曖昧さ）を示すエラーを報告します。</p>
<p>次の例は、関数ポリモーフィズムの一つの使用例を示すものです。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Function Polymorphism</span>
<span class="cm">*/</span>

<span class="kd">function</span> <span class="nx">display</span><span class="p">(</span><span class="kr">Integer</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;integer value is &quot;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">display</span><span class="p">(</span><span class="kr">String</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;string value is &#39;&quot;</span> <span class="o">+</span> <span class="nx">s</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">Integer</span> <span class="nx">integer</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
  <span class="nx">display</span><span class="p">(</span><span class="nx">integer</span><span class="p">);</span>

  <span class="kr">String</span> <span class="nx">string</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span><span class="p">;</span>
  <span class="nx">display</span><span class="p">(</span><span class="nx">string</span><span class="p">);</span>

  <span class="kr">Byte</span> <span class="nx">byte</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
  <span class="nx">display</span><span class="p">(</span><span class="nx">byte</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">integer value is 42</span>
<span class="cm">string value is &#39;hello&#39;</span>
<span class="cm">integer value is 64</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="operators">
<span id="index-5"></span><span id="id5"></span><h2>演算子<a class="headerlink" href="#operators" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>KLにおける <code class="docutils literal"><span class="pre">operator</span></code> キーワードは、関数がFabricディペンデンシー・グラフからKLへのエントリーポイントとして使われるように、その関数をマークするために使用されます。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kd">operator</span> <span class="nx">addElements</span><span class="p">(</span><span class="k">io</span> <span class="kr">Float32</span> <span class="nx">lhs</span><span class="p">,</span> <span class="k">io</span> <span class="kr">Float32</span> <span class="nx">rhs</span><span class="p">,</span> <span class="k">io</span> <span class="kr">Float32</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">result</span> <span class="o">=</span> <span class="nx">lhs</span> <span class="o">+</span> <span class="nx">rhs</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="constructors">
<span id="klpg-constructor"></span><span id="index-6"></span><h2>コンストラクタ<a class="headerlink" href="#constructors" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ユーザー定義の型の <em class="dfn">constructor</em> は他の値から、ユーザーが定義した型の値を初期化する関数です。</p>
<div class="section" id="constructor-declarations">
<span id="index-7"></span><h3>コンストラクタ宣言<a class="headerlink" href="#constructor-declarations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>コンストラクタは、ユーザー定義の型と同じ名前の関数として宣言されます。このコンストラクタ関数は任意の個数のパラメーターを取ることができます。ただし、入力パラメーターである必要があります。コンストラクターは入出力パラメーターは取ることができません。また、コンストラクターは値を返せません。</p>
<p>コンストラクタ定義の本体の中では、初期化される値は、 <code class="docutils literal"><span class="pre">this</span></code> キーワードによって参照できます。そのメンバーには <code class="docutils literal"><span class="pre">.</span></code> (ドット）演算子を使うことでアクセスできます。このコンテキストにおいて、 <code class="docutils literal"><span class="pre">this</span></code> は常に読み書き可能です。つまり、メンバーは変更できます。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Constructor Declarations</span>
<span class="cm">*/</span>

<span class="kr">struct</span> <span class="nx">Complex32</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">re</span><span class="p">;</span>
  <span class="kr">Float32</span> <span class="nx">im</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// The empty constructor;</span>
<span class="kd">function</span> <span class="nx">Complex32</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">re</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">im</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Construct a Complex from a Float32</span>
<span class="kd">function</span> <span class="nx">Complex32</span><span class="p">(</span><span class="kr">Float32</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">re</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">im</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Construct a Complex from two Float32s</span>
<span class="kd">function</span> <span class="nx">Complex32</span><span class="p">(</span><span class="kr">Float32</span> <span class="nx">x</span><span class="p">,</span> <span class="kr">Float32</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">re</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">im</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">Complex32</span><span class="p">());</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">Complex32</span><span class="p">(</span><span class="mf">3.141</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">Complex32</span><span class="p">(</span><span class="mf">3.141</span><span class="p">,</span> <span class="mf">2.718</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{re:+0.0,im:+0.0}</span>
<span class="cm">{re:+3.141,im:+0.0}</span>
<span class="cm">{re:+3.141,im:+2.718}</span>

<span class="cm">*/</span>
</pre></div>
</div>
<p>関数のように、コンストラクタはオプションで <code class="docutils literal"><span class="pre">function</span></code> の代わりに <code class="docutils literal"><span class="pre">inline</span></code> を使って定義することができます。詳しくは <a class="reference internal" href="#inline"><span class="std std-ref">Inline 関数,メソッド</span></a> を参照してください。</p>
</div>
<div class="section" id="constructor-invocation">
<span id="index-8"></span><h3>コンストラクタ呼び出し<a class="headerlink" href="#constructor-invocation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>コンストラクタの呼び出し方はいくつかあります。</p>
<div class="section" id="naked-initialization">
<h4>裸の初期化<a class="headerlink" href="#naked-initialization" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>ある変数が何の初期化もなしに宣言されたとしたら、 <em class="dfn">empty constructor</em> （つまり、何のパラメーターも取らないコンストラクタ）がその変数を初期化するために呼び出されます。これを <em class="dfn">naked initialization</em> と呼びます。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Naked Initialization</span>
<span class="cm">*/</span>

<span class="kr">struct</span> <span class="nx">MyType</span> <span class="p">{</span>
  <span class="kr">Integer</span> <span class="nx">n</span><span class="p">;</span>
  <span class="kr">Float32</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// The empty constructor</span>
<span class="kd">function</span> <span class="nx">MyType</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mf">3.141</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">MyType</span> <span class="nx">myType</span><span class="p">;</span> <span class="c1">// invokes the empty constructor</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">myType</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{n:42,x:+3.141}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="assignment-initialization">
<h4>代入初期化<a class="headerlink" href="#assignment-initialization" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>もし、（ある型の初期化時に、）それと同じ型の変数が宣言の一部として代入されていた場合、単一パラメーターコンストラクタが呼び出されます。これは <em class="dfn">assignment initialization</em> と呼ばれます。もし、割り当てられた値の型にぴったりマッチするコンストラクタがなければ、呼び出すべきコンストラクタを選ぶために、ベスト・マッチ・ポリモーフィズムルールが適用されます。</p>
<p>例：</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">struct</span> <span class="nx">MyType</span> <span class="p">{</span>
  <span class="kr">String</span> <span class="nx">string</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Construct from a string</span>
<span class="kd">function</span> <span class="nx">MyType</span><span class="p">(</span><span class="kr">String</span> <span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">string</span> <span class="o">=</span> <span class="s2">&quot;The string was &#39;&quot;</span> <span class="o">+</span> <span class="nx">string</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Construct from a scalar</span>
<span class="kd">function</span> <span class="nx">MyType</span><span class="p">(</span><span class="kr">Float64</span> <span class="nx">float64</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">string</span> <span class="o">=</span> <span class="s2">&quot;The float64 was &quot;</span> <span class="o">+</span> <span class="nx">float64</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Construct MyType from String value</span>
  <span class="nx">MyType</span> <span class="nx">myTypeFromString</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">myTypeFromString</span><span class="p">);</span>

  <span class="c1">// Construct MyType from Float64 value</span>
  <span class="nx">MyType</span> <span class="nx">myTypeFromFloat64</span> <span class="o">=</span> <span class="mf">2.718</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">myTypeFromFloat64</span><span class="p">);</span>

  <span class="c1">// There is no constructor that takes a Boolean but</span>
  <span class="c1">// there is a cast from Boolean to String</span>
  <span class="nx">MyType</span> <span class="nx">myTypeFromBoolean</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">myTypeFromBoolean</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>出力：</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>{string:&quot;The string was &#39;foo&#39;&quot;}
{string:&quot;The float64 was 2.718&quot;}
{string:&quot;The string was &#39;true&#39;&quot;}
</pre></div>
</div>
</div>
<div class="section" id="invocation-initialization">
<h4>呼び出し初期化<a class="headerlink" href="#invocation-initialization" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>もし、ある変数がその宣言の一部として &#8220;呼び出されて&#8221;（つまり、関数呼び出しの文法を使って）いた場合、与えられた引数を取る（マッチする）コンストラクターが呼ばれます。これを <em class="dfn">invocation initialization</em> と呼びます。もし、呼び出し時に渡された引数とぴったりマッチするコンストラクタがない場合は、呼び出すべきコンストラクタを選ぶために、ベスト・マッチ・ポリモーフィズムルールが適用されます。</p>
<p>例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">Vec2</span> <span class="p">{</span>
  <span class="n">Float64</span> <span class="n">x</span><span class="p">;</span>
  <span class="n">Float64</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="o">//</span> <span class="n">Construct</span> <span class="kn">from</span> <span class="nn">two</span> <span class="n">scalars</span>
<span class="n">function</span> <span class="n">Vec2</span><span class="p">(</span><span class="n">Float64</span> <span class="n">x</span><span class="p">,</span> <span class="n">Float64</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">this</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
  <span class="n">this</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">operator</span> <span class="n">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Vec2</span> <span class="n">vec2FromFloat64s</span><span class="p">(</span><span class="mf">3.141</span><span class="p">,</span> <span class="mf">2.718</span><span class="p">);</span>
  <span class="n">report</span><span class="p">(</span><span class="n">vec2FromFloat64s</span><span class="p">);</span>
  <span class="n">Vec2</span> <span class="n">vec2FromIntegers</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">);</span>  <span class="o">//</span> <span class="n">Uses</span> <span class="n">best</span><span class="o">-</span><span class="n">match</span> <span class="n">polymorphism</span> <span class="n">to</span> <span class="n">convert</span> <span class="n">Integer</span> <span class="n">to</span> <span class="n">Float64</span>
  <span class="n">report</span><span class="p">(</span><span class="n">vec2FromIntegers</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>出力:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="mf">3.141</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="mf">2.718</span><span class="p">}</span>
<span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="o">-</span><span class="mi">7</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="temporary-initialization">
<span id="klpg-constructor-invocation-temporary"></span><h4>一時初期化<a class="headerlink" href="#temporary-initialization" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>もし関数呼び出し時の関数名が型の名前と同じだった場合、与えられた引数を取るコンストラクタは、指定された型の一時的な値を作るために呼び出されます。もし、呼び出し時に渡された引数とぴったりマッチするコンストラクタがない場合は、呼び出すべきコンストラクタを選ぶために、ベスト・マッチ・ポリモーフィズムルールが適用されます。これを <em class="dfn">temporary initialization</em> と呼びます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">KLはコンストラクションとキャスティングを区別しません。異なる型への値のキャストは、（与えられた値から適切なコンストラクタを選んで使用することにより、）与えられた型の一時的な値を生成して、それを初期化するのと同じです。</p>
</div>
<p>例：</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">struct</span> <span class="nx">Vec2</span> <span class="p">{</span>
  <span class="kr">Float64</span> <span class="nx">x</span><span class="p">;</span>
  <span class="kr">Float64</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Construct from two scalars</span>
<span class="kd">function</span> <span class="nx">Vec2</span><span class="p">(</span><span class="kr">Float64</span> <span class="nx">x</span><span class="p">,</span> <span class="kr">Float64</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">Vec2</span><span class="p">(</span><span class="mf">3.141</span><span class="p">,</span> <span class="mf">2.718</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">Vec2</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">));</span>  <span class="c1">// Uses best-match polymorphism to convert Integer to Float64</span>
<span class="p">}</span>
</pre></div>
</div>
<p>出力:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="mf">3.141</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="mf">2.718</span><span class="p">}</span>
<span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="o">-</span><span class="mi">7</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="base-type-constructors-inheritance">
<h4>基底型のコンストラクタ（継承）<a class="headerlink" href="#base-type-constructors-inheritance" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.13.0 で追加.</span></p>
</div>
<p>特殊化された構造体またはオブジェクト型が基底型から <span class="xref std std-ref">inherits</span> するとき、特殊化された型のコンストラクタより前に、基底型のデフォルトコンストラクタが暗黙的に呼び出されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>現時点での制約として、特殊化した型のコンストラクタから、引数を伴って基底クラスのコンストラクタを呼び出すことはできません。次の例では、この問題の回避策として <cite>initialize</cite> メソッドを使っています。</p>
<div class="last highlight-kl"><div class="highlight"><pre><span></span><span class="kr">object</span> <span class="nx">Shape</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">centerX</span><span class="p">,</span> <span class="nx">centerY</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">inline</span> <span class="nx">Shape</span><span class="p">(</span> <span class="kr">Float32</span> <span class="nx">centerX</span><span class="p">,</span> <span class="kr">Float32</span> <span class="nx">centerY</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">initialize</span><span class="p">(</span> <span class="nx">centerX</span><span class="p">,</span> <span class="nx">centerY</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// \internal</span>
<span class="kd">inline</span> <span class="nx">Shape</span><span class="p">.</span><span class="nx">initialize</span><span class="o">!</span><span class="p">(</span> <span class="kr">Float32</span> <span class="nx">centerX</span><span class="p">,</span> <span class="kr">Float32</span> <span class="nx">centerY</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">centerX</span> <span class="o">=</span> <span class="nx">centerX</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">centerY</span> <span class="o">=</span> <span class="nx">centerY</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">object</span> <span class="nx">Circle</span> <span class="o">:</span> <span class="nx">Shape</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">radius</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">inline</span> <span class="nx">Circle</span><span class="p">(</span> <span class="kr">Float32</span> <span class="nx">centerX</span><span class="p">,</span> <span class="kr">Float32</span> <span class="nx">centerY</span><span class="p">,</span> <span class="kr">Float32</span> <span class="nx">radius</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">initialize</span><span class="p">(</span> <span class="nx">centerX</span><span class="p">,</span> <span class="nx">centerY</span> <span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Circle</span> <span class="nx">c</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span> <span class="nx">c</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{centerX:+1.0,centerY:+2.0,radius:+3.0}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="destructors">
<span id="klpg-destructor"></span><span id="index-9"></span><h2>デストラクタ<a class="headerlink" href="#destructors" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>デストラクタは変数がスコープの外に出て、そのリソースを解放するときに呼ばれる関数です。デストラクタは型の名前の前に <code class="docutils literal"><span class="pre">~</span></code> （チルダ）をつけ、また関数として使われるように宣言されます。デストラクタはどのようなパラメーターも取らず、戻り値も返しません。デストラクタは値が解放される前に呼ばれます。したがって、そのメンバーにはまだアクセスすることができます。デストラクタの本体では、そうしたメンバーの値には <code class="docutils literal"><span class="pre">this</span></code> キーワードを使って参照します。また、それらの値は入出力可能なので、つまりはデストラクタで書き換え可能です。</p>
<p>デストラクタの使用例</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">struct</span> <span class="nx">MyType</span> <span class="p">{</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Empty constructor</span>
<span class="kd">function</span> <span class="nx">MyType</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;Creating MyType: this.s = &quot;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Destructor</span>
<span class="kd">function</span> <span class="o">~</span><span class="nx">MyType</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;Destroying MyType: this.s = &quot;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">MyType</span> <span class="nx">myType</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>出力:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Creating</span> <span class="n">MyType</span><span class="p">:</span> <span class="n">this</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">foo</span>
<span class="n">Destroying</span> <span class="n">MyType</span><span class="p">:</span> <span class="n">this</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">foo</span>
</pre></div>
</div>
<p>関数のように、デストラクタはオプションとして <code class="docutils literal"><span class="pre">function</span></code> の代わりに <code class="docutils literal"><span class="pre">inline</span></code> キーワードを使って定義できます。詳細は <a class="reference internal" href="#inline"><span class="std std-ref">Inline 関数,メソッド</span></a> を見てください。</p>
<p>特殊化された構造体またはオブジェクト型が基底型を継承するとき、基底型のデストラクタは特殊化した後に呼び出されます。</p>
</div>
<div class="section" id="methods">
<span id="index-10"></span><span id="id6"></span><h2>メソッド<a class="headerlink" href="#methods" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><em class="dfn">method</em> はユーザー定義の構造体上で操作を行う関数です。メソッドは、普通の関数呼び出しよりもわずかに異なる（そしてより示唆的な）文法を使います。これは、メソッドコールがユーザー定義の構造体を型として持つ値に強く結びつけられていることによります。</p>
<div class="section" id="method-definitions">
<span id="index-11"></span><h3>メソッド定義<a class="headerlink" href="#method-definitions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>もし <code class="samp docutils literal"><em><span class="pre">Type</span></em></code> が構造体かエイリアスだった場合、 <code class="samp docutils literal"><em><span class="pre">methodName</span></em></code> と名付けられたメソッドは次の文法を使うことで、型に加えることができます。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="c1">// A method that returns a value</span>
<span class="kd">function</span> <span class="o">&lt;</span><span class="nx">ReturnType</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nx">Type</span><span class="o">&gt;</span><span class="p">.</span><span class="o">&lt;</span><span class="nx">methodName</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">parameter</span> <span class="nx">list</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">&lt;</span><span class="nx">method</span> <span class="nx">body</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="c1">// A method that does not return a value</span>
<span class="kd">function</span> <span class="o">&lt;</span><span class="nx">Type</span><span class="o">&gt;</span><span class="p">.</span><span class="o">&lt;</span><span class="nx">methodName</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">parameter</span> <span class="nx">list</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">&lt;</span><span class="nx">method</span> <span class="nx">body</span><span class="o">&gt;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>メソッド本体内で、 <code class="docutils literal"><span class="pre">this</span></code> はそのメソッドが呼ばれた値を参照します。<code class="docutils literal"><span class="pre">this</span></code> は、もしそのメソッドが値を返すのであれば、読み込みのみ可能です。もし、値を返さないのであれば、読み書きが可能です。</p>
<p>関数のように、メソッドはオプションとして <code class="docutils literal"><span class="pre">function</span></code> キーワードの代わりに <code class="docutils literal"><span class="pre">inline</span></code> を使って定義することができます。詳細は <a class="reference internal" href="#inline"><span class="std std-ref">Inline 関数,メソッド</span></a> をご覧ください。</p>
</div>
<div class="section" id="method-invocation">
<span id="index-12"></span><h3>メソッド呼び出し<a class="headerlink" href="#method-invocation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>もし <code class="samp docutils literal"><em><span class="pre">value</span></em></code> が <code class="samp docutils literal"><em><span class="pre">Type</span></em></code> 型の値であるなら、そのメソッド <code class="samp docutils literal"><em><span class="pre">methodName</span></em></code> は <code class="samp docutils literal"><em><span class="pre">value</span></em><span class="pre">.</span><em><span class="pre">methodName</span></em><span class="pre">(</span><em><span class="pre">argument</span> <span class="pre">list</span></em><span class="pre">)</span></code> という書き方を使って、 <code class="samp docutils literal"><em><span class="pre">value</span></em></code> 上で呼び出すことができます。</p>
<p>同名な関数を複数を置くことが可能であるので、指定されたある型は同名の複数の関数を持つことが可能です。どのメソッドを実際に呼び出すかを決定するには、通常の最適ルールが適用されます。</p>
<p>メソッド定義と呼び出しの例</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Method Definition and Invocation</span>
<span class="cm">*/</span>

<span class="kr">struct</span> <span class="nx">MyType</span> <span class="p">{</span>
  <span class="kr">Integer</span> <span class="nx">a</span><span class="p">;</span>
  <span class="kr">Float32</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Add method desc to MyType</span>
<span class="kd">function</span> <span class="kr">String</span> <span class="nx">MyType</span><span class="p">.</span><span class="nx">desc</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s2">&quot;a:&quot;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">+</span> <span class="s2">&quot;; b:&quot;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">MyType</span> <span class="nx">t</span><span class="p">;</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
  <span class="c1">// Reports &#39;a:1; b:3.14&#39;</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">desc</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">a:1; b:+3.14</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="methods-taking-read-only-or-read-write-values-for-this">
<span id="klpg-method-this-type"></span><h3>メソッドにおける <code class="docutils literal"><span class="pre">this</span></code> の Read-Only・Read-Write な値としての扱い<a class="headerlink" href="#methods-taking-read-only-or-read-write-values-for-this" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.12.0 で変更: </span><code class="code docutils literal"><span class="pre">this</span></code> は今後、以下の条件 ―メソッド定義においてメソッド名の後ろに明示的に  <code class="code docutils literal"><span class="pre">!</span></code>  を後置しない限り― 以外であれば常にディフォルトで read-only となります。もはやディフォルトはメソッドが値を返すかどうかに依存することはありません。</p>
</div>
<p><code class="code docutils literal"><span class="pre">this</span></code> が read-only か read-write (コンパイラ用語では, r-value あるいは l-value) かどうかは、メソッド単位で制御することができます。ディフォルトでは <code class="code docutils literal"><span class="pre">this</span></code> は read-only; メソッド名に <code class="docutils literal"><span class="pre">!</span></code> (エクスクラメーションびっくりマーク) を接尾すると read-write; メソッド名に <code class="code docutils literal"><span class="pre">?</span></code> (クエスチョンマーク)を接尾すると明示的な read-only となります。</p>
<p>メソッド内の  <code class="code docutils literal"><span class="pre">this</span></code> の明示的な read-only・read-write 使用例</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Explicit read-only or read-write &quot;this&quot; in methods</span>
<span class="cm">*/</span>

<span class="kr">struct</span> <span class="nx">Vec2</span> <span class="p">{</span>
  <span class="kr">Float64</span> <span class="nx">x</span><span class="p">;</span>
  <span class="kr">Float64</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">Vec2</span><span class="p">(</span><span class="k">in</span> <span class="kr">Float64</span> <span class="nx">x</span><span class="p">,</span> <span class="k">in</span> <span class="kr">Float64</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Explicitly make &#39;this&#39; read-only</span>
<span class="kd">function</span> <span class="nx">Vec2</span><span class="p">.</span><span class="nx">getComponents</span><span class="o">?</span><span class="p">(</span><span class="k">io</span> <span class="kr">Float64</span> <span class="nx">x</span><span class="p">,</span> <span class="k">io</span> <span class="kr">Float64</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
  <span class="nx">y</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="kr">Float64</span> <span class="nx">Vec2</span><span class="p">.</span><span class="nx">normSq</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="o">*</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="o">*</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="kr">Float64</span> <span class="nx">Vec2</span><span class="p">.</span><span class="nx">norm</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sqrt</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">normSq</span><span class="p">());</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Vec2</span><span class="p">.</span><span class="o">/=</span><span class="p">(</span><span class="k">in</span> <span class="kr">Float64</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">/=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">/=</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Explicitly make &#39;this&#39; read-write</span>
<span class="kd">function</span> <span class="kr">Float64</span> <span class="nx">Vec2</span><span class="p">.</span><span class="nx">normalizeAndReturnOldNorm</span><span class="o">!</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">Float64</span> <span class="nx">oldNorm</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">norm</span><span class="p">();</span>
  <span class="k">this</span> <span class="o">/=</span> <span class="nx">oldNorm</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">oldNorm</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Vec2</span> <span class="nx">vec2</span><span class="p">(</span><span class="mf">3.14</span><span class="p">,</span> <span class="mf">2.71</span><span class="p">);</span>

  <span class="kr">Float64</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">;</span>
  <span class="nx">vec2</span><span class="p">.</span><span class="nx">getComponents</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;vec2.getComponents: x=&quot;</span> <span class="o">+</span> <span class="nx">x</span> <span class="o">+</span> <span class="s2">&quot;, y=&quot;</span> <span class="o">+</span> <span class="nx">y</span><span class="p">);</span>

  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;vec2.normalizeAndReturnOldNorm returned &quot;</span> <span class="o">+</span> <span class="nx">vec2</span><span class="p">.</span><span class="nx">normalizeAndReturnOldNorm</span><span class="p">());</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;vec2 is now &quot;</span> <span class="o">+</span> <span class="nx">vec2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">vec2.getComponents: x=+3.14, y=+2.71</span>
<span class="cm">vec2.normalizeAndReturnOldNorm returned +4.147734321289154</span>
<span class="cm">vec2 is now {x:+0.757039809392627,y:+0.653368752692363}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="interface-methods-and-inheritance">
<span id="klpg-method-interface-inheritance"></span><h3>インターフェイスメソッドと継承<a class="headerlink" href="#interface-methods-and-inheritance" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.13.0 で追加.</span></p>
</div>
<p>KLコーダにとっては自明なことではありますが、インターフェイスメソッドの呼び出しメカニズムは通常のメソッドとは異なり、ゆえに特定の状況では特に注意を必要とします。</p>
<p>特殊化したオブジェクトは、 <span class="xref std std-ref">基底となるオブジェクト型</span> を継承することができます。この基底型がインタフェースを実装している場合、特殊化したオブジェクトではさらに同じインタフェースのメソッドを独自に実装することができます。このような場合では、インタフェースメソッドの呼び出しは常に特殊化したバージョンのメソッドが呼びだされます。（つまり特殊化したオブジェクトのメソッドが基底オブジェクトのメソッドを <cite>overrides</cite> した）これは常にこの通りになります。メソッド呼び出しが、関数コンテキストでおこなわれようと特殊化したオブジェクトのメソッドであろうと、基本オブジェクトのメソッドであろうと関係ありません。</p>
<p>ただし、特殊化したメソッドの実装において、基底の実装を呼び出す必要が有ることはよくあります。 <code class="samp docutils literal"><em><span class="pre">Type</span></em><span class="pre">.parent.</span><em><span class="pre">methodName</span></em></code> 記法により、特殊化クラスが基底のインタフェースメソッド実装を呼び出すことができます。以下のとおり:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">Described</span> <span class="p">{</span>
  <span class="kr">String</span> <span class="nx">describe</span><span class="p">();</span>
<span class="p">};</span>

<span class="kr">object</span> <span class="nx">Shape</span> <span class="o">:</span> <span class="nx">Described</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">centerX</span><span class="p">,</span> <span class="nx">centerY</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="kr">String</span> <span class="nx">Shape</span><span class="p">.</span><span class="nx">describe</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s2">&quot;Center: (&quot;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">centerX</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">centerY</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">object</span> <span class="nx">Circle</span> <span class="o">:</span> <span class="nx">Shape</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">radius</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">inline</span> <span class="nx">Circle</span><span class="p">.</span><span class="nx">setRadius</span><span class="o">!</span><span class="p">(</span> <span class="kr">Float32</span> <span class="nx">r</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="kr">String</span> <span class="nx">Circle</span><span class="p">.</span><span class="nx">describe</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Call Shape.describe and append to it</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">describe</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot; Radius: &quot;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Circle</span> <span class="nx">c</span><span class="p">();</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">centerX</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">centerY</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="nx">Described</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">c</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span> <span class="nx">d</span><span class="p">.</span><span class="nx">describe</span><span class="p">()</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">Center: (+1.0, +2.0) Radius: +3.0</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="access-to-methods">
<span id="klpg-methods-access"></span><h3>メソッドへのアクセス<a class="headerlink" href="#access-to-methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.15.0 で追加.</span></p>
</div>
<p>メソッドへのアクセスは <span class="xref std std-ref">メンバへのアクセス</span> 同様 <code class="docutils literal"><span class="pre">public</span></code>, <code class="docutils literal"><span class="pre">private</span></code>, <code class="docutils literal"><span class="pre">protected</span></code> キーワードにより制御可能です:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Access to Methods</span>
<span class="cm">*/</span>

<span class="kr">interface</span> <span class="nx">Int</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="nx">int_priv</span><span class="p">();</span>
  <span class="k">protected</span> <span class="nx">int_prot</span><span class="p">();</span>
<span class="p">};</span>

<span class="kr">object</span> <span class="nx">A</span> <span class="o">:</span> <span class="nx">Int</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="k">public</span> <span class="nx">A</span><span class="p">.</span><span class="nx">a_pub</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">int_priv</span><span class="p">();</span> <span class="c1">// ok since A implements Int</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">int_prot</span><span class="p">();</span> <span class="c1">// ok since A implements Int</span>
<span class="p">}</span>

<span class="k">protected</span> <span class="nx">A</span><span class="p">.</span><span class="nx">a_prot</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">private</span> <span class="nx">A</span><span class="p">.</span><span class="nx">a_priv</span><span class="p">()</span> <span class="p">{}</span>

<span class="nx">A</span><span class="p">.</span><span class="nx">int_priv</span><span class="p">()</span> <span class="p">{}</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">int_prot</span><span class="p">()</span> <span class="p">{}</span>

<span class="kr">object</span> <span class="nx">B</span> <span class="o">:</span> <span class="nx">A</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="k">public</span> <span class="nx">A</span><span class="p">.</span><span class="nx">b_pub</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">int_priv</span><span class="p">();</span> <span class="c1">// error since int_priv is private</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">int_prot</span><span class="p">();</span> <span class="c1">// ok since B inherits A</span>
<span class="p">}</span>

<span class="k">protected</span> <span class="nx">B</span><span class="p">.</span><span class="nx">b_prot</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a_prot</span><span class="p">();</span> <span class="c1">// ok since B inherits A</span>
<span class="p">}</span>

<span class="k">private</span> <span class="nx">B</span><span class="p">.</span><span class="nx">b_priv</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a_priv</span><span class="p">();</span> <span class="c1">// error since a_priv is private</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nx">A</span> <span class="nx">a</span><span class="p">();</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">a_pub</span><span class="p">();</span> <span class="c1">// ok since a_pub is public</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">a_prot</span><span class="p">();</span> <span class="c1">// error since a_prot is protected</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">a_priv</span><span class="p">();</span> <span class="c1">// error since a_prot is private</span>

  <span class="nx">B</span> <span class="nx">b</span><span class="p">();</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">b_pub</span><span class="p">();</span> <span class="c1">// ok since a_pub is public</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">b_prot</span><span class="p">();</span> <span class="c1">// error since a_prot is protected</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">b_priv</span><span class="p">();</span> <span class="c1">// error since a_prot is private</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>
<span class="cm">(stdin):52:3: error: cannot access protected function A.a_prot?()</span>
<span class="cm">(stdin):53:3: error: cannot access private function A.a_priv?()</span>
<span class="cm">(stdin):57:3: error: cannot access protected function B.b_prot?()</span>
<span class="cm">(stdin):58:3: error: cannot access private function B.b_priv?()</span>
<span class="cm">(stdin):45:3: error: cannot access private function A.a_priv?()</span>


<span class="cm">*/</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="overloaded-operators">
<span id="index-13"></span><h2>演算子オーバロード<a class="headerlink" href="#overloaded-operators" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>KLでは独自のカスタム型（例えば <code class="docutils literal"><span class="pre">struct</span></code> ）用に２項演算子や、複合代入演算子をオーバロードすることができます。</p>
<p>関数とおなじく、演算子オーバロードも <code class="docutils literal"><span class="pre">inline</span></code> キーワードを  <code class="docutils literal"><span class="pre">function</span></code> の箇所に付して定義することも可能です。  <a class="reference internal" href="#inline"><span class="std std-ref">Inline 関数,メソッド</span></a> 参照</p>
<div class="section" id="binary-operator-overloads">
<span id="index-14"></span><h3>二項演算子のオーバロード<a class="headerlink" href="#binary-operator-overloads" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>二項演算子のオーバロードには以下の文法に従います:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Binary Operator Overloads</span>
<span class="cm">*/</span>

<span class="kr">struct</span> <span class="nx">MyType</span> <span class="p">{</span>
  <span class="kr">Integer</span> <span class="nx">a</span><span class="p">;</span>
  <span class="kr">Float32</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">MyType</span> <span class="o">+</span><span class="p">(</span><span class="nx">MyType</span> <span class="nx">lhs</span><span class="p">,</span> <span class="nx">MyType</span> <span class="nx">rhs</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">MyType</span> <span class="nx">result</span><span class="p">;</span>
  <span class="nx">result</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">lhs</span><span class="p">.</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">rhs</span><span class="p">.</span><span class="nx">a</span><span class="p">;</span>
  <span class="nx">result</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">lhs</span><span class="p">.</span><span class="nx">b</span> <span class="o">+</span> <span class="nx">rhs</span><span class="p">.</span><span class="nx">b</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">MyType</span> <span class="nx">t1</span><span class="p">;</span> <span class="nx">t1</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="nx">t1</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span> <span class="nb">report</span><span class="p">(</span><span class="nx">t1</span><span class="p">);</span>
  <span class="nx">MyType</span> <span class="nx">t2</span><span class="p">;</span> <span class="nx">t2</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="nx">t2</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mf">2.72</span><span class="p">;</span> <span class="nb">report</span><span class="p">(</span><span class="nx">t2</span><span class="p">);</span>
  <span class="nx">MyType</span> <span class="nx">t3</span> <span class="o">=</span> <span class="nx">t1</span> <span class="o">+</span> <span class="nx">t2</span><span class="p">;</span> <span class="nb">report</span><span class="p">(</span><span class="nx">t3</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{a:42,b:+3.14}</span>
<span class="cm">{a:7,b:+2.72}</span>
<span class="cm">{a:49,b:+5.86}</span>

<span class="cm">*/</span>
</pre></div>
</div>
<p>どの二項演算子、算術演算子 (<code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">%</span></code>), ビット演算子 (<code class="docutils literal"><span class="pre">|</span></code>, <code class="docutils literal"><span class="pre">&amp;</span></code>, <code class="docutils literal"><span class="pre">^</span></code>, <code class="docutils literal"><span class="pre">&lt;&lt;</span></code> and <code class="docutils literal"><span class="pre">&gt;&gt;</span></code>) 比較演算子 (<code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">!=</span></code>, <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code> and <code class="docutils literal"><span class="pre">&gt;=</span></code>) もオーバロード可能です。</p>
<p>二項演算子のオーバロードには以下の制限があります:</p>
<ul class="simple">
<li><p class="first">パラメータを『２つ』とります。この２つのパラメータは、どのような型でも可能であり、互いに異なる型でもよいですが、双方 input-only のパラメータである必要があります。</p>
</li>
<li><p class="first">値を返します。ただし返り値の型は問いません。</p>
</li>
</ul>
</div>
<div class="section" id="unary-operator-overloads">
<span id="klpg-unary-op-overloads"></span><span id="index-15"></span><h3>単項演算子のオーバロード<a class="headerlink" href="#unary-operator-overloads" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.12.0 で追加: </span>単項演算子のオーバロード</p>
</div>
<p>単項演算子のオーバーロードは以下の文法に従います:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Binary Operator Overloads</span>
<span class="cm">*/</span>

<span class="kr">struct</span> <span class="nx">MyType</span> <span class="p">{</span>
  <span class="kr">Integer</span> <span class="nx">a</span><span class="p">;</span>
  <span class="kr">Float32</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">MyType</span> <span class="o">-</span><span class="nx">MyType</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">MyType</span> <span class="nx">result</span><span class="p">;</span>
  <span class="nx">result</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="o">-</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">;</span>
  <span class="nx">result</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="o">-</span><span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">MyType</span> <span class="nx">t1</span><span class="p">;</span> <span class="nx">t1</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="nx">t1</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span> <span class="nb">report</span><span class="p">(</span><span class="o">-</span><span class="nx">t1</span><span class="p">);</span>
  <span class="nx">MyType</span> <span class="nx">t2</span><span class="p">;</span> <span class="nx">t2</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="nx">t2</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mf">2.72</span><span class="p">;</span> <span class="nb">report</span><span class="p">(</span><span class="o">-</span><span class="nx">t2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{a:-42,b:-3.14}</span>
<span class="cm">{a:-7,b:-2.72}</span>

<span class="cm">*/</span>
</pre></div>
</div>
<p>単項演算子は  <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">~</span></code> のみオーバロード可能です。</p>
<p>単項演算子のオーバーロードには以下の制限があります:</p>
<ul class="simple">
<li><p class="first">値を返します。ただし返り値の型は問いません。</p>
</li>
</ul>
</div>
<div class="section" id="direct-assignment-overloads">
<span id="overloading-direct-ass-op"></span><span id="index-16"></span><h3>直接代入のオーバロード<a class="headerlink" href="#direct-assignment-overloads" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>KL provides a default direct assignment for custom types which simply assigns each of the members.  However, it is also possible to provide an overload for the direct assignment operator as shown in the example below:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Direct Assignment Overload</span>
<span class="cm">*/</span>

<span class="kr">struct</span> <span class="nx">A</span> <span class="p">{</span>
  <span class="kr">UInt32</span> <span class="nx">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">A</span><span class="p">(</span><span class="kr">UInt32</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">A</span><span class="p">.</span><span class="o">=</span><span class="p">(</span><span class="nx">A</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;Performing assignment&quot;</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">a</span><span class="p">.</span><span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">A</span> <span class="nx">a1</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span> <span class="nx">a2</span><span class="p">(</span><span class="mi">56</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;Before: a1 = &quot;</span> <span class="o">+</span> <span class="nx">a1</span> <span class="o">+</span> <span class="s2">&quot;, a2 = &quot;</span> <span class="o">+</span> <span class="nx">a2</span><span class="p">);</span>
  <span class="nx">a1</span> <span class="o">=</span> <span class="nx">a2</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;After: a1 = &quot;</span> <span class="o">+</span> <span class="nx">a1</span> <span class="o">+</span> <span class="s2">&quot;, a2 = &quot;</span> <span class="o">+</span> <span class="nx">a2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">Before: a1 = {a:42}, a2 = {a:56}</span>
<span class="cm">Performing assignment</span>
<span class="cm">After: a1 = {a:112}, a2 = {a:56}</span>

<span class="cm">*/</span>
</pre></div>
</div>
<p>複合代入演算子のオーバロードは以下の制限に従います:</p>
<ul class="simple">
<li><p class="first">『１つ』パラメータを取ります。このパラメータはどのような型でも構いません。パラメータは input-only である必要があります。</p>
</li>
<li><p class="first">値を返しません。</p>
</li>
</ul>
</div>
<div class="section" id="compound-assignment-overloads">
<span id="overloading-compound-ass-ops"></span><h3>複合代入演算子のオーバロード<a class="headerlink" href="#compound-assignment-overloads" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>KLでは、カスタム型にディフォルトの直接代入演算子を提供します。代入の際は単純にそれぞれのメンバを代入します。 <em class="dfn">compound assignment</em> 演算子についても同様に提供します (例 <code class="docutils literal"><span class="pre">+=</span></code>, <code class="docutils literal"><span class="pre">-=</span></code>, <code class="docutils literal"><span class="pre">*=</span></code>, <code class="docutils literal"><span class="pre">/=</span></code>, <code class="docutils literal"><span class="pre">%=</span></code>, <code class="docutils literal"><span class="pre">|=</span></code>, <code class="docutils literal"><span class="pre">&amp;=</span></code>, <code class="docutils literal"><span class="pre">^=</span></code>, <code class="docutils literal"><span class="pre">&lt;&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;&gt;=</span></code>) 関連する二項演算子 ―利用可能であれば代入も― を作成します。</p>
<p>ただし、複号代入演算子のオーバロードをすることも可能です。以下に例を示します:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">Type</span> <span class="p">{</span>
  <span class="n">Integer</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">Float32</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">function</span> <span class="n">Type</span><span class="o">.+=</span><span class="p">(</span><span class="n">Type</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">this</span><span class="o">.</span><span class="n">a</span> <span class="o">+=</span> <span class="n">that</span><span class="o">.</span><span class="n">a</span><span class="p">;</span>
  <span class="n">this</span><span class="o">.</span><span class="n">b</span> <span class="o">+=</span> <span class="n">that</span><span class="o">.</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">operator</span> <span class="n">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Type</span> <span class="n">t1</span><span class="p">;</span> <span class="n">t1</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="n">t1</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span> <span class="n">report</span><span class="p">(</span><span class="s2">&quot;t1 is &quot;</span> <span class="o">+</span> <span class="n">t1</span><span class="p">);</span>
  <span class="n">Type</span> <span class="n">t2</span><span class="p">;</span> <span class="n">t2</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="n">t2</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mf">2.72</span><span class="p">;</span> <span class="n">report</span><span class="p">(</span><span class="s2">&quot;t2 is &quot;</span> <span class="o">+</span> <span class="n">t2</span><span class="p">);</span>
  <span class="n">t1</span> <span class="o">+=</span> <span class="n">t2</span><span class="p">;</span> <span class="n">report</span><span class="p">(</span><span class="s2">&quot;t1 is now &quot;</span> <span class="o">+</span> <span class="n">t1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以下の出力を得ます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">t1</span> <span class="ow">is</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="n">b</span><span class="p">:</span><span class="mf">3.14</span><span class="p">}</span>
<span class="n">t2</span> <span class="ow">is</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span><span class="n">b</span><span class="p">:</span><span class="mf">2.72</span><span class="p">}</span>
<span class="n">t1</span> <span class="ow">is</span> <span class="n">now</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span><span class="mi">49</span><span class="p">,</span><span class="n">b</span><span class="p">:</span><span class="mf">5.86</span><span class="p">}</span>
</pre></div>
</div>
<p>複合代入演算子のオーバロードは以下の制限に従います:</p>
<ul class="simple">
<li><p class="first">『１つ』パラメータを取ります。このパラメータはどのような型でも構いません。パラメータは input-only である必要があります。</p>
</li>
<li><p class="first">値を返しません。</p>
</li>
</ul>
</div>
</div>
<div class="section" id="inline-functions-and-methods">
<span id="inline"></span><span id="index-17"></span><h2>Inline 関数,メソッド<a class="headerlink" href="#inline-functions-and-methods" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>関数、メソッドなど（オペレータを除く）は宣言の際にオプションとして、 <code class="docutils literal"><span class="pre">inline</span></code> キーワードを <code class="docutils literal"><span class="pre">function</span></code> キーワードの箇所に付すことができます。 <code class="docutils literal"><span class="pre">inline</span></code> キーワードにより、KLは使用に際し関数定義を inline 化しようとします。 <code class="docutils literal"><span class="pre">inline</span></code> は通常、小さな関数に対してのみ使用します。これにより実行時のパフォーマンスの改善を見込めます。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">inline</span> <span class="n">Integer</span> <span class="n">add</span><span class="p">(</span><span class="n">Integer</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Integer</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">lhs</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="built-in-functions-and-methods">
<span id="index-18"></span><h2>組み込み関数・メソッド<a class="headerlink" href="#built-in-functions-and-methods" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>KL にはいくつかの組み込み関数・メソッドがあり、KLプログラム全てで利用可能です。</p>
<div class="section" id="debugging-functions">
<h3>デバッグのための関数<a class="headerlink" href="#debugging-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="function">
<dt id="report">
<em class="property">function </em><code class="descname">report</code><span class="sig-paren">(</span><em>String message</em><span class="sig-paren">)</span><a class="headerlink" href="#report" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージを出力します。KLが送った場所へ出力します;  Fabric Engine ― あるいは KL Toolコマンドラインから使用されたのであれば、出力は標準エラー・標準出力へとそれぞれ送られます。送信時に改行がメッセージに追記されます。</p>
<p>Fabric Engine では report関数は、主にデバッグのため使われ、対してKL Tool では Report関数は一般的な出力のために使われます。</p>
</dd></dl>

<dl class="function">
<dt id="dumpstack">
<em class="property">function </em><code class="descname">dumpstack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dumpstack" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified">バージョン 1.13.0 で追加.</span></p>
</div>
</dd></dl>

<p>KL関数のコールスタックを出力します。KLファイルの名前・行位番号を含む呼び出し位置を含みます。以下にKLコード例を示します。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">func2</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">dumpstack</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">function</span> <span class="n">func1</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">func2</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">operator</span> <span class="n">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">func1</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以下の出力となります:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="n">function</span><span class="o">.</span><span class="n">func2</span><span class="p">()</span> <span class="n">call</span><span class="o">.</span><span class="n">kl</span><span class="p">:</span><span class="mi">4</span>
<span class="mi">2</span> <span class="n">function</span><span class="o">.</span><span class="n">func1</span><span class="p">()</span> <span class="n">call</span><span class="o">.</span><span class="n">kl</span><span class="p">:</span><span class="mi">9</span>
<span class="mi">3</span> <span class="n">operator</span><span class="o">.</span><span class="n">entry</span><span class="p">()</span> <span class="n">call</span><span class="o">.</span><span class="n">kl</span><span class="p">:</span><span class="mi">14</span>
<span class="mi">4</span> <span class="n">kl</span><span class="o">.</span><span class="n">internal</span><span class="o">.</span><span class="n">entry</span><span class="o">.</span><span class="n">stub</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="error-status-functions">
<h3>エラーステータスの関数<a class="headerlink" href="#error-status-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>KLは、エラーステータスのコンテキストを保持します。このステータスは組み込み関数により、設定(set)・照会(query)・リセットが可能です。このステータスは、KLの評価コンテキストとスレッドに制限されます。いくつかのKLでの操作 ――たとえば整数のゼロ除算, 配列の境界外アクセス(境界チェックを有効にしKLを実行している場合)など、は内部で  <a class="reference internal" href="#setError" title="setError"><code class="xref kl kl-func docutils literal"><span class="pre">setError</span></code></a> を呼びます。 Fabric Engine エクステンションは通常、操作の失敗を報告するためエラーステータスを設定します。</p>
<dl class="function">
<dt id="getLastError">
<em class="property">function </em><em class="property">String </em><code class="descname">getLastError</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#getLastError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>設定されている最終エラーステータスを取得します。</p>
</dd></dl>

<dl class="function">
<dt id="clearLastError">
<em class="property">function </em><code class="descname">clearLastError</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clearLastError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最終エラーステータスをリセットします。</p>
</dd></dl>

<dl class="function">
<dt id="setError">
<em class="property">function </em><code class="descname">setError</code><span class="sig-paren">(</span><em>String status</em><span class="sig-paren">)</span><a class="headerlink" href="#setError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しいエラーステータスを設定し、 <a class="reference internal" href="#report" title="report"><code class="xref kl kl-func docutils literal"><span class="pre">report</span></code></a> メカニズムを利用しレポートします。</p>
</dd></dl>

</div>
<div class="section" id="integer-numerical-functions">
<span id="id7"></span><h3>整数の数値演算関数<a class="headerlink" href="#integer-numerical-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>KLは、いくつかの整数関数をサポートします。整数式を扱う際に役立ちます。これら各関数には、それぞれの数値型 (<code class="docutils literal"><span class="pre">UInt8</span></code>, <code class="docutils literal"><span class="pre">SInt8</span></code>; <code class="docutils literal"><span class="pre">UInt16</span></code>, <code class="docutils literal"><span class="pre">SInt16</span></code>; <code class="docutils literal"><span class="pre">UInt32</span></code>, <code class="docutils literal"><span class="pre">SInt32</span></code>; <code class="docutils literal"><span class="pre">UInt64</span></code>, <code class="docutils literal"><span class="pre">SInt64</span></code>)のバージョンがあります。実際にどの関数が呼ばれるかは、ポリモーフィズムのベストマッチルールに従い選ばれます。  <a class="reference internal" href="#polymorphism"><span class="std std-ref">ポリモーフィズム</span></a> 参照</p>
<dl class="function">
<dt id="abs">
<em class="property">function </em><em class="property">&lt;SignedIntegerType&gt; </em><code class="descname">abs</code><span class="sig-paren">(</span><em>&lt;IntegerType&gt; n</em><span class="sig-paren">)</span><a class="headerlink" href="#abs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数の値の整数の絶対値を返します。</p>
<p>引数「 <code class="docutils literal"><span class="pre">n</span></code> 」の型によらず、返り値の型は符号付きとなり、符号付き整数として解釈される <code class="docutils literal"><span class="pre">n</span></code> の絶対値を返します。これによって <code class="docutils literal"><span class="pre">abs</span></code> 関数を、異なる符号なし整数同士を式に対して使用する（例:  <code class="docutils literal"><span class="pre">abs(Size(offset)-Size(index))</span></code> ）ことができます。</p>
</dd></dl>

</div>
<div class="section" id="floating-point-numerical-functions">
<span id="floatingpoint-numerical-functions"></span><h3>浮動小数点数の数値演算関数<a class="headerlink" href="#floating-point-numerical-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>KLは、C言語由来の「標準ライブラリ」より浮動小数点数の数値演算関数を多数サポートします。どの関数も <code class="docutils literal"><span class="pre">Float32</span></code> あるいは <code class="docutils literal"><span class="pre">Float64</span></code> のパラメータ（複数可）をとるバージョンが存在します。実際にどの関数が呼ばれるかは、ポリモーフィズムのベストマッチルールに従い選ばれます。  <a class="reference internal" href="#polymorphism"><span class="std std-ref">ポリモーフィズム</span></a>.</p>
<div class="section" id="trigonometric-functions">
<span id="id8"></span><h4>三角関数<a class="headerlink" href="#trigonometric-functions" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>C言語の標準ライブラリ同様、全ての三角関数は、引数と返り値ににラジアンを(それぞれ適切な箇所に)使用します。</p>
<dl class="function">
<dt id="sin">
<em class="property">function </em><em class="property">Float32 </em><code class="descname">sin</code><span class="sig-paren">(</span><em>Float32 x</em><span class="sig-paren">)</span><a class="headerlink" href="#sin" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">sin</code><span class="sig-paren">(</span><em>Float64 x</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><em><span class="pre">x</span></em></code> の角度の正弦（サイン）を返します。 <code class="samp docutils literal"><em><span class="pre">x</span></em></code> の単位はラジアンです。</p>
</dd></dl>

<dl class="function">
<dt id="cos">
<em class="property">function </em><em class="property">Float32 </em><code class="descname">cos</code><span class="sig-paren">(</span><em>Float32 x</em><span class="sig-paren">)</span><a class="headerlink" href="#cos" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">cos</code><span class="sig-paren">(</span><em>Float64 x</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><em><span class="pre">x</span></em></code> の角度の余弦(コサイン)を返します。 <code class="samp docutils literal"><em><span class="pre">x</span></em></code> の単位はラジアンです。</p>
</dd></dl>

<dl class="function">
<dt id="tan">
<em class="property">function </em><em class="property">Float32 </em><code class="descname">tan</code><span class="sig-paren">(</span><em>Float32 x</em><span class="sig-paren">)</span><a class="headerlink" href="#tan" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">tan</code><span class="sig-paren">(</span><em>Float64 x</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><em><span class="pre">x</span></em></code> の角度の正接(タンジェント)を返します。 <code class="samp docutils literal"><em><span class="pre">x</span></em></code> の単位はラジアンです。</p>
</dd></dl>

<dl class="function">
<dt id="asin">
<em class="property">function </em><em class="property">Float32 </em><code class="descname">asin</code><span class="sig-paren">(</span><em>Float32 x</em><span class="sig-paren">)</span><a class="headerlink" href="#asin" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">asin</code><span class="sig-paren">(</span><em>Float64 x</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><em><span class="pre">x</span></em></code> の逆正弦(アークサイン)を返します。返り値の単位はラジアンです。</p>
</dd></dl>

<dl class="function">
<dt id="acos">
<em class="property">function </em><em class="property">Float32 </em><code class="descname">acos</code><span class="sig-paren">(</span><em>Float32 x</em><span class="sig-paren">)</span><a class="headerlink" href="#acos" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">acos</code><span class="sig-paren">(</span><em>Float64 x</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><em><span class="pre">x</span></em></code> の逆余弦(アークコサイン)を返します。返り値の単位はラジアンです。</p>
</dd></dl>

<dl class="function">
<dt id="atan">
<em class="property">function </em><em class="property">Float32 </em><code class="descname">atan</code><span class="sig-paren">(</span><em>Float32 x</em><span class="sig-paren">)</span><a class="headerlink" href="#atan" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">atan</code><span class="sig-paren">(</span><em>Float64 x</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><em><span class="pre">x</span></em></code> の逆正接(アークコタンジェント)を返します。返り値の単位はラジアンです。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">この関数は巨大な <code class="samp docutils literal"><em><span class="pre">x</span></em></code> では機能しません。 <span class="math">\((-\pi/2,\pi/2)\)</span> の範囲でのみ値を返します。範囲外のものは <a class="reference internal" href="#atan2" title="atan2"><code class="xref kl kl-func docutils literal"><span class="pre">atan2</span></code></a> をかわりに使用します。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="atan2">
<em class="property">function </em><em class="property">Float32 </em><code class="descname">atan2</code><span class="sig-paren">(</span><em>Float32 y</em>, <em>Float32 x</em><span class="sig-paren">)</span><a class="headerlink" href="#atan2" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">atan2</code><span class="sig-paren">(</span><em>Float64 y</em>, <em>Float64 x</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><em><span class="pre">y</span></em><span class="pre">/</span><em><span class="pre">x</span></em></code> の逆正接(アークタンジェント)をラジアンで返します; 返り値の範囲は <span class="math">\((-\pi,\pi)\)</span> になります。</p>
</dd></dl>

</div>
<div class="section" id="exponential-and-logarithmic-functions">
<span id="id9"></span><h4>指数・対数関数<a class="headerlink" href="#exponential-and-logarithmic-functions" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="function">
<dt id="pow">
<em class="property">function </em><em class="property">Float32 </em><code class="descname">pow</code><span class="sig-paren">(</span><em>Float32 x</em>, <em>Float32 y</em><span class="sig-paren">)</span><a class="headerlink" href="#pow" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">pow</code><span class="sig-paren">(</span><em>Float64 x</em>, <em>Float64 y</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><em><span class="pre">x</span></em></code> の <code class="samp docutils literal"><em><span class="pre">y</span></em></code> 乗の値を返します。</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">Float32 </em><code class="descname">pow</code><span class="sig-paren">(</span><em>Float32 x</em>, <em>&lt;IntegerType&gt; y</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">pow</code><span class="sig-paren">(</span><em>Float64 x</em>, <em>&lt;IntegerType&gt; y</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><em><span class="pre">x</span></em></code> の <code class="samp docutils literal"><em><span class="pre">y</span></em></code> 乗の値を返します。 <code class="samp docutils literal"><em><span class="pre">y</span></em></code> は整数です。高速化のため２のべき乗を使用し、とくに <code class="samp docutils literal"><em><span class="pre">y</span></em></code> が定数な整数である場合、固定操作に展開されます。</p>
</dd></dl>

<dl class="function">
<dt id="exp">
<em class="property">function </em><em class="property">Float32 </em><code class="descname">exp</code><span class="sig-paren">(</span><em>Float32 x</em><span class="sig-paren">)</span><a class="headerlink" href="#exp" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">exp</code><span class="sig-paren">(</span><em>Float64 x</em><span class="sig-paren">)</span></dt>
<dd><p><span class="math">\(e\)</span> の <code class="samp docutils literal"><em><span class="pre">x</span></em></code> 乗の値を返します。 <span class="math">\(e\)</span> は自然対数の底です (近似値は 2.7182818...)</p>
</dd></dl>

<dl class="function">
<dt id="log">
<em class="property">function </em><em class="property">Float32 </em><code class="descname">log</code><span class="sig-paren">(</span><em>Float32 x</em><span class="sig-paren">)</span><a class="headerlink" href="#log" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">log</code><span class="sig-paren">(</span><em>Float64 x</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><em><span class="pre">x</span></em></code> の自然対数を返します（底は <span class="math">\(e\)</span> ）</p>
</dd></dl>

<dl class="function">
<dt id="log10">
<em class="property">function </em><em class="property">Float32 </em><code class="descname">log10</code><span class="sig-paren">(</span><em>Float32 x</em><span class="sig-paren">)</span><a class="headerlink" href="#log10" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">log10</code><span class="sig-paren">(</span><em>Float64 x</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><em><span class="pre">x</span></em></code> の10を底とした対数(常用対数)を返します。</p>
</dd></dl>

</div>
<div class="section" id="non-transcendental-functions">
<span id="non-transcendental-functions-functions"></span><h4>非超越関数<a class="headerlink" href="#non-transcendental-functions" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="function">
<dt>
<em class="property">function </em><em class="property">Float32 </em><code class="descname">abs</code><span class="sig-paren">(</span><em>Float32 x</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">abs</code><span class="sig-paren">(</span><em>Float64 x</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><em><span class="pre">x</span></em></code> の絶対値を返します。</p>
</dd></dl>

<dl class="function">
<dt id="round">
<em class="property">function </em><em class="property">Float32 </em><code class="descname">round</code><span class="sig-paren">(</span><em>Float32 x</em><span class="sig-paren">)</span><a class="headerlink" href="#round" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">round</code><span class="sig-paren">(</span><em>Float64 x</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><em><span class="pre">x</span></em></code> に、最も近い整数(ゼロの小数部)に丸めた浮動小数点数の値を返します。</p>
</dd></dl>

<dl class="function">
<dt id="floor">
<em class="property">function </em><em class="property">Float32 </em><code class="descname">floor</code><span class="sig-paren">(</span><em>Float32 x</em><span class="sig-paren">)</span><a class="headerlink" href="#floor" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">floor</code><span class="sig-paren">(</span><em>Float64 x</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><em><span class="pre">x</span></em></code> と等しいか、<code class="samp docutils literal"><em><span class="pre">x</span></em></code> 以下の最も大きい整数を浮動小数点数で返します。</p>
</dd></dl>

<dl class="function">
<dt id="ceil">
<em class="property">function </em><em class="property">Float32 </em><code class="descname">ceil</code><span class="sig-paren">(</span><em>Float32 x</em><span class="sig-paren">)</span><a class="headerlink" href="#ceil" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">ceil</code><span class="sig-paren">(</span><em>Float64 x</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><em><span class="pre">x</span></em></code> と等しいか、<code class="samp docutils literal"><em><span class="pre">x</span></em></code> 以上の最も小さい整数を浮動小数点数で返します。</p>
</dd></dl>

</div>
<div class="section" id="category-functions">
<h4>カテゴリ関数<a class="headerlink" href="#category-functions" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="function">
<dt id="Float32.isReg">
<em class="property">function </em><em class="property">Boolean </em><code class="descclassname">Float32.</code><code class="descname">isReg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Float32.isReg" title="この定義へのパーマリンク">¶</a></dt>
<dt id="Float64.isReg">
<em class="property">function </em><em class="property">Boolean </em><code class="descclassname">Float64.</code><code class="descname">isReg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Float64.isReg" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>浮動小数点数が、通常の浮動小数点数である場合にのみ true を返します。つまり、infinite や NaN（非数）値でない場合です。</p>
</dd></dl>

<dl class="function">
<dt id="Float32.isInf">
<em class="property">function </em><em class="property">Boolean </em><code class="descclassname">Float32.</code><code class="descname">isInf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Float32.isInf" title="この定義へのパーマリンク">¶</a></dt>
<dt id="Float64.isInf">
<em class="property">function </em><em class="property">Boolean </em><code class="descclassname">Float64.</code><code class="descname">isInf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Float64.isInf" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>浮動小数点数が、infinite 浮動小数点数である場合にのみ true を返します。ただし NaN（非数）値チェックは行いません。必要であれば <a class="reference internal" href="#Float32.isNaN" title="Float32.isNaN"><code class="xref kl kl-method docutils literal"><span class="pre">Float32.isNaN()</span></code></a> を併用してください。</p>
</dd></dl>

<dl class="function">
<dt id="Float32.isNaN">
<em class="property">function </em><em class="property">Boolean </em><code class="descclassname">Float32.</code><code class="descname">isNaN</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Float32.isNaN" title="この定義へのパーマリンク">¶</a></dt>
<dt id="Float64.isNaN">
<em class="property">function </em><em class="property">Boolean </em><code class="descclassname">Float64.</code><code class="descname">isNaN</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Float64.isNaN" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>浮動小数点数が、非数（NaN)な浮動小数点数である場合にのみ true を返します。ただし infinite 値チェックは行いません。必要であれば <a class="reference internal" href="#Float32.isInf" title="Float32.isInf"><code class="xref kl kl-method docutils literal"><span class="pre">Float32.isInf()</span></code></a> を併用してください。</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">ある浮動小数点数  <code class="docutils literal"><span class="pre">x</span></code> について、 <code class="docutils literal"><span class="pre">!x.isReg()</span></code> は  <code class="docutils literal"><span class="pre">x.isInf()</span> <span class="pre">||</span> <span class="pre">x.isNaN()</span></code> と同等です</p>
</div>
</div>
</div>
<div class="section" id="vector-functions">
<span id="id10"></span><h3>ベクタ関数<a class="headerlink" href="#vector-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>KLは、大規模な <em class="dfn">vector functions</em> 一式そろえています。これらの関数は以下の構造ぶつについて自動的に使用可能となります； 構造体のメンバが ―全て同じ整数型である,あるいは全て同じ浮動小数点数型である；（つまりベクタを表現する構造体が通常そうであるように）KLコンパイラは、実行中のアーキテクチャに最適なベクタ固有の操作となるよう、呼び出す関数を削減します。たとえば現代の Intel x86マシン上であれば、SSEまたはAVXのベクタ拡張を使用し命令(instruction)を削減します。これにより非ベクタコードを凌ぐパフォーマンスの改善を見込めます。</p>
<p><code class="samp docutils literal"><em><span class="pre">&lt;V&gt;</span></em></code> が構造体であり、メンバ <code class="samp docutils literal"><em><span class="pre">&lt;m1&gt;</span></em><span class="pre">,</span> <em><span class="pre">&lt;m2&gt;</span></em><span class="pre">,</span> <span class="pre">...</span> <em><span class="pre">&lt;mN&gt;</span></em></code> が全て同一の（整数、浮動小数点数の）型 <code class="samp docutils literal"><em><span class="pre">&lt;T&gt;</span></em></code> であるなら、以下の関数が利用可能です:</p>
<dl class="function">
<dt id="vecAdd">
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecAdd</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span><a class="headerlink" href="#vecAdd" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">+</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">+</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">+</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecAdd</code><span class="sig-paren">(</span><em>&lt;T&gt; k</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">k</span> <span class="pre">+</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">+</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">+</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecAdd</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;T&gt; k</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">+</span> <span class="pre">k</span></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">+</span> <span class="pre">k</span></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">+</span> <span class="pre">k</span></code> を返します</p>
</dd></dl>

<dl class="function">
<dt id="vecSub">
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecSub</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span><a class="headerlink" href="#vecSub" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">-</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">-</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">-</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecSub</code><span class="sig-paren">(</span><em>&lt;T&gt; k</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">k</span> <span class="pre">-</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">-</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">-</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecSub</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;T&gt; k</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">-</span> <span class="pre">k</span></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">-</span> <span class="pre">k</span></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">-</span> <span class="pre">k</span></code> を返します</p>
</dd></dl>

<dl class="function">
<dt id="vecMul">
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecMul</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span><a class="headerlink" href="#vecMul" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">*</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">*</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">*</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecMul</code><span class="sig-paren">(</span><em>&lt;T&gt; k</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">k</span> <span class="pre">*</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">*</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">*</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecMul</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;T&gt; k</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">*</span> <span class="pre">k</span></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">*</span> <span class="pre">k</span></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">*</span> <span class="pre">k</span></code> を返します</p>
</dd></dl>

<dl class="function">
<dt id="vecDiv">
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecDiv</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span><a class="headerlink" href="#vecDiv" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">/</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">/</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">/</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecDiv</code><span class="sig-paren">(</span><em>&lt;T&gt; k</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">k</span> <span class="pre">/</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">/</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">/</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecDiv</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;T&gt; k</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">/</span> <span class="pre">k</span></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">/</span> <span class="pre">k</span></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">/</span> <span class="pre">k</span></code> を返します</p>
</dd></dl>

<dl class="function">
<dt id="vecRem">
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecRem</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span><a class="headerlink" href="#vecRem" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">%</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">%</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">%</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecRem</code><span class="sig-paren">(</span><em>&lt;T&gt; k</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">k</span> <span class="pre">%</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">%</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">%</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecRem</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;T&gt; k</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">%</span> <span class="pre">k</span></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">%</span> <span class="pre">k</span></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">%</span> <span class="pre">k</span></code> を返します</p>
</dd></dl>

<p><code class="docutils literal"><span class="pre">&lt;T&gt;</span></code> が整数型であれば、更に追加で以下の関数が利用可能です。</p>
<dl class="function">
<dt id="vecBitOr">
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecBitOr</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span><a class="headerlink" href="#vecBitOr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">|</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">|</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">|</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecBitOr</code><span class="sig-paren">(</span><em>&lt;T&gt; k</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">k</span> <span class="pre">|</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">|</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">|</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecBitOr</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;T&gt; k</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">|</span> <span class="pre">k</span></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">|</span> <span class="pre">k</span></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">|</span> <span class="pre">k</span></code> を返します</p>
</dd></dl>

<dl class="function">
<dt id="vecBitAnd">
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecBitAnd</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span><a class="headerlink" href="#vecBitAnd" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">&amp;</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">&amp;</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">&amp;</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecBitAnd</code><span class="sig-paren">(</span><em>&lt;T&gt; k</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">k</span> <span class="pre">&amp;</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">&amp;</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">&amp;</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecBitAnd</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;T&gt; k</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">&amp;</span> <span class="pre">k</span></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">&amp;</span> <span class="pre">k</span></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">&amp;</span> <span class="pre">k</span></code> を返します</p>
</dd></dl>

<dl class="function">
<dt id="vecBitXor">
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecBitXor</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span><a class="headerlink" href="#vecBitXor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">^</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">^</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">^</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code></p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecBitXor</code><span class="sig-paren">(</span><em>&lt;T&gt; k</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">k</span> <span class="pre">^</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">^</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">^</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecBitXor</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;T&gt; k</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">^</span> <span class="pre">k</span></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">^</span> <span class="pre">k</span></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">^</span> <span class="pre">k</span></code> を返します</p>
</dd></dl>

<dl class="function">
<dt id="vecShl">
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecShl</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span><a class="headerlink" href="#vecShl" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">&lt;&lt;</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">&lt;&lt;</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">&lt;&lt;</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecShl</code><span class="sig-paren">(</span><em>&lt;T&gt; k</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">k</span> <span class="pre">&lt;&lt;</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">&lt;&lt;</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">&lt;&lt;</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecShl</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;T&gt; k</em><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">&lt;&lt;</span> <span class="pre">k</span></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">&lt;&lt;</span> <span class="pre">k</span></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">&lt;&lt;</span> <span class="pre">k</span></code> を返します</p>
</dd></dl>

<dl class="function">
<dt id="vecShr">
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecShr</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span><a class="headerlink" href="#vecShr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">&gt;&gt;</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">&gt;&gt;</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">&gt;&gt;</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecShr</code><span class="sig-paren">(</span><em>&lt;T&gt; k</em>, <em>&lt;V&gt; rhs</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">k</span> <span class="pre">&gt;&gt;</span> <span class="pre">rhs.</span><em><span class="pre">m1</span></em></code>, <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">&gt;&gt;</span> <span class="pre">rhs.</span><em><span class="pre">m2</span></em></code>, ... <code class="samp docutils literal"><span class="pre">k</span> <span class="pre">&gt;&gt;</span> <span class="pre">rhs.</span><em><span class="pre">mN</span></em></code> を返します</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">&lt;V&gt; </em><code class="descname">vecShr</code><span class="sig-paren">(</span><em>&lt;V&gt; lhs</em>, <em>&lt;T&gt; k</em><span class="sig-paren">)</span></dt>
<dd><p><code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m1</span></em> <span class="pre">&gt;&gt;</span> <span class="pre">k</span></code>, <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">m2</span></em> <span class="pre">&gt;&gt;</span> <span class="pre">k</span></code>, ... <code class="samp docutils literal"><span class="pre">lhs.</span><em><span class="pre">mN</span></em> <span class="pre">&gt;&gt;</span> <span class="pre">k</span></code> を返します</p>
</dd></dl>

</div>
<div class="section" id="conversion-functions">
<span id="conversion-funcs"></span><h3>変換関数<a class="headerlink" href="#conversion-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="function">
<dt>
<code class="descname">function &lt;Type&gt;.appendDesc(io String string)</code></dt>
<dd><div class="versionadded">
<p><span class="versionmodified">バージョン 1.12.0 で追加.</span></p>
</div>
<p><code class="code docutils literal"><span class="pre">appendDesc</span></code> メソッドを与えられた型から <code class="code docutils literal"><span class="pre">String</span></code> へと変換するために呼びます。独自の <code class="code docutils literal"><span class="pre">appendDesc</span></code> メソッドを記述し、この変換をカスタマイズすることができます。以下に例示します:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Custom appendDesc Method</span>
<span class="cm">*/</span>

<span class="kr">struct</span> <span class="nx">Vec3</span> <span class="p">{</span> <span class="kr">Float32</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">;</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nx">Vec3</span><span class="p">(</span><span class="kr">Float32</span> <span class="nx">x</span><span class="p">,</span> <span class="kr">Float32</span> <span class="nx">y</span><span class="p">,</span> <span class="kr">Float32</span> <span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Vec3</span><span class="p">.</span><span class="nx">appendDesc</span><span class="p">(</span><span class="k">io</span> <span class="kr">String</span> <span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">string</span> <span class="o">+=</span> <span class="s2">&quot;vec3:[&quot;</span><span class="p">;</span>
  <span class="nx">string</span> <span class="o">+=</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
  <span class="nx">string</span> <span class="o">+=</span> <span class="s2">&quot;:&quot;</span><span class="p">;</span>
  <span class="nx">string</span> <span class="o">+=</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
  <span class="nx">string</span> <span class="o">+=</span> <span class="s2">&quot;:&quot;</span><span class="p">;</span>
  <span class="nx">string</span> <span class="o">+=</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span><span class="p">;</span>
  <span class="nx">string</span> <span class="o">+=</span> <span class="s2">&quot;]&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Vec3</span> <span class="nx">vec3</span><span class="p">(</span><span class="mf">6.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.4</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">vec3</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">vec3:[+6.7:-9.4:+2.3]</span>

<span class="cm">*/</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="hex">
<em class="property">function </em><em class="property">String </em><code class="descname">hex</code><span class="sig-paren">(</span><em>UInt8 n</em><span class="sig-paren">)</span><a class="headerlink" href="#hex" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">String </em><code class="descname">hex</code><span class="sig-paren">(</span><em>UInt16 n</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">function </em><em class="property">String </em><code class="descname">hex</code><span class="sig-paren">(</span><em>UInt32 n</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">function </em><em class="property">String </em><code class="descname">hex</code><span class="sig-paren">(</span><em>UInt64 n</em><span class="sig-paren">)</span></dt>
<dd><p>符号なし整数を16進数文字列値の表現へと変換します。</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">function </em><em class="property">String </em><code class="descname">hex</code><span class="sig-paren">(</span><em>SInt8 n</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">function </em><em class="property">String </em><code class="descname">hex</code><span class="sig-paren">(</span><em>SInt16 n</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">function </em><em class="property">String </em><code class="descname">hex</code><span class="sig-paren">(</span><em>SInt32 n</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">function </em><em class="property">String </em><code class="descname">hex</code><span class="sig-paren">(</span><em>SInt64 n</em><span class="sig-paren">)</span></dt>
<dd><p>整数を16進数文字列値の表現へと変換します。 <code class="docutils literal"><span class="pre">n</span></code> が対応する符号なし整数であるかのように出力されます。つまり負の値は考慮されません。</p>
</dd></dl>

<dl class="function">
<dt id="bitcastUIntToFloat">
<em class="property">function </em><em class="property">Float32 </em><code class="descname">bitcastUIntToFloat</code><span class="sig-paren">(</span><em>UInt32 n</em><span class="sig-paren">)</span><a class="headerlink" href="#bitcastUIntToFloat" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">Float64 </em><code class="descname">bitcastUIntToFloat</code><span class="sig-paren">(</span><em>UInt64 n</em><span class="sig-paren">)</span></dt>
<dd><p>符号なし整数を同じ幅をもつ浮動小数点数へとビットキャストします。これはKL自体のユニットテストを行う際とても有用な、非数値変換です。</p>
</dd></dl>

<dl class="function">
<dt id="bitcastFloatToUInt">
<em class="property">function </em><em class="property">UInt32 </em><code class="descname">bitcastFloatToUInt</code><span class="sig-paren">(</span><em>Float32 x</em><span class="sig-paren">)</span><a class="headerlink" href="#bitcastFloatToUInt" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">function </em><em class="property">UInt64 </em><code class="descname">bitcastFloatToUInt</code><span class="sig-paren">(</span><em>Float64 x</em><span class="sig-paren">)</span></dt>
<dd><p>浮動小数点数を同じ幅をもつ符号なし整数へとビットキャストします。これはKL自体のユニットテストを行う際とても有用な、非数値変換です。</p>
</dd></dl>

</div>
<div class="section" id="thread-core-related-functions">
<h3>スレッド,コア関連の関数<a class="headerlink" href="#thread-core-related-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="function">
<dt id="getThreadIndex">
<em class="property">function </em><em class="property">UInt16 </em><code class="descname">getThreadIndex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#getThreadIndex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在実行中のスレッドインデックス番号を返します。この値は  0 から <a class="reference internal" href="#getThreadCount" title="getThreadCount"><code class="xref kl kl-func docutils literal"><span class="pre">getThreadCount()</span></code></a>-1 であることが保証されます。</p>
<p>PEXワークロードにおける、ある2つの同時実行スレッドおいて、この関数はそれぞれ異なる値を返すことが保証されます。</p>
</dd></dl>

<dl class="function">
<dt id="getThreadCount">
<em class="property">function </em><em class="property">UInt16 </em><code class="descname">getThreadCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#getThreadCount" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#getThreadIndex" title="getThreadIndex"><code class="xref kl kl-func docutils literal"><span class="pre">getThreadIndex()</span></code></a> で返る最大値を返します。</p>
</dd></dl>

<dl class="function">
<dt id="getCoreCount">
<em class="property">function </em><em class="property">UInt16 </em><code class="descname">getCoreCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#getCoreCount" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>マシンのCPUコア数を返します。</p>
</dd></dl>

<dl class="function">
<dt id="atomicMemoryBarrier">
<em class="property">function </em><code class="descname">atomicMemoryBarrier</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#atomicMemoryBarrier" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Produces an atomic memory barrier at this point in the code.  The barrier
is a &#8220;full&#8221; (sequentially consistent) barrier.</p>
</dd></dl>

<dl class="function">
<dt id="atomicMemoryBarrier_Acquire">
<em class="property">function </em><code class="descname">atomicMemoryBarrier_Acquire</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#atomicMemoryBarrier_Acquire" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Produces an atomic memory barrier at this point in the code.  The barrier
is a &#8220;acquire&#8221; barrier.</p>
</dd></dl>

<dl class="function">
<dt id="atomicMemoryBarrier_Release">
<em class="property">function </em><code class="descname">atomicMemoryBarrier_Release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#atomicMemoryBarrier_Release" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Produces an atomic memory barrier at this point in the code.  The barrier
is a &#8220;release&#8221; barrier.</p>
</dd></dl>

<dl class="function">
<dt id="atomicMemoryBarrier_AcquireRelease">
<em class="property">function </em><code class="descname">atomicMemoryBarrier_AcquireRelease</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#atomicMemoryBarrier_AcquireRelease" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Produces an atomic memory barrier at this point in the code.  The barrier
is a &#8220;acquire-release&#8221; barrier.</p>
</dd></dl>

</div>
<div class="section" id="performance-counter-functions">
<h3>パフォーマンス計測関数<a class="headerlink" href="#performance-counter-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>KLは、高性能ななシステムタイマ情報へアクセスを提供し、KLコード中から、操作に要する時間の情報についてアクセスすることができます。</p>
<dl class="function">
<dt id="getCurrentTicks">
<em class="property">function </em><em class="property">UInt64 </em><code class="descname">getCurrentTicks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#getCurrentTicks" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>パフォーマンスカウンタの現在の値を返します。この値はそれ自体に意味があるわけでありません(単位はundefined)。ですが <code class="docutils literal"><span class="pre">getSecondsBetweenTicks()</span></code> の呼び出す中に使用することで、経過時間の絶対時間で計測します。  <code class="docutils literal"><span class="pre">getCurrentTicks()</span></code> で返る値は、システム時計（壁時計）の変更の影響を受けません。</p>
</dd></dl>

<dl class="function">
<dt id="getSecondsBetweenTicks">
<em class="property">function </em><em class="property">Float64 </em><code class="descname">getSecondsBetweenTicks</code><span class="sig-paren">(</span><em>UInt64 start</em>, <em>UInt64 end</em><span class="sig-paren">)</span><a class="headerlink" href="#getSecondsBetweenTicks" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>2つのパフォーマンスカウンタ間の値を「秒」で返します。計測解像度は、少なくとも100万分の1秒であることが保証されます。</p>
</dd></dl>

<p>パフォーマンス計測関数の使用例：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">operator</span> <span class="n">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">UInt64</span> <span class="n">start</span> <span class="o">=</span> <span class="n">getCurrentTicks</span><span class="p">();</span>
  <span class="o">//</span> <span class="n">Do</span> <span class="n">nothing</span><span class="o">...</span>
  <span class="n">UInt64</span> <span class="n">end</span> <span class="o">=</span> <span class="n">getCurrentTicks</span><span class="p">();</span>
  <span class="n">report</span><span class="p">(</span><span class="s2">&quot;Elapsed time: &quot;</span> <span class="o">+</span> <span class="n">getSecondsBetweenTicks</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; seconds&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>出力:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Elapsed</span> <span class="n">time</span><span class="p">:</span> <span class="mf">4.1e-08</span> <span class="n">seconds</span>
</pre></div>
</div>
</div>
<div class="section" id="memory-usage-functions">
<h3>Memory Usage Functions<a class="headerlink" href="#memory-usage-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="function">
<dt id="klHeapInUse">
<em class="property">function </em><em class="property">UInt64 </em><code class="descname">klHeapInUse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#klHeapInUse" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns the number of bytes currently allocated on the KL heap.  Memory is allocated on the KL heap in order to provide memory for variable arrays, dictionaries, objects, most strings, and some other less-commonly used types.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">This function cannot be called on the GPU</p>
</div>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: klHeapInUse()</span>
<span class="cm">*/</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;klHeapInUse() before: &quot;</span> <span class="o">+</span> <span class="nx">klHeapInUse</span><span class="p">());</span>
  <span class="kr">Float32</span> <span class="nx">a</span><span class="p">[](</span><span class="mi">16</span><span class="p">);</span> <span class="c1">// allocates some memory on the KL heap</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;klHeapInUse() after: &quot;</span> <span class="o">+</span> <span class="nx">klHeapInUse</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">klHeapInUse() before: 0</span>
<span class="cm">klHeapInUse() after: 104</span>

<span class="cm">*/</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="fabric-context-functions">
<h3>Fabric Context 関数<a class="headerlink" href="#fabric-context-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Fabric Core コンテキストとやり取りするための関数です。</p>
<dl class="function">
<dt id="fabricCoreContextID">
<em class="property">function </em><em class="property">String </em><code class="descname">fabricCoreContextID</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fabricCoreContextID" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Fabric Core コンテキストIDを文字列で返します。このコンテキストIDは、新規のFabric Coreクライアントと、既存のコンテキストをバインドするため使用します。</p>
</dd></dl>

</div>
</div>
<div class="section" id="named-constants">
<span id="klpg-global-named-constants"></span><span id="index-19"></span><h2>名前付き定数<a class="headerlink" href="#named-constants" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>KLにおいて <em class="dfn">named constant</em> とは、式中より名前により参照されるある値のことであり、実行時に変更することができない値です。名前付き定数は、基本的に read-only な変数です；しかし、KLコンパイラにとってその値が不変であることがわかっているため、ただの変数のかわりに名前付き定数を使用すると、高速なコードとなります。スカラ、あるいは配列の名前付き定数を宣言することができます。</p>
<p>名前付き定数はどのスコープ中（グローバルスコープも含む）にも宣言が可能です。（スコープについては <a class="reference internal" href="scopes-namespaces.html#scope"><span class="std std-ref">Scoping Rules</span></a> 参照）名前付き定数は、宣言されたスコープ中からのみ可視となります。</p>
<p>スカラの名前付き定数は以下の形態をとります:</p>
<pre class="literal-block">
const <code class="samp docutils literal"><em><span class="pre">Type</span></em></code> <code class="samp docutils literal"><em><span class="pre">name</span></em></code> = <code class="samp docutils literal"><em><span class="pre">expr</span></em></code>;
</pre>
<p>配列の名前付き定数は以下の形式を取ります:</p>
<pre class="literal-block">
const <code class="samp docutils literal"><em><span class="pre">Type</span></em></code> <code class="samp docutils literal"><em><span class="pre">name</span></em></code>[] = [
  <code class="samp docutils literal"><em><span class="pre">expr1</span></em></code>, <code class="samp docutils literal"><em><span class="pre">expr2</span></em></code>, ..., <code class="samp docutils literal"><em><span class="pre">exprN</span></em></code>
];
</pre>
<p>どちらのケースも、 <code class="samp docutils literal"><em><span class="pre">Type</span></em></code> は boolean, integer, floating-point, string いずれかの型である; <code class="samp docutils literal"><em><span class="pre">name</span></em></code> は識別子;  <code class="samp docutils literal"><em><span class="pre">expr</span></em></code> は <cite>{Type}</cite> 型の定数として評価される定数を含む式である必要があります。スカラの名前付き定数の場合、その型は <code class="samp docutils literal"><em><span class="pre">Type</span></em></code> です。配列の名前付き定数の場合、その型は <code class="samp docutils literal"><em><span class="pre">Type</span></em></code> 型の要素の固定長配列です; この配列のサイズは、カッコ内に与えられた初期化する値の数と同一になります。</p>
<p>以下のどれかをするとコンパイル時にエラーとなります。</p>
<ul class="simple">
<li><p class="first">名前付き定数への代入</p>
</li>
<li><p class="first">関数の <code class="docutils literal"><span class="pre">io</span></code> パラメータとして名前付き定数を渡す</p>
</li>
<li><p class="first">既存の関数（あるいはオペレータ、他の名前付き定数）と同名でグローバル名前付き定数を宣言</p>
</li>
<li><p class="first">同一スコープ内の、既存の変数（あるいは他の名前付き定数）と同名で非グローバルな名前付き定数を宣言</p>
</li>
</ul>
<p>名前付き定数の例:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="kr">String</span> <span class="nx">MODULE_NAME</span> <span class="o">=</span> <span class="s2">&quot;KL&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="kr">String</span> <span class="nx">PREFIX</span> <span class="o">=</span> <span class="nx">MODULE_NAME</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="kr">UInt32</span> <span class="nx">twoToTheSixteen</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
<span class="kr">const</span> <span class="kr">Float32</span> <span class="nx">familiarValues</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">3.141</span><span class="p">,</span> <span class="mf">2.718</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mf">7.4</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.4</span><span class="p">];</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">PREFIX</span> <span class="o">+</span> <span class="s2">&quot;twoToTheSixteen = &quot;</span> <span class="o">+</span> <span class="nx">twoToTheSixteen</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">PREFIX</span> <span class="o">+</span> <span class="s2">&quot;familiarValues = &quot;</span> <span class="o">+</span> <span class="nx">familiarValues</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kr">UInt32</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="kr">UInt32</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kr">const</span> <span class="kr">UInt32</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="nb">report</span><span class="p">(</span><span class="nx">PREFIX</span> <span class="o">+</span> <span class="s2">&quot;a*&quot;</span><span class="o">+</span><span class="nx">i</span><span class="o">+</span><span class="s2">&quot;+b = &quot;</span><span class="o">+</span><span class="p">(</span><span class="nx">a</span><span class="o">*</span><span class="nx">i</span><span class="o">+</span><span class="nx">b</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>出力：</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>KL: twoToTheSixteen = 65536
KL: familiarValues = [+3.141000,+2.717999,+6.529411]
KL: a*0+b = 4
KL: a*1+b = 7
KL: a*2+b = 10
KL: a*3+b = 13
</pre></div>
</div>
<span class="target" id="klpg-named-constants-predefined"></span><div class="section" id="predefined-constants">
<span id="index-20"></span><h3>事前定義された定数<a class="headerlink" href="#predefined-constants" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>全KLプログラムで利用可能な種々の事前定義された定数があります。</p>
<div class="section" id="fabric-version-pre-defined-constants">
<h4>Fabric バージョン Pre-Defined 定数<a class="headerlink" href="#fabric-version-pre-defined-constants" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The three constants <code class="docutils literal"><span class="pre">FabricVersionMaj</span></code>, <code class="docutils literal"><span class="pre">FabricVersionMin</span></code> and <code class="docutils literal"><span class="pre">FabricVersionRev</span></code> are three predefined constants of type <code class="docutils literal"><span class="pre">UInt8</span></code> that are the major, minor and revision components of the running Fabric version.  For example, this documentation was built for Fabric version 2.4.0, and so KL code executed in this version will have <code class="docutils literal"><span class="pre">FabricVersionMaj</span> <span class="pre">=</span> <span class="pre">|FABRIC_VERSION_MAJ|</span></code>, <code class="docutils literal"><span class="pre">FabricVersionMin</span> <span class="pre">=</span> <span class="pre">|FABRIC_VERSION_MIN|</span></code> and <code class="docutils literal"><span class="pre">FabricVersionRev</span> <span class="pre">=</span> <span class="pre">|FABRIC_VERSION_REV|</span></code>.</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;FabricVersionMaj = &quot;</span> <span class="o">+</span> <span class="nx">FabricVersionMaj</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;FabricVersionMin = &quot;</span> <span class="o">+</span> <span class="nx">FabricVersionMin</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;FabricVersionRev = &quot;</span> <span class="o">+</span> <span class="nx">FabricVersionRev</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="integer-limit-pre-defined-constants">
<h4>整数限界の事前定義定数<a class="headerlink" href="#integer-limit-pre-defined-constants" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>全ての整数型 <code class="docutils literal"><span class="pre">&lt;IntTy&gt;</span></code> には事前定義された整数定数 <code class="docutils literal"><span class="pre">&lt;IntTy&gt;Max</span></code> があり、整数が許容する最大値を示します。符号付き整数では追加で  <code class="docutils literal"><span class="pre">&lt;IntTy&gt;Min</span></code> があり、整数の許容する最小値を示します。どちらでも整数定数の型はその整数自身の型です。例:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;UInt8Max=&quot;</span> <span class="o">+</span> <span class="nx">UInt8Max</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;UInt16Max=&quot;</span> <span class="o">+</span> <span class="nx">UInt16Max</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;UInt32Max=&quot;</span> <span class="o">+</span> <span class="nx">UInt32Max</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;UInt64Max=&quot;</span> <span class="o">+</span> <span class="nx">UInt64Max</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;SInt8Min=&quot;</span> <span class="o">+</span> <span class="nx">SInt8Min</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;SInt8Max=&quot;</span> <span class="o">+</span> <span class="nx">SInt8Max</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;SInt16Min=&quot;</span> <span class="o">+</span> <span class="nx">SInt16Min</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;SInt16Max=&quot;</span> <span class="o">+</span> <span class="nx">SInt16Max</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;SInt32Min=&quot;</span> <span class="o">+</span> <span class="nx">SInt32Min</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;SInt32Max=&quot;</span> <span class="o">+</span> <span class="nx">SInt32Max</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;SInt64Min=&quot;</span> <span class="o">+</span> <span class="nx">SInt64Min</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;SInt64Max=&quot;</span> <span class="o">+</span> <span class="nx">SInt64Max</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>出力結果</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>UInt8Max=255
UInt16Max=65535
UInt32Max=4294967295
UInt64Max=18446744073709551615
SInt8Min=-128
SInt8Max=127
SInt16Min=-32768
SInt16Max=32767
SInt32Min=-2147483648
SInt32Max=2147483647
SInt64Min=-9223372036854775808
SInt64Max=9223372036854775807
</pre></div>
</div>
</div>
<div class="section" id="the-func-pre-defined-constants">
<h4><code class="docutils literal"><span class="pre">FUNC</span></code> 事前定義定数<a class="headerlink" href="#the-func-pre-defined-constants" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>KLコンパイラは、関数のスタート時その関数を説明する文字列定数として、自動的に <code class="docutils literal"><span class="pre">FUNC</span></code> を事前定義します。以下のコードにしたがいます:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="kr">Float32</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;This function is: &quot;</span> <span class="o">+</span> <span class="kr">FUNC</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>出力結果</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>This function is: function foo(Float32)
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="importing-functionality-with-require">
<span id="klpg-require"></span><span id="index-21"></span><h2><code class="docutils literal"><span class="pre">require</span></code> による機能のインポート<a class="headerlink" href="#importing-functionality-with-require" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Fabric との統合により、――たとえばKLの型と（もしくは） Fabricエクステンションを継承するため―― 外部に定義されたKLコードを現在のソースコードへと提供することが可能となります。これらの型、コードを現在のソースファイルで使用するには、 <code class="docutils literal"><span class="pre">require</span></code> 文を使用します; Pythonにおける <code class="docutils literal"><span class="pre">import</span></code> 文と似ています。</p>
<p><cite>require`</cite> 文の後には、登録された型（registered type）、エクステンションの名前を続けます。例えば、 &#8220;Math&#8221; という名のエクステンションと &#8220;RegType&#8221; という名の登録された方に提供されているの機能を含めたいのであれば、このようにプログラムをはじめます:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">require</span> <span class="n">Math</span><span class="p">,</span> <span class="n">RegType</span><span class="p">;</span>
</pre></div>
</div>
<p>どの <code class="docutils literal"><span class="pre">require</span></code> 文も 関連する機能をつかうKLプログラム中、最上部に記載します。複数の <code class="docutils literal"><span class="pre">require</span></code> 文を望みの数記述することもできます。</p>
</div>
<div class="section" id="using-require-with-version-information">
<span id="klpg-require-versioning"></span><h2>バージョン情報と共に <code class="docutils literal"><span class="pre">require</span></code> を使用する<a class="headerlink" href="#using-require-with-version-information" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ディフォルトで <code class="docutils literal"><span class="pre">require</span></code> 文は、エクステンションの利用可能な最新バージョンのを読み込みに行きます。 <code class="code docutils literal"><span class="pre">ExtensionName</span></code> エクステンションに2つのバージョン  <code class="code docutils literal"><span class="pre">&quot;1.0.0&quot;</span></code> と <code class="code docutils literal"><span class="pre">&quot;1.2.1&quot;</span></code> があるとします、</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">require</span> <span class="nx">ExtensionName</span><span class="p">;</span>
</pre></div>
</div>
<p>とすると、 <code class="code docutils literal"><span class="pre">&quot;1.2.1&quot;</span></code> バージョンのものが読み込まれる結果となります。もし特定バージョンのものを読み込みたいのであれば、以下のシンタックスにより</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">require</span> <span class="nx">ExtensionName</span><span class="o">:</span><span class="s2">&quot;=1.0.0&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>指定した <code class="code docutils literal"><span class="pre">&quot;1.0.0&quot;</span></code> バージョンが読み込まれます。そのバージョンが存在しない場合、エラーが投げられます。あるいは、エクステンションが指定バージョン以上であることが望みであれば、大なり小なり不等号記号を使用し、以下のようにします:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">require</span> <span class="nx">ExtensionName</span><span class="o">:</span><span class="s2">&quot;&gt;1.0.0&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>指定のバージョン以下、（以上）が存在しない場合は、やはりエラーが投げられます。この例ではバージョン <code class="code docutils literal"><span class="pre">&quot;1.2.1&quot;</span></code> が読み込まれます。</p>
<p>さらに、プリプロセッサ文を使用しオプションのKLコードを追加したり、あるいは、エクステンションのバージョンに基づいた振舞のスイッチをさせたりすることができます。 <code class="code docutils literal"><span class="pre">EXT_VER_IF:</span> <span class="pre">と</span> <span class="pre">:code:`EXT_VER_ENDIF</span></code> 文を使用し、等号、大なり、小なり記号を利用できます。</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="kr">require</span> <span class="nx">ExtensionName</span><span class="p">;</span>

<span class="nx">EXT_VER_IF</span> <span class="nx">ExtensionName</span><span class="o">:</span><span class="s2">&quot;&gt;1.0.0&quot;</span>

<span class="kd">function</span> <span class="nx">dummyFunction</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="s1">&#39;Found an extension version for &quot;ExtensionName&quot; higher than &quot;1.0.0&quot;&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">EXT_VER_ENDIF</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>

<span class="nx">EXT_VER_IF</span> <span class="nx">ExtensionName</span><span class="o">:</span><span class="s2">&quot;&gt;1.0.0&quot;</span>

  <span class="nx">dummyFunction</span><span class="p">();</span>

<span class="nx">EXT_VER_ENDIF</span>

<span class="p">}</span>
</pre></div>
</div>
<p><code class="code docutils literal"><span class="pre">dummy</span></code> 関数の定義と呼び出しは、エクステンション <code class="code docutils literal"><span class="pre">ExtensionName</span></code> のバージョンが <code class="code docutils literal"><span class="pre">&quot;1.0.0&quot;</span></code> 以上の場合にのみ、上記の例では発生します。</p>
<p>If you wish to check the version of Fabric itself, use <code class="code docutils literal"><span class="pre">Fabric</span></code> as the extension name:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">** Example: Conditional Compilation using Preprocessor Statements</span>
<span class="cm">*/</span>

<span class="nx">EXT_VER_IF</span> <span class="nx">Fabric</span> <span class="o">:</span> <span class="s2">&quot;&lt; 2.0.0&quot;</span>
<span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;Version is &lt; 2.0.0&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">EXT_VER_ENDIF</span>

<span class="nx">EXT_VER_IF</span> <span class="nx">Fabric</span> <span class="o">:</span> <span class="s2">&quot;&gt;= 2.0.0&quot;</span>
<span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;Version is &gt;= 2.0.0&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">EXT_VER_ENDIF</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">Version is &gt;= 2.0.0</span>

<span class="cm">*/</span>
</pre></div>
</div>
<p>バージョン情報をエクステンションに埋め込むための、より詳しい情報については <a class="reference internal" href="../ExtensionAuthoringGuide/fpm.html#exts-versioning"><span class="std std-ref">version ：エクステンション・バージョニングの指定（任意）</span></a> をご参照ください。</p>
</div>
<div class="section" id="extension-versioning-environment-variables">
<span id="klpg-require-versioning-envvars"></span><h2>エクステンションのバージョニング環境変数<a class="headerlink" href="#extension-versioning-environment-variables" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>上述の <a class="reference internal" href="#klpg-require-versioning"><span class="std std-ref">バージョン情報と共に require を使用する</span></a> の機能につけくわえ、環境変数の設定によっても <code class="code docutils literal"><span class="pre">require</span></code> 文を駆動することができます。環境変数を使用するにはいくつか方法があります。</p>
<p>１番目のアプローチは、各エクステンションに対し単一の環境変数を使用します。環境変数の定義は次のようにします:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">FABRIC_EXT_VER_EXTENSIONNAME</span><span class="o">=</span><span class="s2">&quot;=1.0.0&quot;</span>
</pre></div>
</div>
<p>２番めのアプローチは、とくに、与えられたあるビルドセットに対し大量の環境変数を切り替える必要があるような場合、とてもぴったりです。（オプション）はじめに <span class="target" id="index-38"></span><code class="xref std std-envvar docutils literal"><span class="pre">FABRIC_EXT_VER_PREFIX</span></code> と <span class="target" id="index-39"></span><code class="xref std std-envvar docutils literal"><span class="pre">FABRIC_EXT_VER_SUFFIX</span></code> 環境変数を指定します; この変数に、追加の環境変数を検索する際に使用される、接頭語と接尾語を設定します。指定しない場合はディフォルト値が使用されます。</p>
<p>つぎに、接頭語と接尾語とエクステンション名を使用し、各エクステンションに対し環境変数 ―結果としてバージョン情報含むことになる― をそれぞれ指定します。ディフォルトの接頭語と接尾語を用いた例:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">FABRIC_EXT_VER_EXTENSIONNAME</span><span class="o">=</span><span class="s2">&quot;=1.0.0&quot;</span>
</pre></div>
</div>
<p>接頭語と接尾語を利用するようにした例:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">FABRIC_EXT_VER_PREFIX</span><span class="o">=</span><span class="s2">&quot;COMPANY_&quot;</span>
<span class="nb">export</span> <span class="nv">FABRIC_EXT_VER_SUFFIX</span><span class="o">=</span><span class="s2">&quot;_VER_INFO&quot;</span>
<span class="nb">export</span> <span class="nv">COMPANY_EXTENSIONNAME_VER_INFO</span><span class="o">=</span><span class="s2">&quot;=1.0.0&quot;</span>
</pre></div>
</div>
<p>これは、エクステンションの読み込みメカニズム中、以下のように解決されます。はじめに <span class="target" id="index-40"></span><code class="xref std std-envvar docutils literal"><span class="pre">FABRIC_EXT_VER_PREFIX</span></code> と <span class="target" id="index-41"></span><code class="xref std std-envvar docutils literal"><span class="pre">FABRIC_EXT_VER_SUFFIX</span></code> 環境変数を解決します。次に以上にもとづく名前をもつ <span class="target" id="index-42"></span><code class="xref std std-envvar docutils literal"><span class="pre">COMPANY_EXTENSIONNAME_VER_INFO</span></code> 変数によって、利用可能な２つのバージョンのうち 1.0.0 が使われるべきであるとして解決します。</p>
<p>３番めのアプローチは、エクステンション名と使用するバージョン間のマッピングを提供する、補助 json ファイルを利用する方法です。この jsonファイルのパスは、環境変数 <span class="target" id="index-43"></span><code class="xref std std-envvar docutils literal"><span class="pre">FABRIC_EXT_VERFILE</span></code> で指定する必要があります。このファイルの内容は、以下のようにします:</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;Alembic&quot;</span><span class="o">:</span> <span class="s2">&quot;&gt;=1.0&quot;</span><span class="p">,</span>
  <span class="s2">&quot;FBX&quot;</span><span class="o">:</span> <span class="s2">&quot;&gt;=1.1&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>４番め（最後）のアプローチは、 <span class="target" id="index-44"></span><code class="xref std std-envvar docutils literal"><span class="pre">FABRIC_EXT_OVERRIDE</span></code> 環境変数を設定します。この変数は、「必ず一緒に読み込まれるエクステンションのセット」を指定するために使用します。各エクステンションにオーバーライドキーを定義(<a class="reference internal" href="../ExtensionAuthoringGuide/fpm.html#exts-versioning"><span class="std std-ref">version ：エクステンション・バージョニングの指定（任意）</span></a> 参照)します。キーが <span class="target" id="index-45"></span><code class="xref std std-envvar docutils literal"><span class="pre">FABRIC_EXT_OVERRIDE</span></code> の値と一致すると、そのエクステンションが、他のエクステンション（あるいはオーバーライドキーがないもの）よりも先に読み込まれます。これにより、より低位のバージョンナンバーを持つエクステンションが読み込まれることになります。以下例:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">FABRIC_EXT_OVERRIDE</span><span class="o">=</span><span class="s2">&quot;MyOverride&quot;</span>
</pre></div>
</div>
<p>オーバーライドキー &#8220;MyOverride&#8221; を持つエクステンション全てを、異なるオーバーライドキーをもつ、同じエクステンションの異なるバージョンよりも優先する結果となります。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">全ての環境変数はすべて大文字を使用します。</p>
</div>
<p>バージョン情報をエクステンションに埋め込むための、より詳しい情報については <a class="reference internal" href="../ExtensionAuthoringGuide/fpm.html#exts-versioning"><span class="std std-ref">version ：エクステンション・バージョニングの指定（任意）</span></a> をご参照ください。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/FE_logo_211_37.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">関数と他のグローバルな宣言</a><ul>
<li><a class="reference internal" href="#functions">関数</a><ul>
<li><a class="reference internal" href="#function-definitions">関数定義</a></li>
<li><a class="reference internal" href="#function-invocations">関数呼び出し</a></li>
<li><a class="reference internal" href="#function-prototypes">関数プロトタイプ</a></li>
</ul>
</li>
<li><a class="reference internal" href="#polymorphism">ポリモーフィズム</a></li>
<li><a class="reference internal" href="#operators">演算子</a></li>
<li><a class="reference internal" href="#constructors">コンストラクタ</a><ul>
<li><a class="reference internal" href="#constructor-declarations">コンストラクタ宣言</a></li>
<li><a class="reference internal" href="#constructor-invocation">コンストラクタ呼び出し</a><ul>
<li><a class="reference internal" href="#naked-initialization">裸の初期化</a></li>
<li><a class="reference internal" href="#assignment-initialization">代入初期化</a></li>
<li><a class="reference internal" href="#invocation-initialization">呼び出し初期化</a></li>
<li><a class="reference internal" href="#temporary-initialization">一時初期化</a></li>
<li><a class="reference internal" href="#base-type-constructors-inheritance">基底型のコンストラクタ（継承）</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#destructors">デストラクタ</a></li>
<li><a class="reference internal" href="#methods">メソッド</a><ul>
<li><a class="reference internal" href="#method-definitions">メソッド定義</a></li>
<li><a class="reference internal" href="#method-invocation">メソッド呼び出し</a></li>
<li><a class="reference internal" href="#methods-taking-read-only-or-read-write-values-for-this">メソッドにおける <code class="docutils literal"><span class="pre">this</span></code> の Read-Only・Read-Write な値としての扱い</a></li>
<li><a class="reference internal" href="#interface-methods-and-inheritance">インターフェイスメソッドと継承</a></li>
<li><a class="reference internal" href="#access-to-methods">メソッドへのアクセス</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overloaded-operators">演算子オーバロード</a><ul>
<li><a class="reference internal" href="#binary-operator-overloads">二項演算子のオーバロード</a></li>
<li><a class="reference internal" href="#unary-operator-overloads">単項演算子のオーバロード</a></li>
<li><a class="reference internal" href="#direct-assignment-overloads">直接代入のオーバロード</a></li>
<li><a class="reference internal" href="#compound-assignment-overloads">複合代入演算子のオーバロード</a></li>
</ul>
</li>
<li><a class="reference internal" href="#inline-functions-and-methods">Inline 関数,メソッド</a></li>
<li><a class="reference internal" href="#built-in-functions-and-methods">組み込み関数・メソッド</a><ul>
<li><a class="reference internal" href="#debugging-functions">デバッグのための関数</a></li>
<li><a class="reference internal" href="#error-status-functions">エラーステータスの関数</a></li>
<li><a class="reference internal" href="#integer-numerical-functions">整数の数値演算関数</a></li>
<li><a class="reference internal" href="#floating-point-numerical-functions">浮動小数点数の数値演算関数</a><ul>
<li><a class="reference internal" href="#trigonometric-functions">三角関数</a></li>
<li><a class="reference internal" href="#exponential-and-logarithmic-functions">指数・対数関数</a></li>
<li><a class="reference internal" href="#non-transcendental-functions">非超越関数</a></li>
<li><a class="reference internal" href="#category-functions">カテゴリ関数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vector-functions">ベクタ関数</a></li>
<li><a class="reference internal" href="#conversion-functions">変換関数</a></li>
<li><a class="reference internal" href="#thread-core-related-functions">スレッド,コア関連の関数</a></li>
<li><a class="reference internal" href="#performance-counter-functions">パフォーマンス計測関数</a></li>
<li><a class="reference internal" href="#memory-usage-functions">Memory Usage Functions</a></li>
<li><a class="reference internal" href="#fabric-context-functions">Fabric Context 関数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#named-constants">名前付き定数</a><ul>
<li><a class="reference internal" href="#predefined-constants">事前定義された定数</a><ul>
<li><a class="reference internal" href="#fabric-version-pre-defined-constants">Fabric バージョン Pre-Defined 定数</a></li>
<li><a class="reference internal" href="#integer-limit-pre-defined-constants">整数限界の事前定義定数</a></li>
<li><a class="reference internal" href="#the-func-pre-defined-constants"><code class="docutils literal"><span class="pre">FUNC</span></code> 事前定義定数</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#importing-functionality-with-require"><code class="docutils literal"><span class="pre">require</span></code> による機能のインポート</a></li>
<li><a class="reference internal" href="#using-require-with-version-information">バージョン情報と共に <code class="docutils literal"><span class="pre">require</span></code> を使用する</a></li>
<li><a class="reference internal" href="#extension-versioning-environment-variables">エクステンションのバージョニング環境変数</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="types.html"
                        title="前の章へ">KLの型システム</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="ops-exprs.html"
                        title="次の章へ">演算子・式</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/KLProgrammingGuide/globals.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    <li><a href="http://docs.fabric-engine.com/FabricEngine/latest/HTML/KLProgrammingGuide/globals.html"
              rel="nofollow">原文公式ページへ移動 (goto official page)</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="ops-exprs.html" title="演算子・式"
             >次へ</a> |</li>
        <li class="right" >
          <a href="types.html" title="KLの型システム"
             >前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Fabric Engine 2.4.0 Unofficial Documentation (ja)</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >KL プログラミングガイド</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2010-2017 Fabric Software Inc.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1 で生成しました。
    </div>
  </body>
</html>